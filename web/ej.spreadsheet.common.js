(function ($, ej, undefined) {
    ej.widget("ejSpreadsheet", "ej.Spreadsheet", {
        _rootCSS: "e-spreadsheet",
        // widget element will be automatically set in this
        element: null,
        _excelFilter: null,
        validTags: ["div"],
        // user defined model will be automatically set in this
        model: null,
        _requiresID: true,
        defaults: {
            allowFreezing: true,
            enableContextMenu: true,
            allowEditing: true,
            allowResizing: true,
            allowMerging: true,
            allowWrap: true,
            allowUndoRedo: true,
            allowClipboard: true,
            allowDataValidation: true,
            allowConditionalFormats: true,
            allowSearching: true,
            allowKeyboardNavigation: true,
            allowAutoFill: true,
            allowSelection: true,
            allowSorting: true,
            allowDragAndDrop: true,
            allowCellType: true,
            allowAutoCellType: false,
            allowCharts: true,
            enablePersistence: false,
            allowCellFormatting: true,
            allowFormulaBar: true,
            showRibbon: true,
            showPager: true,
            allowComments: true,
            allowFiltering: true,
            allowInsert: true,
            allowDelete: true,
            allowFormatPainter: true,
            allowHyperlink: true,
            allowImport: true,
            allowFormatAsTable: true,
            allowAutoSum: true,
            enablePivotTable: false,
            allowLockCell: true,
            enableTouch: true,
            allowOverflow: true,
            allowClear: true,
            allowSparkline: false,
            isReadOnly: false,
            columnCount: 21,
            rowCount: 20,
            rowHeight: 20,
            columnWidth: 64,
            sheetCount: 1,
            undoRedoStep: 20,
            activeSheetIndex: 1,
            apWidth: 300,
            activationPanelWidth: 300,
            _isActPanelVisible: false,
            cssClass: "",
            userName: "",
            locale: "en-US",
            pageSize: "A4",
            sparkDiv: "",
            sheets: [],
            nameManager: [],
            customFormulas: [],
            currentViewData: null,
            query: null,
            create: null,
            actionBegin: null,
            actionComplete: null,
            beforeCellFormat: null,
            cellFormatting: null,
            beforeOpen: null,
            beforeDrop: null,
            drop: null,
            cellEdit: null,
            pagerClick: null,
            cellClick: null,
            _pivotPrint: null,
            tabClick: null,
            tabSelect: null,
            _createPivotTable: null,
            beforePanelOpen: null,
            load: null,
            loadComplete: null,
            editRangeBegin: null,
            editRangeComplete: null,
            cellHover: null,
            menuClick: null,
            contextMenuClick: null,
            ribbonClick: null,
            dragStart: null,
            drag: null,
            cellSave: null,
            beforeCellSelect: null,
            cellSelected: null,
            autoFillBegin: null,
            autoFillComplete: null,
            openFailure: null,
            onImport: null,
            onExport: null,
            beforeImport: null,
            beforeBatchSave: null,
            keyUp: null,
            keyDown: null,
            dragShape: null,
            resizeStart: null,
            resizeEnd: null,
            refresh: null,
            beforeEditComment: null,
            beforeTabClick: null,
            scrollStop: null,
			formulaComputed:null,
            scrollSettings: {
                width: "100%",
                height: "100%",
                allowScrolling: true,
                scrollMode: "infinite",
                isResponsive: true,
                allowVirtualScrolling: true,
                allowSheetOnDemand: false
            },
            pageSettings: {
                pageCount: 10,
                currentPage: 1,
                pagerHeight: 26
            },
            exportSettings: {
                allowExporting: true,
                excelUrl: null,
                csvUrl: null,
                pdfUrl: null,
                password: null
            },
            pictureSettings: {
                allowPictures: true,
                height: 220,
                width: 440
            },
            selectionSettings: {
                selectionType: "default",
                selectionUnit: "multirange",
                enableAnimation: false,
                animationType: "linear",
                animationTime: 0.001,
                activeCell: ""
            },
            chartSettings: {
                height: 220,
                width: 440
            },
            formatSettings: {
                allowFontFamily: true,
                allowDecimalPlaces: true,
                allowCellBorder: true
            },
            autoFillSettings: {
                fillType: "fillseries",
                showFillOptions: true
            },
            "importSettings": {
                importMapper: "",
                importUrl: "",
                password: "",
                allowSheetOnDemand: false,
                importOnLoad: false
            },
            printSettings: {
                allowPageSetup: true,
                allowPageSize: false,
                allowPrinting: true
            },
            ribbonSettings: {
                enableOnDemand: false,
                applicationTab: {
                    type: ej.Ribbon.ApplicationTabType.Backstage,
                    menuSettings: {
                        isAppend: false,
                        dataSource: []
                    }
                }
            }
        },

        dataTypes: {
            pageSize: "enum",
            sheets: "array",
            nameManager: "array",
            scrollSettings: {
                scrollMode: "enum"
            },
            selectionSettings: {
                selectionType: "enum",
                selectionUnit: "enum",
                animationType: "enum"
            },
            autoFillSettings: {
                fillType: "enum"
            }
        },

        _dataSource: function (sheetIdx) {
            return this.getSheet(sheetIdx).dataSource;
        },

        getSheet: function (sheetIdx) {
            return this.model.sheets[this._getSheetIndex(sheetIdx)];
        },

        getSheets: function () {
            return this.model.sheets;
        },

        getSheetElement: function (sheetIdx) {
            return this.element.find("#" + this._id + "_" + this.getSheet(sheetIdx).sheetInfo.value);
        },

        getDataSettings: function (sheetIdx) {
            var setting, arr = [], sheet = this.getSheet(sheetIdx), i = sheet.rangeSettings.length;;
            if (i) {
                while (i--) {
                    setting = sheet.rangeSettings[i];
                    if (setting.dataSource)
                        arr.push(setting);
                }
            }
            return arr.length ? arr : (sheet.dataSource ? [sheet] : null);
        },

        _getJSSheetHeader: function (sheetIdx) {
            return this._sheets[sheetIdx]._sheetHeader;
        },

        _setJSSheetHeader: function (value, sheetIdx) {
            this._sheets[sheetIdx]._sheetHeader = value;
        },

        _getInputBox: function () {
            return this._inputBox;
        },

        _setInputBox: function (elem) {
            this._inputBox = elem;
        },

        _getIndexBox: function () {
            return this._indexBox;
        },

        _setIndexBox: function (elem) {
            this._indexBox = elem;
        },

        _getJSSheetRowHeader: function (sheetIdx) {
            return this._sheets[sheetIdx]._sheetRowHeader;
        },

        _setJSSheetRowHeader: function (value, sheetIdx) {
            this._sheets[sheetIdx]._sheetRowHeader = value;
        },

        _getJSSheetRowHeaderContent: function (sheetIdx) {
            return this._sheets[sheetIdx]._sheetRowHeaderContent;
        },

        _setJSSheetRowHeaderContent: function (value, sheetIdx) {
            this._sheets[sheetIdx]._sheetRowHeaderContent = value;
        },

        _getJSSheetContent: function (sheetIdx) {
            return this._sheets[sheetIdx]._sheetContent;
        },

        _setJSSheetContent: function (value, sheetIdx) {
            this._sheets[sheetIdx]._sheetContent = value;
        },

        _getContent: function (sheetIdx) {
            return this._sheets[sheetIdx]._content;
        },

        _setContent: function (value, sheetIdx) {
            this._sheets[sheetIdx]._content = value;
        },

        getPager: function () {
            return this._spreadSheetPager;
        },

        setPager: function (value) {
            this._spreadSheetPager = value;
        },

        getFooter: function () {
            return this._footer;
        },

        setFooter: function (value) {
            this._footer = value;
        },

        getMainPanel: function () {
            return this._mainPanel;
        },

        setMainPanel: function (value) {
            this._mainPanel = value;
        },

        getGroupPanel: function () {
            return this._groupPanel;
        },

        setGroupPanel: function (value) {
            this._groupPanel = value;
        },

        getActivationPanel: function () {
            return this._activationPanel;
        },

        setActivationPanel: function (value) {
            this._activationPanel = value;
        },

        getActiveSheetIndex: function () {
            return this.model.activeSheetIndex;
        },

        setActiveSheetIndex: function (value) {
            this.model.activeSheetIndex = value;
        },

        getRows: function (sheetIdx) {
            return this._sheets[sheetIdx]._Rows;
        },

        setRows: function (value, sheetIdx) {
            this._sheets[sheetIdx]._Rows = value;
        },

        getFrozenRows: function (sheetIdx) {
            return this.getSheet(this._getSheetIndex(sheetIdx)).frozenRows;
        },

        setFrozenRows: function (value, sheetIdx) {
            if (!this.model.isReadOnly)
       				this.getSheet(this._getSheetIndex(sheetIdx)).frozenRows = value;
        },

        getFrozenColumns: function (sheetIdx) {
            return this.getSheet(sheetIdx).frozenColumns;
        },

        setFrozenColumns: function (value, sheetIdx) {
            if (!this.model.isReadOnly)
                this.getSheet(sheetIdx).frozenColumns = value;
        },

        setFocusTopElem: function (elem) {
            this._focusTopElem = elem;
        },

        getFocusTopElem: function () {
            return this._focusTopElem;
        },

        setFocusRightElem: function (elem) {
            this._focusRightElem = elem;
        },

        getFocusRightElem: function () {
            return this._focusRightElem;
        },

        setFocusBottomElem: function (elem) {
            this._focusBottomElem = elem;
        },

        getFocusBottomElem: function () {
            return this._focusBottomElem;
        },

        setFocusLeftElem: function (elem) {
            this._focusLeftElem = elem;
        },

        getFocusLeftElem: function () {
            return this._focusLeftElem;
        },

        setAutoFillElem: function (elem) {
            this._autoFillElem = elem;
        },

        getAutoFillElem: function () {
            return this._autoFillElem;
        },

        _setAutoFillOptElem: function (elem) {
            this._autoFillOptElem = elem;
        },

        _getAutoFillOptElem: function () {
            return this._autoFillOptElem;
        },

        _getColWidth: function (colIdx, sheetIdx) {
            return this.getSheet(sheetIdx).columnsWidthCollection[colIdx];
        },

        _getRowHeight: function (rowIdx, sheetIdx) {
            return this.getSheet(sheetIdx).rowsHeightCollection[rowIdx];
        },

        setActiveCell: function (rowIdx, colIdx, sheetIdx) {
            var sheet = this.getSheet(sheetIdx ? sheetIdx : this.getActiveSheetIndex()), range;
            if (typeof (rowIdx) === "string") {
                range = this.getRangeIndices(rowIdx);
                rowIdx = range[0];
                colIdx = range[1];
            }
            sheet._activeCell = ej.isNullOrUndefined(rowIdx) && ej.isNullOrUndefined(colIdx) ? sheet._startCell : { rowIndex: rowIdx, colIndex: colIdx };
        },

        getActiveCell: function (sheetIdx) {
            return this.getSheet(this._getSheetIndex(sheetIdx))._activeCell;
        },

        _setFormulaSuggElem: function (elem) {
            this._formulaSuggElem = elem;
        },

        _getFormulaSuggElem: function () {
            return this._formulaSuggElem;
        },

        _setRowHdrTBody: function (elem, sheetIdx) {
            this._sheets[sheetIdx]._rowHdrTBody = elem;
        },

        _getRowHdrTBody: function (sheetIdx) {
            return this._sheets[sheetIdx]._rowHdrTBody;
        },

        _setContTBody: function (elem, sheetIdx) {
            this._sheets[sheetIdx]._contTBody = elem;
        },

        _getContTBody: function (sheetIdx) {
            return this._sheets[sheetIdx]._contTBody;
        },

        _init: function () {
            var isettings = this.model.importSettings;
            this._initBegin();
            if (this.model.allowImport && (isettings.importUrl.length || isettings.importOnLoad))
                this["import"]({ url: isettings.importUrl, password: isettings.password, allowSheetOnDemand: isettings.allowSheetOnDemand });
            else {
                this.showWaitingPopUp();
                this._initBase();
                this._initComplete();
            }
			if (this._isAutoWHMode) {
				var dimension = this._getElementDimension();
                this.element.css({ height: dimension.height, width: dimension.width });
			}
			this.addClass(this.element, this.model.cssClass);
			this._cssClass = this.model.cssClass;
        },

        _initBegin: function () {
            var tchProp = "touch-action", tchVal = "double-tap-zoom pinch-zoom", ssettings = this.model.scrollSettings, width = ssettings.width, height = ssettings.height, culPatrns = ej.preferredCulture(this.model.locale).calendar.patterns;
            ej.support.stableSort = false;
            this._isInitLoad = true;
            this._isDefaultLocked = false;
			this._computeFormula = true;
            this._isAutoWHMode = !ssettings.allowScrolling;
            if (this._isAutoWHMode) {
                ssettings.isResponsive = false;
                ssettings.scrollMode = "normal";
                ssettings.allowVirtualScrolling = false;
            }
            this._minWidth = 280;
            this._minHeight = 200;
            if (!this._isAutoWHMode)
                this.element.css({ 'min-height': this._minHeight, 'min-width': this._minWidth, height: ssettings.height, width: ssettings.width });
            this._updateResponsiveSettings();
            if (!this._isAutoWHMode && !ssettings.isResponsive) {
                if (ssettings.width.toString().indexOf("%") > -1)
                    ssettings.width = this._responsiveWidth;
                if (ssettings.height.toString().indexOf("%") > -1)
                    ssettings.height = this._responsiveHeight;
                this.element.css({ height: ssettings.height, width: ssettings.width });
            }
            this._browserDetails = ej.browserInfo();
            this.localizedLabels = ej.getLocalizedConstants(this.sfType, this.model.locale);
            this.element.attr("tabindex", 0);
            if (this._browserDetails.name === "msie")
                tchProp = "-ms-" + tchProp;
            this.element.css(tchProp, tchVal);
            var waitPopup = ej.buildTag("div#" + this._id + "_wait", "", { position: "absolute" });
            $(document.body).append(waitPopup);
            waitPopup.ejWaitingPopup({ showOnInit: false, target: this.element });
            culPatrns["dT"] = culPatrns["d"] + " " + culPatrns["T"];
			if(this.model.locale != "en-US"){
				if(culPatrns['d'])
					ej.Spreadsheet.CellFormat.shortdate = "{0:" + culPatrns['d'] + "}";
				if(culPatrns['D'])
					ej.Spreadsheet.CellFormat.longdate = "{0:" + culPatrns['D'] + "}";
				if(culPatrns['T'])
					ej.Spreadsheet.CellFormat.time = "{0:" + culPatrns['T'] + "}";
			}	
        },

        _initBase: function () {
            this._refreshModel(this.isImport ? this._impData.model : this._isRefresh ? this.model : null);
            if(this._isRefresh)
                this._updateCellType();
			else
				this._initProps();
            if (!this._tabMode && !this._phoneMode) {
                this._minHeight = 400;
                this.element.css({ "min-height": this._minHeight });
            }
            this._initCSSTag();
            this._initLayout();
            this._wireEvents("_on");
            this._isInitLoad = false;
        },

        _initProps: function () {
            var model = this.model, features = ej.spreadsheetFeatures;
            this.XLClipboard = new features.clipboard(this);
            this.XLEdit = new features.editing(this);
            this.XLPrint = new features.print(this);
            this.XLRibbon = new features.ribbon(this);
            this.XLScroll = new features.scroller(this);
            if (model.allowDragAndDrop)
                this.XLDragDrop = new features.dragAndDrop(this);
            if (model.allowKeyboardNavigation)
                this.XLCellNav = new features.cellNavigation(this);
            if (model.allowFiltering)
                this.XLFilter = new features.filter(this);
            if (model.allowAutoFill)
                this.XLDragFill = new features.dragFill(this);
            if (model.allowCellFormatting || model.allowFormatAsTable || model.allowFormatPainter)
                this.XLFormat = new features.cellFormatting(this);
            if (model.allowCellFormatting)
                this.XLCellFrmtDlg = new features.formatCellDialog(this);
            if (model.allowConditionalFormats)
                this.XLCFormat = new features.cFormat(this);
            if (model.allowSearching)
                this.XLSearch = new features.findnreplace(this);
            if (model.allowCharts)
                this.XLChart = new features.chart(this);
            if(model.allowSparkline)
                this.XLSparkline = new features.sparkLine(this);
            if (model.exportSettings.allowExporting)
                this.XLExport = new features.exporting(this);
            if (model.allowSorting)
                this.XLSort = new features.sorting(this);
            if (model.allowFreezing)
                this.XLFreeze = new features.freezepane(this);
            if (model.allowComments)
                this.XLComment = new features.comments(this);
            if (model.allowSelection)
                this.XLSelection = new features.selection(this);
            if (model.allowCharts || model.pictureSettings.allowPictures)
                this.XLShape = new features.shape(this);
            if (model.allowResizing)
                this.XLResize = new features.resizing(this);
            if (model.enableContextMenu)
                this.XLCMenu = new features.contextmenu(this);
            if (model.allowDataValidation)
                this.XLValidate = new features.validation(this);
            if (model.allowCellType)
                this.XLCellType = new features.cellType(this);
            if (model.enablePivotTable)
                this.XLPivot = new features.pivot(this);
            if (features.math)
                $.extend(ej.Spreadsheet.prototype, features.math);
            this._initPvtProps();
            this._initFATProps();
            if (this.model.customFormulas.length) // Update custom formulas
                this._updateCustomFormulas(this.model.customFormulas, "add");
            if (this.model.nameManager.length)
                this._refreshNameMngr(this.model.nameManager);
        },

        _initPvtProps: function () {
            var i = 1, obj = { rowIndex: 0, colIndex: 0 }, text = this._getLocStr("AutoFillOptions").split("/"),
                sheetIdx = this.getActiveSheetIndex(), numFormat = ej.preferredCulture(this.model.locale).numberFormat;
            this._dataContainer = this.isImport ? $.extend(true, {}, this._impData.dataContainer) : { sheets: {}, sheetCellType: {}, hashCode: [], sharedData: [], cellType: [], valData: [], cFormatData: [], customCellStyle: {} };
            this._newSIndex = 1;
            this.isImport = this.isImport || false;
            this.mergeCenter = false;
            this.isDirty = false;
            this._calcID = CalcEngine.createSheetFamilyID();
            this._calcEngine = new CalcEngine(this, this._calcID);
            this._calcEngine.setUseDependencies(true);
            this._calcEngine.setExcelLikeComputations(true);
            this._calcEngine.setUseDatesInCalculations(true);
            this._calcEngine.setEnableFormulaErrorValidation(true);
            this._calcEngine.setCalculatingSuspended($("#" + this._id + "_CalcManual").find("span").hasClass("e-ss-calcauto"));
            this._sheets = [];
            this._cellProp = ["value", "value2", "type", "cFormatRule", "range", "thousandSeparator", "rule", "format", "border", "picture", "chart", "calcValue", "align", "hyperlink", "formats", "borders", "tformats", "tborders", "isFilterHeader", "filterState", "tableName", "comment", "formatStr", "decimalPlaces", "cellType", "isFilterHighlight", "pivot", "sparkline"];
            if (!this.isImport) {
                this.model.sheets.splice(0, 0, {});
                this._updateCellType();
            }
            while (i <= this.model.sheetCount) {
                if (!this.isImport)
                    this._dataContainer.sheets[i] = {};
                this._sheetSettings(i);
                this._newSIndex++;
                i++;
            }
            this._detachTable = null;
            this._isPrint = false;
            this._isSheetInsert = false;
            this._isSheetRename = false;
            this._isTableRename = false;
            this._tableClassName = null;
            this._isSheetNavigate = false;
            this._sheetCopy = { isSheetCopy: false, sheetContent: null };
            this._alertDialog = { element: null, action: null };
            this._dataManager = null;
            this._isUndo = false;
            this._undoCollection = [],
            this._redoCollection = [],
            this._ctrlKeyCount = 0;
            this._formulaRange = [];
            this._formulaHeight = 36;
            this._isSort = false;
            this._isPaste = false;
            this._isFATResize = false;
            this._isDisplayHeader = false;
            this._currencySymbol = numFormat.currency.symbol || "$";
            this._percentSymbol = numFormat.percent.symbol || "%";
            this._decimalSeparator = numFormat["."] || ".";
            this.operators = {
                '<': function (a, b) { return a < b },
                '>': function (a, b) { return a > b },
                '>=': function (a, b) { return a >= b },
                '<=': function (a, b) { return a <= b },
                '==': function (a, b) { return a === b },
                '!=': function (a, b) { return a !== b },
                '!': function (a) { return !a },
                '=': function (a) { return a }
            };
            this.parse = {
                "parseInt": function (a) { return parseInt(a); },
                "parseFloat": function (a) { return parseFloat(a); },
                "parseDate": function (a) { return new Date(a).getTime(); },
                "parseTime": function (a) { return new Date("01/01/1990 " + a).getTime(); },
                "length": function (a) { return (a.charAt(0) === "^") ? parseInt(a.split("^")[1]) : a.length; }
            };
            this._selMergeCells = [];
            this._mergeType = "merge-cells";
            this._delCells = [];
            this._deletedText = [];
            this._removeMergeColl = [];
            this._insData = {};
            this._deletedDimension = [];
            this._insDelStatus = "";
            this._isUndoRedo = false;
            this._indexBox = null;
            this._inputBox = null;
            this._focusTopElem = null;
            this._focusRightElem = null;
            this._focusBottomElem = null;
            this._focusLeftElem = null;
            this._dStartCell = obj;
            this._dEndCell = obj;
            this._pStartCell = obj;
            this._pEndCell = obj;
            this._pFillCell = obj;
            this._borderFocus = ["e-focusright", "e-focusbottom"];
            this._cutFocus = ["e-cutright", "e-cutbottom"];
            this._autoFillFocus = ["e-autofillright", "e-autofillbottom"];
            this._formulaBorder = [["e-bborderright", "e-bborderbottom"], ["e-rborderright", "e-rborderbottom"], ["e-vborderright", "e-vborderbottom"], ["e-gborderright", "e-gborderbottom"], ["e-pborderright", "e-pborderbottom"], ["e-oborderright", "e-oborderbottom"]];
            this._ctrlFormulaBorder = [["e-bctrlborderright", "e-bctrlborderbottom"], ["e-rctrlborderright", "e-rctrlborderbottom"], ["e-vctrlborderright", "e-vctrlborderbottom"], ["e-gctrlborderright", "e-gctrlborderbottom"], ["e-pctrlborderright", "e-pctrlborderbottom"], ["e-octrlborderright", "e-octrlborderbottom"]];
            this._borderTypes = [
               { id: "bottomborder", text: this._getLocStr("BottomBorder"), parentId: null, sprite: "e-icon e-ss-bottomborder" },
               { id: "topborder", text: this._getLocStr("TopBorder"), parentId: null, sprite: "e-icon e-ss-topborder" },
               { id: "leftborder", text: this._getLocStr("LeftBorder"), parentId: null, sprite: "e-icon e-ss-leftborder" },
               { id: "rightborder", text: this._getLocStr("RightBorder"), parentId: null, sprite: "e-icon e-ss-rightborder" },
               { id: "noborder", text: this._getLocStr("NoBorder"), parentId: null, sprite: "e-icon e-ss-noborder" },
               { id: "allborder", text: this._getLocStr("AllBorder"), parentId: null, sprite: "e-icon e-ss-allborder" }
            ];
            this._datePattern = ["year", "month", "day", "hours", "minutes", "seconds"];
            this._styleColl = {};
            this._borderStyle = "solid";
            this._borderColor = "#000000";
            this._borderStyles = ["solid", "dashed", "dotted","double"];
            this._ddlCell = null;
            this._cOpt = {};
            this._shapeChange = false;
            this._dupDetails = false;
            this._paste = false;
            this._autoFillElem = null;
            this._autoFillOptElem = null;
            this._fillOptionMenuData = [
              { id: "copycells", text: text[0], parentId: null, sprite: "e-icon e-ss-fillselect" },
              { id: "fillseries", text: text[1], parentId: null, sprite: "e-icon e-ss-filloption" },
              { id: "fillformattingonly", text: text[2], parentId: null, sprite: "e-icon e-ss-filloption" },
              { id: "fillwithoutformatting", text: text[3], parentId: null, sprite: "e-icon e-ss-filloption" },
              { id: "flashfill", text: text[4], parentId: null, sprite: "e-icon e-ss-filloption" }
            ];
            this._formulaSuggElem = null;
            this._isFormulaSuggestion = false;
            this._shiftKeyEnabled = false;
            this._preventctrlkey = false;
            this._rAlign = "e-ralign";
            this._cAlign = "e-calign";
            this._chartBorder = [["e-rcborderright", "e-rcborderbottom"], ["e-vcborderright", "e-vcborderbottom"], ["e-bcborderright", "e-bcborderbottom"]];
            this._selectionBorder = ["e-selecttop", "e-selectright", "e-selectbottom", "e-selectleft"];
            this._autofillBorder = ["e-autofilltop", "e-autofillright", "e-autofillbottom", "e-autofillleft"];
            this._thinBorder = ["e-thinborderright", "e-thinborderbottom"];
            this._rcRegx = new RegExp('\\b' + "e-rc" + '.*\\b', 'g');
            this._formatRegx = new RegExp('\\b' + "e-format" + '.*?\\b', 'g');
            this._borderRegx = new RegExp('\\b' + "e-border" + '.*?\\b', 'g');
            this._formulaChanged = [];
            this._ref = [];
            this._prevText = "";
            this._prevVal = "";
            this._dlgHLClick = false;
            this._selectDataval = {};
            this._undoInputobj = {};
            this._cureditedCell = '';
            this._colHeaderHeight = 22;
            this._rowHeaderWidth = 30;
            this._scrollerHeight = 18;
            this._scrollerWidth = 18;
            this._bufferCnt = 5;
            this._maxRowCnt = 1048576;
            this._maxColCnt = 16384;
            this._impData = this._impData || null;
            this._isNew = false;
            this._isSheetReq = false;
            this._intrnlReq = false;
            this._isFilterApplied = false;
            this._commentCount = 0;
            this._tableCnt = 1;
            this._uploadImage = false;
            this._responsiveWidth = 0;
            this._responsiveHeight = 0;
            this._celltypes = [];
            this._reqCnt = 0;
            this._resCnt = 0;
            this._pageClickArgs = null;
            this._gotoPageArgs = null;
            this._updateFormulaCollection();
            this._isRibbonClick = false;
            this._intrnlUpdate = false;
            this._isPvtNameEdit = false;
            this._hlColor = "#428bca";
            this._isFilter = false;
            this._isShowHide = false;
            this._insRows = {};
            this._isTotalRow = false;
            this._scrollReverse = false;
            this._phoneMode = this.model.scrollSettings.isResponsive && document.documentElement.clientWidth < 420;
            this._tabMode = this.model.scrollSettings.isResponsive && (document.documentElement.clientWidth > 419 && document.documentElement.clientWidth < 617);
            this._dlgHeight = this._responsiveHeight - 2;
            this._dlgWidth = this._responsiveWidth - 2;
            this._isTouchEvt = false;
            this._isTouchMoveSel = false;
            this._isTouchScroll = false;
			this._isScrolling = false;
            this._startXY = null;
            this._touchArgs = null;
            this._isResized = false;
            this._isRibbonDestroyed = false;
            this._resizeColl = [];
            this._delWrapColl = {};
            this._isInsdel = false;
            this._canOverflow = true;
            this.preventFilterPopup = false;
            this._FATStyles = {};
            this._isFiltered = false;
            this._dautoFillCell = { rowIndex: 0, colIndex: 0 };
            this._isPublic = false;
            this._fRow = { rowAdj: true, fRowCnt: 0 };
            this._fCol = { colAdj: true, fColCnt: 0 };
            this.isPasteValuesOnly = false;
            this._isSaveAsJSON = false;
            this._cssClass = "";
            this._hideRowColl = [];
            this._isSort = false;
            this._isKeyCtrlShftF2 = false;
            this._isSelIdxChange = false;
            this._isRefresh = false;
            this._clkCellObj = { rowIndex: 0, colIndex: 0 };
			this._copySheet = false;
			this._isCopyPaste = false;
        },

        _initFATProps: function () {
            var i, len, b = 'w:bold', c1 = 'c:#FFFFFF', c2 = 'c:#000000', c3 = 'c:#2F75B5', c4 = 'c:#ED7D31', c5 = 'c:#FFC000', b1 = '1px solid #000000', b2 = '1px solid #2f75b5', b3 = '1px solid #ED7D31', b4 = '1px solid #FFC000',
            d1 = 'b:#D9D9D9', d2 = 'b:#DDEBF7', d3 = 'b:#FCE4D6', d4 = 'b:#FFF2CC', d5 = 'b:#000000', d6 = 'b:#DBECF6', d7 = 'b:#FFE2C6', d8 = 'b:#FFF1BF', d9 = 'b:#000000', d10 = 'b:#D7D7D7', d11 = 'b:#FFC000', d12 = 'b:#5B9BD5', d13 = 'b:#Ed7D31',
            style = 'hl?' + b + ';' + c2 + ';bo:tb-' + b1 + '&cl?' + d1 + ';' + c2 + ',' + c2 + '&cb?b-' + b1 + '/hl?' + b + ';bo:tb-' + b2 + ';' + c3 + '&cl?' + d2 + ';' + c3 + ',' + c3 + '&cb?b-' + b2 + '/hl?' + b + ';bo:tb-' + b3 + ';' + c4 + '&cl?' + d3 + ';' + c4 + ',' + c4 + '&cb?b-' + b3 + '/hl?' + b + ';bo:tb-' + b4 + ';' + c5 + '&cl?' + d4 + ';' + c5 + ',' + c5 + '&cb?b-' + b4 + '/hl?' + b + ';' + d5 + ';' + c1 + ';bo:o-' + b1 + '&cl?bo:t-' + b1 + ';' + c2 + '&cb?o-' + b1 + '/hl?bo:o-' + b2 + ';' + b + ';' + d12 + ';' + c1 + '&cl?bo:t-' + b2 + ';' + c2 + '&cb?o-' + b2 + '/hl?' + b + ';b:#EB7E2F;' + c1 + ';bo:o-' + b3 + '&cl?bo:t-' + b3 + ';' + c2 + '&cb?o-' + b3 + '/hl?' + b + ';' + d11 + ';' + c1 + ';bo:o-' + b4 + '&cl?bo:t-' + b4 + ';' + c2 + '&cb?o-' + b4 + '/hl?' + b + ';bo:gb-' + b1 + ';' + c2 + '&cl?' + d1 + ';' + c2 + ',' + c2 + '&cb?gb-' + b1 + '/hl?' + b + ';bo:gb-' + b2 + ';' + c2 + '&cl?' + d2 + ';' + c2 + ',' + c2 + '&cb?gb-' + b2 + '/hl?' + b + ';bo:gb-' + b3 + ';' + c2 + '&cl?' + d3 + ';' + c2 + ',' + c2 + '&cb?gb-' + b3 + '/hl?' + b + ';bo:gb-' + b4 + ';' + c2 + '&cl?' + d4 + ';' + c2 + ',' + c2 + '&cb?gb-' + b4 + '/hl?' + b + ';' + d5 + ';' + c1 + '&cl?b:#A6A6A6;' + c2 + ',' + d1 + ';' + c2 + '/hl?' + b + ';' + d12 + ';' + c1 + '&cl?b:#BDD7EE;' + c2 + ',' + d2 + ';' + c2 + '/hl?' + b + ';' + d13 + ';' + c1 + '&cl?b:#F8CBAD;' + c2 + ',' + d3 + ';' + c2 + '/hl?' + b + ';' + d11 + ';' + c1 + '&cl?b:#FFE699;' + c2 + ',' + d4 + ';' + c2 + '/hl?' + b + ';' + d10 + ';' + c2 + ';bo:gb-' + b1 + '&cl?b:#A7A7A7;' + c2 + ',' + d10 + ';' + c2 + '&cb?gb-' + b1 + '/hl?' + b + ';' + d6 + ';' + c2 + ';bo:gb-' + b2 + '&cl?b:#BED8F1;' + c2 + ',' + d2 + ';' + c2 + '&cb?gb-' + b2 + '/hl?' + b + ';' + d7 + ';' + c2 + ';bo:gb-' + b3 + '&cl?b:#F6CAAD;' + c2 + ',' + d7 + ';' + c2 + '&cb?gb-' + b3 + '/hl?' + b + ';' + d8 + ';' + c2 + ';bo:gb-' + b4 + '&cl?b:#FDE18D;' + c2 + ',' + d8 + ';' + c2 + '&cb?gb-' + b4 + '/hl?' + b + ';' + d9 + ';' + c1 + '&cl?b:#404040;' + c1 + ',b:#737373;' + c1 + '/hl?' + b + ';' + d9 + ';' + c1 + '&cl?b:#2F75B5;' + c1 + ',' + d12 + ';' + c1 + '/hl?' + b + ';' + d9 + ';' + c1 + '&cl?b:#C65911;' + c1 + ',' + d13 + ';' + c1 + '/hl?' + b + ';' + d9 + ';' + c1 + '&cl?b:#BF8F00;' + c1 + ',' + d11 + ';' + c1,
            name = ["Light1", "Light2", "Light3", "Light5", "Light8", "Light9", "Light10", "Light12", "Light15", "Light16", "Light17", "Light19", "Medium8", "Medium9", "Medium10", "Medium12", "Medium22", "Medium23", "Medium24", "Medium26", "Dark1", "Dark2", "Dark3", "Dark5"];
            style = style.split('/');
            i = 0; len = name.length;
            while (i < len) {
                this._FATStyles["TableStyle" + name[i]] = { format: this.XLRibbon._getFormatAsTableInput(style[i]), formatName: "TableStyle" + name[i] };
                i++;
            }
            this.XLFormat._formatAsTableStyle = this._FATStyles["TableStyle" + name[0]];
        },

        _updateResponsiveSettings: function () {
            var isIE8 = ((ej.browserInfo().name === "msie") && (ej.browserInfo().version === "8.0"));
            var clientRect = this.element[0].getClientRects()[0];
            this._responsiveHeight = Math.floor(isIE8 ? this.element[0].offsetHeight : clientRect ? clientRect.height : 0);
            this._responsiveWidth = Math.floor(isIE8 ? this.element[0].offsetWidth : clientRect ? clientRect.width : 0);
        },

		_getElementDimension: function () {
            var rbnHt = 0, elemWidth, formulaHt = 0, contentHt = 0;
            if (this.model.showRibbon) {
                var rObj = $('#' + this._id + '_Ribbon').data('ejRibbon');
                elemWidth = rObj.element[0].offsetWidth;
                rbnHt = rObj.element[0].offsetHeight;
            }
            if (this.model.allowFormulaBar) {
                var formulaElem = $('#' + this._id + '_formulabar')[0];
                formulaHt = formulaElem.offsetHeight;
                if (!elemWidth)
                    elemWidth = formulaElem.offsetWidth;
            }
            var mPanel = this.element.find(".e-spreadsheetmainpanel")[0];
            contentHt = mPanel.offsetHeight;
            if (!elemWidth)
                elemWidth = mPanel.offsetWidth;
            return { width: elemWidth + 2, height: (rbnHt + formulaHt + contentHt + 1) }
        },

        _sheetSettings: function (sheetIdx) {
            var sIdx, sheet, impSheet, name, sheetName, msheet, psheet;
            if (!this._isSheetReq) {
                msheet = this.getSheet(sheetIdx);
                sheetName = this._generateSheetName(this._newSIndex);
                sheet = this.model.sheets[sheetIdx] = {
                    colCount: msheet && msheet.colCount || this.model.columnCount,
                    rowCount: msheet && msheet.rowCount || this.model.rowCount,
                    _formulaCollection: {},
                    columnsWidthCollection: [],
                    _colWidthCollection: [],
                    _ofColWidthColl: [],
                    rowsHeightCollection: [],
                    _rowHeightCollection: [],
                    _rowIdxColl: [],
                    _spreadSheetPager: null,
                    showHeadings: (msheet && !this.isUndefined(msheet.showHeadings)) ? msheet.showHeadings : true,
                    showGridlines: (msheet && !this.isUndefined(msheet.showGridlines)) ? msheet.showGridlines : true,
                    dataSource: (msheet && msheet.dataSource) || null,
                    _jsonData: msheet ? (msheet.dataSource instanceof ej.DataManager ? null : msheet.dataSource) : null,
                    _dataManager: (msheet && msheet.dataSource instanceof ej.DataManager) ? msheet.dataSource : null,
                    query: (msheet && msheet.query) || null,
                    primaryKey: (msheet && msheet.primaryKey) || "",
                    startCell: (msheet && msheet.startCell) || "A1",
                    topLeftCell: (msheet && msheet.topLeftCell) || "A1",
                    fieldAsColumnHeader: (msheet && msheet.fieldAsColumnHeader) || false,
                    showHeader: (msheet && msheet.showHeader === false) ? false : true,
                    headerStyles: (msheet && msheet.headerStyles) || null,
                    batchChanges: { added: [], changed: [], deleted: [] },
                    range: [0, 0, 0, 0],
                    fields: [],
                    _isDataManager: false,
                    _isOffline: false,
                    _hasDataSrc: false,
                    columns: msheet && msheet.columns || [],
                    _columnStyles: {},
                    _rowStyles: {},
                    cellTypes: msheet && msheet.cellTypes || [],
                    rows: msheet && msheet.rows || null,
                    _excelFilter: null,
                    filterSettings:
                    {
                        filteredColumns: [],
                        maxFilterChoices: 1000,
                        filteredRange: [],
                        range: "",
                        tableRange: []
                    },
                    frozenRows: msheet && msheet.frozenRows || 0,
                    frozenColumns: msheet && msheet.frozenColumns || 0,
                    _frozenRows: msheet && msheet.frozenRows && msheet.frozenRows + 1 || 1,
                    _frozenColumns: msheet && msheet.frozenColumns && msheet.frozenColumns + 1 || 1,
                    _fHMergeRows: [],
                    _fHMergeCols: [],
                    paneTopLeftCell: msheet && msheet.paneTopLeftCell || "A1",
                    _selectedRange: {},
                    _selectedCellColors: [],
                    columnWidth: (msheet && msheet.columnWidth) || this.model.columnWidth,
                    rowHeight: this.model.rowHeight,
                    _frozenHeight: 0,
                    _frozenWidth: 0,
                    _firstRow: { idx: 0, value: 0 },
                    _firstCol: { idx: 0, value: 0 },
                    _topRow: { idx: 0, value: 0 },
                    _bottomRow: { idx: 0, value: 0 },
                    _leftCol: { idx: 0, value: 0 },
                    _rightCol: { idx: 0, value: 0 },
                    _filterColl: {},
                    _filteredColumns: [],
                    _commentColl: {},
                    _mergeColl: {},
                    _unmergeColl: {},
                    _delmergeColl: {},
                    _hideMergeColl: {},
                    _clrMergeColl: [],
                    _clrWrapColl: [],
                    _selectedCells: [],
                    selectedRange: [0, 0, 0, 0],
                    tableManager: {},
                    _header: {},
                    _selectedCellIndexes: [],
                    _startCell: { rowIndex: 0, colIndex: 0 },
                    _endCell: { rowIndex: 0, colIndex: 0 },
                    _activeCell: { rowIndex: 0, colIndex: 0 },
                    _autoFillCell: { rowIndex: 0, colIndex: 0 },
                    rangeSettings: msheet && msheet.rangeSettings || [],
                    sheetInfo: { text: sheetName, value: this._getLocStr("Sheet") + this._newSIndex, isVisible: true },
                    _multipleFiltering: false,
                    _multifilterIdx: [],
                    _filteredByColor: "",
                    staticWidth: 0,
                    _fRow: 0,
                    _fCol: 0,
                    hideColsCollection: {},
                    hideRowsCollection: msheet && msheet.hideRowsCollection || [],
                    _hiddenFreezeRows: [],
                    _hiddenFreezeCols: [],
                    _filterHRowsColl: [],
                    _restrictedHeightRows: [],
                    filteredRowsCollection: [],
                    _rHeightCollection: [],
                    _frHiddenHeight: 0,
                    _fpHiddenHeight: 0,
                    _fpHiddenWidth: 0,
                    _pTarget: {},
                    _cSpan: 1,
                    _rSpan: 1,
                    usedRange: { rowIndex: 0, colIndex: 0 },
                    mergedCells: [],
                    shapeMngr: { picture: {}, chart: {}, sharedPics: [], sparkline:{}, },
                    pivotMngr: { pivot: {} },
                    _nmValue: {},
                    _nmEdit: false,
                    _wrapHtCollection: {},
                    _isChartBorderDrawn: false,
                    _virtualBlockCnt: 0,
                    _virtualBlockRowCnt: 0,
                    _virtualContBlockIdx: 1,
                    _virtualTopTBodyHgt: 0,
                    _virtualBottomTBodyHgt: 0,
                    _virtualTBodyHgt: 0,
                    _scrollTop: 0,
                    _scrollLeft: 0,
                    _virtualRowIdx: [],
                    _virtualTopTBodyOffset: { top: 0, bottom: 0 },
                    _virtualContTBodyOffset: { top: 0, bottom: 0 },
                    _virtualBottomTBodyOffset: { top: 0, bottom: 0 },
                    _virtualDataLoadedBlks: [],
                    _virtualDataMngrLoadedBlks: [1, 2],
                    _isVirtualTopReached: true,
                    _isVirtualEndReached: false,
                    _isLoaded: false,
                    _isImpSLoad: false,
                    _isRowSelected: false,
                    _isColSelected: false,
                    _isSheetSelected: false,
                    isSheetProtected: false,
                    _contWidth: 0,
                    _isRangeSelected: false,
                    _isEmptyActiveCell: false,
                    _isMultiSelect: false,
                    _isImported: this.isImport,
                    _isRequested: false,
                    _goToCollection: { multiple: false, selected: [] },
                    _showLockCellAlert: false,
                    _reqCnt: 0,
                    _resCnt: 0,
                    _templateColCount: 0,
                    _isTemplate: false,
                    _cFormatFormula: {},
                    _isVPRendered: false,
                    _isDataMoved: false,
                    _vPortHgt: 0,
                    _vPortWth: 0,
                    cFormatRule: msheet && msheet.cFormatRule || [],
                    mergeCells: msheet && msheet.mergeCells || [],
                    hideRows: msheet && msheet.hideRows || [],
                    hideColumns: msheet && msheet.hideColumns || [],
                    border: msheet && msheet.border || [],
                    isResized: false,
                    _isOpened:false,
                    _wrapColl: {},
					_formatColl: {},
                    _isFreezed: false,
                    _ftopRowIdx: 0,
                    _fleftColIdx: 0,
                    _contScrollTop: 0,
                    _contScrollLeft: 0,
                    _fDivTop: 0,
                    _fDivLeft: 0,
                    _isRibCollapsed: false,
					_wrapValColl: {}
                };
                this._initRangeSettings(sheetIdx);
                name = sheet.sheetInfo.value;
                psheet = this._sheets[sheetIdx] = { _contentColGroup: null, _content: null, _sheetRowHeaderContent: null, _sheetHeader: null, _sheetRowHeader: null, _sheetContent: null, _Rows: null, _contTBody: null, _rowHdrTBody: null };
                this._calcEngine.registerGridAsSheet(name, name, this._calcID);
            }
            else
                sheet = this.getSheet(sheetIdx);
            if (this.isImport) {
                impSheet = this._impData.model.sheets[sheetIdx];
                sIdx = this.getRangeIndices(impSheet.topLeftCell || "A1");
                sheet.sheetInfo.text = impSheet.sheetInfo.text;
                if (this.isUndefined(impSheet.sheetInfo.isVisible))
                    sheet.sheetInfo.isVisible = true;
                else
                    sheet.sheetInfo.isVisible = impSheet.sheetInfo.isVisible;
                if (!this.model.importSettings.allowSheetOnDemand || sheetIdx === this.getActiveSheetIndex())
                    sheet._isRequested = true;
                if (sheet._isRequested) {
                    if (impSheet.usedRange) {
                        if (impSheet.usedRange.rowIndex)
                            sheet.usedRange.rowIndex = impSheet.usedRange.rowIndex;
                        if (impSheet.usedRange.colIndex)
                            sheet.usedRange.colIndex = impSheet.usedRange.colIndex;
                    }
                    if (impSheet._startCell) {
                        if (impSheet._startCell.rowIndex)
                            sheet._startCell.rowIndex = impSheet._startCell.rowIndex;
                        if (impSheet._startCell.colIndex)
                            sheet._startCell.colIndex = impSheet._startCell.colIndex;
                    }
                    if (impSheet._endCell) {
                        if (impSheet._endCell.rowIndex)
                            sheet._endCell.rowIndex = impSheet._endCell.rowIndex;
                        if (impSheet._endCell.colIndex)
                            sheet._endCell.colIndex = impSheet._endCell.colIndex;
                    }
                    if (impSheet._activeCell) {
                        if (impSheet._activeCell.rowIndex)
                            sheet._activeCell.rowIndex = impSheet._activeCell.rowIndex;
                        if (impSheet._activeCell.colIndex)
                            sheet._activeCell.colIndex = impSheet._activeCell.colIndex;
                    }
                    if (impSheet.columnsWidthCollection)
                        sheet.columnsWidthCollection = impSheet.columnsWidthCollection;
                    if (impSheet.rowsHeightCollection) {
                        var i, len, rowIdxCln = impSheet.hideRowsCollection || [];
                        for (i = 0, len = rowIdxCln.length; i < len; i++)
                            impSheet.rowsHeightCollection[parseInt(rowIdxCln[i])] = 0;
                        sheet.rowsHeightCollection = $.extend(true, [], impSheet.rowsHeightCollection);
                    }
                    if (!ej.isNullOrUndefined(impSheet.showGridlines))
                        sheet.showGridlines = impSheet.showGridlines;
                    if (impSheet.hideRowsCollection)
                        sheet.hideRowsCollection = impSheet.hideRowsCollection || [];
                    if (impSheet.shapeMngr.picture.length)
                        sheet.shapeMngr.sharedPics = impSheet.shapeMngr.sharedPics;
                    if (impSheet.isSheetProtected)
                        sheet.isSheetProtected = impSheet.isSheetProtected;
                    if (impSheet._restrictedHeightRows)
                        sheet._restrictedHeightRows = impSheet._restrictedHeightRows || [];
                    if (impSheet._isColSelected)
                        sheet._isColSelected = impSheet._isColSelected;
                    if (impSheet._isRowSelected)
                        sheet._isRowSelected = impSheet._isRowSelected;
                    if (impSheet.showHeadings === false)
                        sheet.showHeadings = false;
                    if (impSheet.frozenRows) {
                        sheet.frozenRows = sheet._frozenRows = sIdx[0] + impSheet.frozenRows;
                        sheet._frozenRows = sheet.frozenRows + 1;
                    }
                    if (impSheet.frozenColumns) {
                        sheet.frozenColumns = sheet._frozenColumns = sIdx[1] + impSheet.frozenColumns;
                        sheet._frozenColumns = sheet.frozenColumns + 1;
                    }
                }
            }
        },

        _generateSheetName: function (index) {
            var i, len, sName, sheet, shtNo = 1, sheetModel = this.model.sheets, txt = this._getLocStr("Sheet"),
                sheet = sheetModel[index];
            sName = sheet && sheet.sheetName || (txt + index);
            for (i = 1, len = sheetModel.length; i < len; i++) {
                if (sheetModel[i].sheetInfo && sName === sheetModel[i].sheetInfo.text) {
                    i = 0;
                    sName = sheet && sheet.sheetName ? (sheet.sheetName + shtNo++) : (txt + ++index);
                }
            }
            return sName;
        },

        _initRangeSettings: function (sheetIdx) {
            var setting, sheet = this.getSheet(sheetIdx), i = sheet.rangeSettings.length;
            if (i) {
                while (i--) {
                    setting = sheet.rangeSettings[i];
                    if (setting.dataSource) {
                        setting._jsonData = setting._dataManager = null;
                        if (setting.dataSource instanceof ej.DataManager)
                            setting._dataManager = setting.dataSource;
                        else
                            setting._jsonData = setting.dataSource;
                        if (setting.showHeader != false)
                            setting.showHeader = true;
                    }
                }
            }
        },

        _initCSSTag: function () {
            if (!document.getElementById(this._id + "_sscustomformat")) {
                if (this.isImport)
                    this._dataContainer.hashCode = [];
                var prop, len, i = 0, stag;
                stag = this._renderStyleTag("custom");
                if (this.isImport)
                    this._refreshImpStyles(this._impData.dataContainer.hashCode);
                if (this.XLFormat) {
                    prop = "s:11pt/b:#FFC7CE;c:#82012A;f:calibri;s:11pt/b:#C6EED2;c:#0A7043;f:calibri;s:11pt/b:#FEEC9B;c:#826717;f:calibri;s:11pt/f:Calibri;w:bold;v:top;s:11pt/f:calibri;s:18pt/b:#DDE5F6;f:calibri;s:11pt/b:#FDE0D2;f:calibri;s:11pt/b:#EEEEEC;f:calibri;s:11pt/b:#FEF4CD;f:calibri;s:11pt/b:#9CC0E7;f:calibri;s:11pt/b:#F9AD7B;f:calibri;s:11pt/b:#C9C9C9;f:calibri;s:11pt/b:#FED965;f:calibri;s:11pt/b:#559AD9;c:#FFFFFF;f:calibri;s:11pt/b:#EB7E2F;c:#FFFFFF;f:calibri;s:11pt/b:#A5A5A5;c:#FFFFFF;f:calibri;s:11pt/b:#FDBF01;c:#FFFFFF;f:calibri;s:11pt".split("/");
                    len = prop.length;
                    while (i < len) {
                        this.XLFormat._createFormatClass(this._getStyleAsJSON(prop[i]), null, true);
                        i++;
                    }
                }
                prop = ".e-spreadsheet .e-hide, .e-spreadsheet .e-mc-hide, .e-spreadsheet .e-fr-hide, .e-spreadsheet .e-fc-hide, .e-spreadsheet .e-c-hide, .e-spreadsheet .e-r-hide, .e-spreadsheet .e-col-hide{ display: none}";
                prop += ".e-spreadsheet .e-rowcell.e-redft { background-color: #FFC7CE; color: #9C0055;} .e-spreadsheet .e-rowcell.e-yellowft { background-color: #FFEB9C; color: #9C6500;}";
                prop += ".e-spreadsheet .e-rowcell.e-greenft { background-color: #C6EFCE;   color: #006100;} .e-spreadsheet .e-rowcell.e-redf { background-color: #FFC7CE;} .e-spreadsheet .e-rowcell.e-redt { color: #9C0055;}";
                prop += ".e-spreadsheet .e-rowcell.e-hlcell { background-color: #FFFF00; color: #FF0000;} .e-spreadsheet .e-rowcell.e-goto-blank { background-color: #C6C6C6;}";
                stag.styleSheet ? stag.styleSheet.cssText += prop : stag.appendChild(document.createTextNode(prop));
            }
            this._renderStyleTag("showhide");
        },

        _initEditForm: function () {
            var $acElem, $form, $valElem;
            $acElem = ej.buildTag("input", "", { display: "none" }, { id: this._id + "_AutoComplete" });
            $acElem.addClass("e-hide");
            this.element.append($acElem);
            this.XLEdit._renderAutoComplete($acElem, "", null, true);
            $acElem.data("ejAutocomplete")._setListPosition = function () { }; //JS-35957
            $form = ej.buildTag("form", "", { width: 1, height: 1, display: "none" }, { id: this._id + "EditForm" }), $valElem = ej.buildTag("input", "", { width: 1, height: 1, overflow: "hidden", opacity: 0 }, { id: this._id + "_ValElem" });
            $form.append($valElem);
            $valElem.data("id", this._id);
            this.element.append($form);
        },

        _getStyleAsJSON: function (str) {
            var istr, len, lwn, i = 0, obj = {}, prop = { b: 'background-color', c: 'color', f: 'font-family', s: 'font-size', w: 'font-weight', v: 'vetical-align', bo: 'border' };
            str = str.split(';'), len = str.length;
            while (i < len) {
                istr = str[i].split(':');
                obj[prop[istr[0]]] = istr[0] === 'bo' ? this.XLRibbon._getBorderObj(istr[1].split('-')[0], istr[1].split('-')[1]) : istr[1];
                i++;
            }
            return obj;
        },

        _initLayout: function () {
            if (this.model.showRibbon) {
                this.XLRibbon._renderRibbon();
                if (this._tabMode)
                    $("#" + this._id + "_Ribbon").ejRibbon("collapse");
            }
            if (this.model.allowFormulaBar)
                this._renderFormulaBar();
            this._renderFUpload();
            this._renderLayout();
        },

        _renderLayout: function () {
            var i, cnt;
            this._renderPanel();
            this._initTags();
            this._initDependencies();
            this._renderFooter();
            this._refreshSheetLayout();
            if (this.model.scrollSettings.allowVirtualScrolling || this.model.scrollSettings.allowSheetOnDemand)
                i = cnt = this.getActiveSheetIndex()
            else {
                i = 1;
                cnt = this.model.sheetCount;
            }
            while (i <= cnt) {
                this._initSheet(i);
                i++;
            }
        },

        _renderPanel: function () {
            var $mainDiv, div, settings = this.model.scrollSettings;
            $mainDiv = ej.buildTag('div.e-spreadsheetgrppanel', "", {}, { id: this._id + "GroupPanel" });
            this.setGroupPanel($mainDiv);
            div = ej.buildTag('div.e-spreadsheetmainpanel', this._renderDIV("e-spreadsheet-list", ""), {}, { id: this._id + "MainPanel" });
            $mainDiv.append(div);
            this.setMainPanel(div);
            div = ej.buildTag('div.e-spreadsheetactpanel', "", { height: settings.height, width: this.model.activationPanelWidth - 1, display: "none" }, { id: this._id + "ActivationPanel" });
            $mainDiv.append(div);
            this.setActivationPanel(div);
            this.element.append($mainDiv);
        },

        _refreshSheetLayout: function () {
            var contentHt, formulaHeight, ribHgt, ribbonHeight, diffHt, ribContHeight = -1, pagerHt = this.model.pageSettings.pagerHeight + 1;
            this._updateResponsiveSettings();
            this.XLRibbon._ribbonState && (ribContHeight = $("#" + this._id + "_Ribbon").find(".e-content:eq(1)").height());
            ribHgt = this._phoneMode ? $("#" + this._id + "_Ribbon").height() : $("#" + this._id + "_Ribbon").find(".e-header").height() + ribContHeight + 2;
            formulaHeight = this.model.allowFormulaBar ? this._formulaHeight : 0;
            ribbonHeight = (ribHgt && this.model.showRibbon && $("#" + this._id + "_Ribbon").is(":visible")) ? ribHgt : 0;
            (!this.model.showPager || !this.element.find(".e-spreadsheetfooter").is(":visible")) && (pagerHt = 1);
            contentHt = this._responsiveHeight - (ribbonHeight + formulaHeight + 2);
            ((this._browserDetails.name != "msie") && !this._isAutoWHMode) && this.element.find(".e-spreadsheet-list").height(contentHt - pagerHt);
        },

        _initTags: function () {
            var span = ej.buildTag('span#' + this._id + '_emptySpan'), div = ej.buildTag('div#' + this._id + '_emptyDiv');
            this.element.find('.e-spreadsheetmainpanel')[0].insertBefore(span[0], this.element.find('.e-spreadsheetmainpanel').find(".e-spreadsheet-list")[0]);
            this.element.find('.e-spreadsheetmainpanel')[0].insertBefore(div[0], this.element.find('.e-spreadsheetmainpanel').find(".e-spreadsheet-list")[0]);
            this._refreshGlobalSpan();
        },

        _refreshGlobalSpan: function (span, width) {
            span = span || document.getElementById(this._id + (width ? '_emptyDiv' : '_emptySpan'));
            span.textContent = '';
            span.className = '';
            if (this._browserDetails.name === "msie" && this._browserDetails.version === "8.0")
                $(span).removeAttr('style').text("");
            else
                span.removeAttribute("style");
        },

        _initSheet: function (sheetIdx) {
            var len, i = 0, sheet = this.getSheet(sheetIdx), settings = this.getDataSettings(sheetIdx);
            this._updateResponsiveSettings();
            this._initViewPort(sheetIdx);
            if (settings && !this._sheetCopy.isSheetCopy) {
                len = settings.length;
                while (i < len) {
                    this._initDataSrc(sheetIdx, sheet, settings[i]);
                    i++;
                }
            }
            if (sheet._reqCnt === sheet._resCnt)
                this._renderSheet(sheetIdx);
        },

        _initViewPort: function (sheetIdx) {
            var pagerHt = -1, actPnlWidth, ribbonHgt,ribHght, scrollerHgt, scrollerWth, colHdrHgt, rowHdrWth, formulaHgt, settings = this.model.scrollSettings, sheet = this.getSheet(sheetIdx);
            actPnlWidth = ribbonHgt = scrollerHgt = scrollerWth = colHdrHgt = rowHdrWth = formulaHgt = 0;
            if (settings.allowScrolling) {
                scrollerHgt = this._scrollerHeight;
                scrollerWth = this._scrollerWidth;
            }
            if (sheet.showHeadings) {
                colHdrHgt = this._colHeaderHeight;
                rowHdrWth = this._rowHeaderWidth;
            }
            if (this.model.showRibbon) {
                ribHght = this.getSheet(this.getActiveSheetIndex())._isRibCollapsed ? 0 : ribHght = $("#" + this._id + "_Ribbon_home").height();
                ribbonHgt = this.element.find(".e-box.e-addborderbottom.e-header").height() + ribHght + 2;
                ribbonHgt = ribbonHgt < 189 ? ribbonHgt : 188; //188 max height of Ribbon
            }
            if (this.model.allowFormulaBar)
                formulaHgt = this._formulaHeight;
            if (this.model.showPager && this.element.find(".e-spreadsheetfooter").is(":visible"))
                pagerHt = this.model.pageSettings.pagerHeight;
            if (this.getActivationPanel().is(":visible"))
                actPnlWidth = this.getActivationPanel().width();
            sheet._vPortHgt = this._responsiveHeight - (ribbonHgt + formulaHgt + colHdrHgt + pagerHt + scrollerHgt);
            sheet._vPortWth = this._responsiveWidth - (actPnlWidth + scrollerWth + rowHdrWth);
            if (settings.allowVirtualScrolling)
                sheet._virtualBlockRowCnt = Math.ceil(sheet._vPortHgt / sheet.rowHeight) + this._bufferCnt;
        },

        _initDataSrc: function (sheetIdx, sheet, setting) {
            var proxy, args = { sheetIndex: sheetIdx, lockWorkbookCells: false, computeFormula: false };
            if (setting._dataManager) {
                this._trigger("load", args);
                this._isDefaultLocked = args.lockWorkbookCells;
				this._computeFormula = args.computeFormula;
                if (setting._dataManager instanceof ej.DataManager) {
                    if (setting._dataManager.ready) {
                        proxy = this;
                        sheet._reqCnt++;
                        this._reqCnt++;
                        setting._dataManager.ready.done(function (args) {
                            proxy._initDataMngr(sheetIdx, sheet, setting);
                        });
                    }
                    else
                        this._initDataMngr(sheetIdx, sheet, setting);
                }
            }
            else if (setting._jsonData)
                setting.count = setting._jsonData.length;
        },

        _initDataMngr: function (sheetIdx, sheet, setting) {
            var len, query, range, queries, promise, queryCnt, cnt = 0, proxy = this;
            setting._isDataManager = true;
            setting._isOffline = setting._dataManager.dataSource.offline;
            if (!setting.query)
                setting.query = new ej.Query();
            setting.query.requiresCount();
            if (this.model.scrollSettings.allowVirtualScrolling) {
                queries = setting.query.queries;
                len = queries.length;
                if (len) {
                    while (len--) {
                        query = queries[len];
                        if (query.fn === "onTake") {
                            cnt = query.e.nos;
                            queries.splice(len, 1);
                        }
                        else if (query.fn === "onSkip")
                            setting._skip = query.e.nos;
                    }
                }
                queryCnt = sheet._virtualBlockRowCnt * 2;
                if (setting.startCell) {
                    range = this.getRangeIndices(setting.startCell);
                    if (range[0])
                        queryCnt -= range[0] - 0;
                }
                if (cnt && cnt < queryCnt)
                    queryCnt = cnt;
                setting.query.take(queryCnt);
            }
            promise = setting._dataManager.executeQuery(setting.query);
            promise.done(function (e) {
                len = e.count || e.result.length;
                if (len) {
                    setting._jsonData = e.result;
                    setting.count = cnt || len;
                }
                proxy._respHandler(sheetIdx);
            });
            promise.fail(function (e) {
                proxy._respHandler(sheetIdx);
            });
            if (!setting._dataManager.isDataAvailable) {
                sheet._reqCnt++;
                this._reqCnt++;
            }
        },

        _respHandler: function (sheetIdx) {
            var sheet = this.getSheet(sheetIdx);
            sheet._resCnt++;
            this._resCnt++;
            if (sheet._reqCnt === sheet._resCnt)
                this._renderSheet(sheetIdx);
            this._initComplete();
        },

        _renderSheet: function (sheetIdx) {
            var div, sIdx, impData, hfreeze, actSheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), name = sheet.sheetInfo.value, settings = {},
                elem = this.element.find('#' + this._id + '_' + name), args = { sheetIndex: sheetIdx, lockWorkbookCells: this._isDefaultLocked, computeFormula: this._computeFormula };
            this._resizeColl[sheetIdx - 1] = false;
            if (this._isInitLoad)
                this._trigger("load", args);
            this._isDefaultLocked = args.lockWorkbookCells;
			this._computeFormula = args.computeFormula;
            this._initTmplColumns(sheetIdx);
            div = elem.length === 1 ? elem : ej.buildTag('div.e-sheet e-hide ', '', {}, { id: this._id + '_' + name });
            div.append(this._renderContent(sheetIdx));
            if (!elem.length) {
                if (this.model.allowFreezing)
                    hfreeze = this.XLFreeze._getHFreeze();
                if (hfreeze)
                    hfreeze.before(div);
                else
                    this.element.find(".e-spreadsheet-list").append(div);
            }
            if (sheet.showGridlines === false)
                $("#" + this._id + "_Ribbon_PageLayout_Show_Gridlines").ejCheckBox({ checked: sheet.showGridlines });
            if (this.model.enableContextMenu) {
                this.XLCMenu._initContextMenu();
                this.XLCMenu._initColorDialog();
                this.XLCMenu._initCMenuFooter();
            }
            this._updateResponsiveSettings();
            this._removeClass(div, "e-hide");
            settings.width = this._responsiveWidth;
            settings.height = this._responsiveHeight;
            (this.model.showRibbon && !this._isAutoWHMode && (this._tabMode || this._responsiveHeight < 280)) && $("#" + this._id + "_Ribbon").ejRibbon("collapse");
            this._setSheetWidthHeight(sheetIdx, settings, null, "refresh", "initial");
            this._refreshCellBinding(sheetIdx);
            this._refreshImpResRowHght(sheetIdx);
            this.refreshContent(sheetIdx);
            if (sheetIdx === actSheetIdx)
                this._updateHiddenRows(actSheetIdx);
            this._initializePicture(sheetIdx);
            if (this.isImport && this.model.allowCellType && this.model.allowAutoCellType && this._celltypes.length)
                this._processCellTypes(this._celltypes, sheetIdx);
            if (this.model.allowCellType && !this.model.scrollSettings.allowVirtualScrolling)
                this.XLCellType._rangeCellTypes(sheet.cellTypes, sheetIdx);
            if (sheet._isImported && !this._sheetCopy.isSheetCopy) {
                this.setActiveSheetIndex(sheetIdx);
                this._refreshImpSheets(sheetIdx);
                this.setActiveSheetIndex(actSheetIdx);
            }
            if (sheetIdx !== actSheetIdx)
                div.hide();
            else
                this._initSelection();
            this._initSheetModel(sheetIdx);
            if (this.isImport && sheet._isFreezed) {
                impData = this._impData.model.sheets[sheetIdx];
                sIdx = this.getRangeIndices(impData.paneTopLeftCell);
                if (this._isFrozen(sheet.frozenRows))
                    this.XLScroll._vScroller(sheetIdx).scroll(this._getRowOffsetTop(sheet, sIdx[0]) - sheet._frozenHeight);
                if (this._isFrozen(sheet.frozenColumns))
                    this.XLScroll._hScroller(sheetIdx).scroll(this._getColOffsetLeft(sheet, sIdx[1]) - sheet._frozenWidth);
            }
            sheet._isLoaded = true;
            if (!this._isSheetInsert && (this._pageClickArgs || this._gotoPageArgs))
                this._pageLoadComplete(sheetIdx);
            this.getSheet(actSheetIdx)._isOpened = true;
            if (this.model.showRibbon) {
                if ($("#" + this._id + "_Ribbon")[0].style.overflow === "hidden") {
                    $("#" + this._id + "_Ribbon")[0].style.overflow = "";
                    if (this.model.showRibbon)
                        this.XLRibbon._refreshBackstageHeight();
                }
                sheet._isRibCollapsed = !this.XLRibbon._ribbonState;
			}
			if (this._isAutoWHMode)
                this._autoSSWidthHeight(sheetIdx);
        },

        _initSheetModel: function (sheetIdx) {
            var sIdx, toprow, leftCol, impData, sheet = this.getSheet(sheetIdx), frows = this.getFrozenRows(sheetIdx), fcols = this.getFrozenColumns(sheetIdx);
            if (sheet.showHeadings === false)
                this.showHeadings(sheet.showHeadings);
            if (sheet._isImported) {
                impData = this._impData.model.sheets[sheetIdx];
                sIdx = this.getRangeIndices(impData.topLeftCell || "A1");
            }
            toprow = sheet._isImported ? sIdx[0] : ((this._isFrozen(frows) && sheet._bottomRow.idx <= frows) ? frows - 1 : 0);
            leftCol = sheet._isImported ? sIdx[1] : ((this._isFrozen(fcols) && sheet._rightCol.idx <= fcols) ? fcols - 1 : 0);
            if (this.model.scrollSettings.allowScrolling) {
                (toprow > 0) && this.XLScroll._vScroller(sheetIdx).scroll(this._getRowOffsetTop(sheet, toprow));
                (leftCol > 0) && this.XLScroll._hScroller(sheetIdx).scroll(this._getColOffsetLeft(sheet, leftCol));
            }
            if (this.model.allowFreezing) {
                if (this._isFrozen(frows) && this._isFrozen(fcols))
                    this.XLFreeze.freezePanes(frows, fcols);
                else if (this._isFrozen(frows))
                    this.XLFreeze._freeze(frows);
                else if (this._isFrozen(fcols))
                    this.XLFreeze._freeze(null, fcols);
            }
        },

        _initTmplColumns: function (sheetIdx) {
            var i, idx, value, field, data, range, sheet = this.getSheet(sheetIdx);
            if (!this._sheetCopy.isSheetCopy && !sheet.rangeSettings.length && sheet.dataSource && sheet._jsonData && sheet.fieldAsColumnHeader) {
                data = sheet._jsonData[0];
                range = this.getRangeIndices(sheet.startCell);
                i = range[1] + 1;
                if (data) {
                    for (field in data) {
                        if (data.hasOwnProperty(field)) {
                            value = data[field];
                            if (typeof data[field] === "object")
                                field = this._iterateComplxObj(data[field], field).prop;
                            sheet.columns[i - 1] = {
                                field: this._generateHeaderText(i),
                                text: field,
                                type: value != null ? (value.getDay ? "date" : typeof (value)) : null
                            };
                            i++;
                        }
                    }
                    sheet.colCount = sheet._templateColCount = sheet.columns.length;
                    sheet._isTemplate = true;
                }
            }
        },

        _refreshCellBinding: function (sheetIdx) {
            var i, j, len, sheet = this.getSheet(sheetIdx), mergeCellsCln = sheet.mergeCells, hideRowsCln = sheet.hideRows, rowIdx, curCell, cell;
            if (mergeCellsCln.length) {
                var k, range, rowCount, colCount, mergeObj;
                for (k = 0, len = mergeCellsCln.length; k < len; k++) {
                    range = this.getRangeIndices(mergeCellsCln[k]), rowCount = range[2] - range[0] + 1, colCount = range[3] - range[1] + 1, mergeObj;
                    for (i = 0; i < rowCount; i++) {
                        for (j = 0; j < colCount; j++) {
                            if (i == 0 && j == 0)
                                mergeObj = { merge: { isMerge: true, mRange: mergeCellsCln[k], isCenterAlign: false, mSpan: { colSpan: colCount, rowSpan: rowCount } } };
                            else
                                mergeObj = { isMHide: true, mergeIdx: { rowIndex: range[0], colIndex: range[1] } };
                            this.XLEdit._updateDataContainer({ rowIndex: range[0] + i, colIndex: range[1] + j }, { dataObj: mergeObj, sheetIdx: sheetIdx, skipCell: true });
                        }
                    }

                }
            }
            if (hideRowsCln.length && this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = hideRowsCln.length; i < len; i++)
                    this._cellBindHiddenRows(hideRowsCln[i], hideRowsCln, sheetIdx);
            }

        },

        _cellBindHiddenRows: function (rowIdx, hideRowsCln, sheetIdx) {
            var curCell, cell, sheet = this.getSheet(sheetIdx), xlEdit = this.XLEdit;
            sheet.hideRowsCollection.push(rowIdx);
            this.XLScroll._getRowHeights(sheetIdx, hideRowsCln.sort()[0]);
            cell = (rowIdx === 0) ? { rowIndex: rowIdx, colIndex: 0 } : { rowIndex: rowIdx - 1, colIndex: 0 };
            curCell = { rowIndex: rowIdx, colIndex: 0 };
            xlEdit._updateDataContainer(cell, { dataObj: { hRow: true }, sheetIdx: sheetIdx, skipCell: true });
            xlEdit._updateDataContainer(curCell, { dataObj: { isRHide: true }, sheetIdx: sheetIdx, skipCell: true });
        },

        _updateHiddenRows: function (sheetIdx) {
            var i, len, rowColl, rows, hdrRows, sheet = this.getSheet(sheetIdx), hideRowsCln = sheet.hideRows, rowIdx, cFormatRuleCln = sheet.cFormatRule, cFormatRule, hideColsCln = sheet.hideColumns, borderColl = sheet.border;
            if (hideRowsCln.length && !this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = hideRowsCln.length; i < len; i++) {
                    rowIdx = hideRowsCln[i];
                    rowColl = this.getRows(sheetIdx), rows = rowColl[1], hdrRows = rowColl[0];
                    this.addClass(rows[rowIdx], "e-r-hide");
                    this.addClass(hdrRows[rowIdx], "e-r-hide");
                    rowIdx > 0 && this.addClass(hdrRows.eq(rowIdx - 1).find("td")[0], "e-hrow");
                    this._cellBindHiddenRows(rowIdx, hideRowsCln, sheetIdx);
                }
            }
            if (hideColsCln.length && !this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = hideColsCln.length; i < len; i++) {
                    if (!sheet.hideColsCollection[hideColsCln[i]])
                        this._updateHiddenColumns({ rowIndex: 0, colIndex: hideColsCln[i] }, sheetIdx);
                }
                this.XLScroll._getColWidths(sheetIdx, hideColsCln.sort()[0]);
            }
            if (!ej.isNullOrUndefined(cFormatRuleCln) && cFormatRuleCln.length) {
                for (i = 0, len = sheet.cFormatRule.length; i < len; i++) {
                    cFormatRule = sheet.cFormatRule[i];
                    this.XLCFormat._cFormat(cFormatRule.action, cFormatRule.inputs[0], cFormatRule.inputs[1], cFormatRule.color, cFormatRule.bgColor, cFormatRule.range, sheetIdx);
                }
            }

            if (borderColl.length && !this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = borderColl.length; i < len; i++)
                    this._updateCellBorder(borderColl[i], sheetIdx);
            }
        },

        _updateHiddenColumns: function (cell, sheetIdx) {
            var rowIdx = cell.rowIndex, colIdx = cell.colIndex, sheet = this.getSheet(sheetIdx), dataObj = { isCHide: true }, curCell, prevCell, sheetHdr = this._getJSSheetHeader(sheetIdx), hdrElem = sheetHdr.find("th"), hdrcolgrp = sheetHdr.find("col"), colGrp = this._getContent(sheetIdx).find("col");
            sheet.hideColsCollection[colIdx] = sheet.columnWidth;
            sheet.columnsWidthCollection[colIdx] = 0;
            if (colIdx === 0)
                dataObj.hCol = true;
            this._writeRule(colIdx, sheetIdx);
            this.addClass(hdrElem[colIdx], "e-hide");
            this.addClass(hdrcolgrp[colIdx], "e-hide");
            this.addClass(colGrp[colIdx], "e-hide");
            !sheetHdr.find('th:eq(' + (colIdx - 1) + ')').hasClass("e-hide") && this.addClass(sheetHdr.find('th:eq(' + (colIdx - 1) + ')')[0], "e-hcol");
            this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: colIdx }, { dataObj: dataObj, sheetIdx: sheetIdx, skipCell: true });
            if (colIdx > 0)
                this.isUndefined(this.XLEdit.getPropertyValue(0, colIdx - 1, "isCHide")) && this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: colIdx - 1 }, { dataObj: { hCol: true }, sheetIdx: sheetIdx, skipCell: true });
        },


        _renderContent: function (sheetIdx) {
            var elems = [], div = ej.buildTag('div.e-spreadsheetheader'), innerDiv = ej.buildTag('div.e-headercontent'),
               colHeader = ej.buildTag('div.e-spreadsheetcolumnheader e-icon e-ss-selectall  e-ss-cursor', "", {}, {}),
               contentContainer = ej.buildTag('div.e-spreadsheetcontentcontainer', "", { "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }), cont = ej.buildTag("div.e-content e-ss-cursor"),
               rowHeader = ej.buildTag('div.e-spreadsheetrowheader', "", { "float": "left", "width": "30px" }, {}), rowHdrCont = ej.buildTag("div.e-rowheadercontent");
            if (this._isAutoWHMode) {
                cont.addClass("e-rmvbtmbdr");
                innerDiv.addClass("e-rmvrghtbdr");
                rowHdrCont.addClass("e-rmvbtmbdr");
            }
            this._setJSSheetHeader(div, sheetIdx);
            div.append(colHeader);
            div.append(innerDiv);
            elems.push(div);
            div = ej.buildTag("div.e-spreadsheetcontent");
            this._setJSSheetContent(div, sheetIdx);
            this._setContent(contentContainer, sheetIdx);
            this._setJSSheetRowHeader(rowHeader, sheetIdx);
            this._setJSSheetRowHeaderContent(rowHdrCont, sheetIdx);
            rowHeader.append(rowHdrCont);
            contentContainer.append(cont);
            div.append(rowHeader);
            div.append(contentContainer);
            elems.push(div);
            return elems;
        },

        refreshContent: function (sheetIdx) {
            sheetIdx = sheetIdx || this.getActiveSheetIndex();
            var contentrows, rowhdrrows, settings = {}, sheet = this.getSheet(sheetIdx), scroll = this.model.scrollSettings,
                isVirtualScroll = scroll.allowVirtualScrolling, cont = this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content");
            this._initDataRange(sheetIdx);
            this._refreshRowColCnt(sheetIdx);
            this._getJSSheetHeader(sheetIdx).find(".e-headercontent").html(this._renderHeaderColumns(sheetIdx));
            this._refreshTemplates(sheetIdx);
            this._getJSSheetRowHeaderContent(sheetIdx).html(this._renderHdrRows(sheetIdx));
            cont.find(".e-table").remove();
            cont.prepend(this._renderContTable(sheetIdx));
            this._initViewPortCont(sheetIdx);
            if (this._isAutoWHMode) {
                if (!this._isInitLoad)
                    this._autoSSWidthHeight(sheetIdx);
            }
            else
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "all");
            if (!isVirtualScroll) {
                this.XLScroll._getFirstRow(sheetIdx);
                this.XLScroll._getFirstColumn(sheetIdx);
            }
            contentrows = this._getContTBody(sheetIdx).find("tr");
            rowhdrrows = this._getRowHdrTBody(sheetIdx).find("tr");
            this.setRows([rowhdrrows, contentrows], sheetIdx);
        },

        _autoSSWidthHeight: function (sheetIdx, refrshWHSttgsOnly) {
            var settings = {}, scroll = this.model.scrollSettings, ribObj = $("#" + this._id + "_Ribbon").data("ejRibbon");
            sheetIdx = sheetIdx || this._getSheetIndex();
            this._responsiveWidth = this._dlgWidth = settings.width = this._getContTBody(sheetIdx).width() + this._getJSSheetRowHeader(sheetIdx).width();
            if (this.model.showRibbon && settings.width <= 480) {
                settings.width = 480;
                this._getContent(sheetIdx).find(".e-content").removeClass("e-rmvrghtbdr");
            }
            else if (!refrshWHSttgsOnly)
                this._getContent(sheetIdx).find(".e-content").addClass("e-rmvrghtbdr");
            if (!refrshWHSttgsOnly)
                this._setSheetWidthHeight(sheetIdx, settings, null, "refresh");
            if (this.model.showRibbon) {
				(settings.width <= 480) && this._alignFormulaBar(settings.width);
                this.XLRibbon._refreshBackstageHeight();
                ribObj.setModel({ width: settings.width });
            }
			this._responsiveHeight = this._dlgHeight = settings.height = this.element.height();
        },

        _initDataRange: function (sheetIdx) {
            var len, range, setting, rowCnt, colCnt, rowIdx, colIdx, i = 0, sheet = this.getSheet(sheetIdx), settings = this.getDataSettings(sheetIdx);
            if (settings) {
                len = settings.length;
                while (i < len) {
                    setting = settings[i];
                    if (setting._jsonData) {
                        setting.batchChanges = { added: [], changed: [], deleted: [] };
                        setting.fields = this.getObjectKeys(setting._jsonData[0]);
                        range = setting.startCell ? this._toIntrnlRange(setting.startCell, sheetIdx) : [0, 0, 0, 0];
                        range[2] = range[0] + (!setting.fieldAsColumnHeader && setting.showHeader ? setting.count : setting.count - 1);
                        range[3] = range[1] + this.getObjectLength(setting._jsonData[0]) - 1;
                        setting.range = range;
                        rowIdx = range[2], colIdx = range[3]; // used range update
                        if (this._isAutoWHMode || sheet.usedRange.rowIndex < rowIdx)
                            sheet.usedRange.rowIndex = rowIdx;
                        if (this._isAutoWHMode || sheet.usedRange.colIndex < colIdx)
                            sheet.usedRange.colIndex = colIdx;
                        rowCnt = rowIdx + 1, colCnt = colIdx + 1; // row and col count update
                        if (this._isAutoWHMode || sheet.rowCount < rowCnt)
                            sheet.rowCount = rowCnt;
                        if (this._isAutoWHMode || sheet.colCount <= colCnt)
                            sheet.colCount = colCnt;
                        sheet._hasDataSrc = true;
                    }
                    i++;
                }
            }
        },

        _renderStyleTag: function (type) {
            var rtag, stag;
            rtag = document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0];
            stag = document.createElement("style");
            stag.type = "text/css";
            if (type == "custom") {
                stag.setAttribute("id", this._id + "_sscustomformat");
                rtag.appendChild(stag);
            }
            else if (type === "showhide" && !document.getElementById(this._id + "_sshide")) {
                stag.setAttribute("id", this._id + "_sshide");
                rtag.appendChild(stag);
            }
            return stag;
        },

        _renderHeaderColumns: function (sheetIdx) {
            var colHdr, table, colGroup, valColl, thead = document.createElement('thead');
            valColl = this._renderHeaderCol(sheetIdx, 0, this.getSheet(sheetIdx).colCount);            
            table = ej.buildTag('table.e-table')[0];
            if (this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal)
                $(table).width(this._getEntireColWidth(sheetIdx));
            else
                this.addClass(table, "e-ss-hdrspacing");
            colGroup = valColl[1];
            colHdr = valColl[0];
            thead.appendChild(colHdr);
            table.appendChild(colGroup);
            table.appendChild(thead);
            return table;
        },

        _renderHeaderCol: function (sheetIdx, startIdx, colCount) {
            var thCls, hdrCell, hdrCellDiv, col, colTxt, hTxt, hdrTxt, value, colWth, width = 0, arr = [], i = startIdx, sheet = this.getSheet(sheetIdx),
                colHdr = document.createElement('tr'), colGrp = document.createElement('colgroup');
            colHdr.className = "e-columnheader";
            if (!this.isImport) {
                sheet._colWidthCollection.length = 0;
                sheet._ofColWidthColl.length = 0;
            }
            sheet._colWidthCollection.push(width);
            sheet._ofColWidthColl.push(width);
            while (i < colCount) {
                thCls = "e-headercell";
                colTxt = "col";
                colWth = sheet.columnsWidthCollection[i];
                if (this.isUndefined(colWth))
                    colWth = sheet.columnsWidthCollection[i] = sheet.columnWidth;
                if (i != colCount - 1) {
                    width = sheet._colWidthCollection[sheet._colWidthCollection.length - 1] + colWth;
                    sheet._colWidthCollection.push(width);
                    sheet._ofColWidthColl.push(width);
                }
                if (this.model.allowSelection && this._inColumn(sheet.selectedRange, i)) {
                    thCls += " e-colhighlight";
                    if (sheet._isColSelected)
                        thCls += " e-colselected";
                }
                if (colWth < 1) {
                    colTxt += ".e-hide";
                    thCls += " e-hide";
                }
                else if (sheet._hiddenFreezeCols.indexOf(i) > -1) {
                    colTxt += ".e-fcol-hide";
                    thCls += " e-fcol-hide";
                }
                if(this.IsImport || sheet._isLoaded)
					this.XLEdit.getPropertyValue(0, i, "hCol") && (thCls += " e-hcol");
                hdrCell = document.createElement('th');
                hdrCell.className = thCls;
                hTxt = hdrTxt = this._generateHeaderText(i + 1);
                if (sheet.fieldAsColumnHeader && sheet.columns[i])
                    hTxt = sheet.columns[i].text;
                hdrCellDiv = document.createElement('div');
                hdrCellDiv.className = "e-headercelldiv";
                hdrCellDiv.innerHTML = hTxt;
                hdrCell.appendChild(hdrCellDiv);
                col = ej.buildTag(colTxt, "", { width: colWth }, {});
                colHdr.appendChild(hdrCell);
                colGrp.appendChild(col[0]);
                if (!this._sheetCopy.isSheetCopy && !sheet.columns[i]) {
                    sheet.columns[i] = {
                        field: hdrTxt,
                        text: hdrTxt,
                        type: value != null ? (value.getDay ? "date" : typeof (value)) : null,
                    };
                }
                i++;
            }
            arr.push(colHdr);
            arr.push(colGrp);
            return arr;
        },

        _getWidth: function (scolIdx, ecolIdx, sheetIdx) {
            var wth = 0, sheet = this.getSheet(sheetIdx);
            for (; scolIdx <= ecolIdx; scolIdx++)
                wth += sheet.columnsWidthCollection[scolIdx];
            return wth;
        },

        _getEntireColWidth: function (sheetIdx) {
            var sheet = this.getSheet(sheetIdx), lastColTop = this._getIdxWithOffset(null, this._getLastColIdx(sheet)).xOffset;
            return lastColTop + sheet.columnsWidthCollection[sheet.columnsWidthCollection.length - 1];
        },

        _getLastColIdx: function (sheet) {
            var colIdx = sheet.colCount - 1;
            while (colIdx > -1) {
                if (!(colIdx in sheet.hideColsCollection) && sheet._hiddenFreezeCols.indexOf(colIdx) === -1)
                    break;
                colIdx--;
            }
            return colIdx;
        },

        _getIdxWithOffset: function (y, x, isOffset, skipActions, sheetIdx) {
            skipActions = skipActions || [];
            var isDefaultHide, isFreezeHide, len, i, idx, pos, offset, obj = {}, hideTypes = ej.Spreadsheet.HideTypes, sheet = this.getSheet(sheetIdx);
            i = idx = pos = offset = 0;
            if (!ej.isNullOrUndefined(y)) {
                if (isOffset) {
                    len = sheet.rowsHeightCollection.length;
                    while (i < len) {
                        isDefaultHide = isFreezeHide = false;
                        if (skipActions.indexOf(hideTypes.Default) === -1 && sheet.hideRowsCollection.indexOf(i) > -1)
                            isDefaultHide = true;
                        if (skipActions.indexOf(hideTypes.Freeze) === -1 && sheet._hiddenFreezeRows.indexOf(i) > -1)
                            isFreezeHide = true;
                        if (!isDefaultHide && !isFreezeHide) {
                            pos += sheet.rowsHeightCollection[i];
                            if (pos > y) {
                                idx = i;
                                break;
                            }
                            offset = pos;
                        }
                        i++;
                    }
                }
                else {
                    while (i < y) {
                        isDefaultHide = isFreezeHide = false;
                        if (skipActions.indexOf(hideTypes.Default) === -1 && sheet.hideRowsCollection.indexOf(i) > -1)
                            isDefaultHide = true;
                        if (skipActions.indexOf(hideTypes.Freeze) === -1 && sheet._hiddenFreezeRows.indexOf(i) > -1)
                            isFreezeHide = true;
                        if (!isDefaultHide && !isFreezeHide)
                            offset += sheet.rowsHeightCollection[i];
                        i++;
                    }
                    idx = y;
                }
                obj.rowIdx = idx;
                obj.yOffset = offset;
            }
            if (!ej.isNullOrUndefined(x)) {
                if (isOffset) {
                    i = idx = pos = offset = 0, len = sheet.columnsWidthCollection.length;
                    while (i < len) {
                        isDefaultHide = isFreezeHide = false;
                        if (skipActions.indexOf(hideTypes.Default) === -1 && i in sheet.hideColsCollection)
                            isDefaultHide = true;
                        if (skipActions.indexOf(hideTypes.Freeze) === -1 && sheet._hiddenFreezeCols.indexOf(i) > -1)
                            isFreezeHide = true;
                        if (!isDefaultHide && !isFreezeHide) {
                            pos += sheet.columnsWidthCollection[i];
                            if (pos > x) {
                                idx = i;
                                break;
                            }
                            offset = pos;
                        }
                        i++;
                    }
                }
                else {
                    while (i < x) {
                        isDefaultHide = isFreezeHide = false;
                        if (skipActions.indexOf(hideTypes.Default) === -1 && i in sheet.hideColsCollection)
                            isDefaultHide = true;
                        if (skipActions.indexOf(hideTypes.Freeze) === -1 && sheet._hiddenFreezeCols.indexOf(i) > -1)
                            isFreezeHide = true;
                        if (!isDefaultHide && !isFreezeHide)
                            offset += sheet.columnsWidthCollection[i];
                        i++;
                    }
                    idx = x;
                }
                obj.colIdx = idx;
                obj.xOffset = offset;
            }
            return obj;
        },

        _getEntireRowHeight: function (sheetIdx) {
            var sheet = this.getSheet(sheetIdx);
            return sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1] + sheet.rowsHeightCollection[sheet.rowsHeightCollection.length - 1];
        },

        _renderHdrRows: function (sheetIdx) {
            var i, j, k, l, len, cnt, cls, hgt, row, cell, span, diff, table, rowHgt, rowIdx, minrIdx, cellData,
                sheet = this.getSheet(sheetIdx), isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling;
            table = ej.buildTag("table.e-table", "<colgroup><col style='width: 30px;'></colgroup>", {});
            this.addClass(table[0], "e-ss-rowhdrspacing");
            if (!this._sheetCopy.isSheetCopy) {
                hgt = rowIdx = 0;
                cellData = sheet.rows;
                i = 0, cnt = sheet.rowCount;
                sheet._rowHeightCollection = [], sheet._rowIdxColl = [];
                sheet._rowHeightCollection.push(hgt);
                while (i < cnt) {
                    rowHgt = sheet.rowsHeightCollection[i];
                    if (!rowHgt)
                        rowHgt = sheet.rowsHeightCollection[i] = sheet.rowHeight;
                    if (!isVirtualScroll || (sheet.hideRowsCollection.indexOf(i) === -1 && sheet._hiddenFreezeRows.indexOf(i) === -1))
                        sheet._rowIdxColl.push(i);
                    else
                        rowHgt = 0;
                    if (i != cnt - 1)
                        sheet._rowHeightCollection.push(sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1] + rowHgt);
                    i++;
                }
                if (cellData) {
                    minrIdx = -1;
                    len = cellData.length;
                    diff = (this._browserDetails.name === "mozilla") ? 2 : 1;
                    for (j = 0; j < len; j++) {
                        row = cellData[j];
                        l = row.cells.length;
                        if (!this.isUndefined(row.index))
                            rowIdx = row.index;
                        hgt = row.height || sheet.rowHeight;
                        if (sheet.rowHeight < hgt) {
                            sheet.rowsHeightCollection[rowIdx] = hgt;
                            if (minrIdx === -1)
                                minrIdx = rowIdx;
                        }
                        for (k = 0; k < l; k++) {
                            cell = row.cells[k];
                            if (cell.style && cell.style["font-size"]) {
                                span = document.getElementById(this._id + '_emptySpan');
                                cls = this.XLFormat._createFormatClass(cell.style);
                                this.addClass(span, cls);
                                span.textContent = cell.value;
                                hgt = span.offsetHeight + diff;
                                if (hgt > sheet.rowsHeightCollection[rowIdx]) {
                                    sheet.rowsHeightCollection[rowIdx] = hgt;
                                    if (minrIdx === -1)
                                        minrIdx = rowIdx;
                                }
                                this._refreshGlobalSpan(span);
                            }
                            if (!this.isUndefined(cell.value))
                                sheet._hasDataSrc = true;
                        }
                        rowIdx++;
                    }
                    if (minrIdx !== -1)
                        this.XLScroll._getRowHeights(sheetIdx, minrIdx, true);
                }
            }
            if (isVirtualScroll)
                table.append("<tbody class='e-ss-virtualtop'></tbody><tbody></tbody><tbody class='e-ss-virtualbottom'></tbody>");
            else
                table.append("<tbody>" + this._renderRowHdr(sheet._rowIdxColl, sheetIdx) + "</tbody>");
            this._setRowHdrTBody(table.find("tbody").eq(isVirtualScroll ? 1 : 0), sheetIdx);
            return table;
        },

        _renderRowHdr: function (rowIdxArr, sheetIdx) {
            var idx, cnt, obj, i = 0, data = [], sheet = this.getSheet(sheetIdx);
            cnt = rowIdxArr ? rowIdxArr.length : sheet.rowCount;
            while (i < cnt) {
                idx = rowIdxArr ? rowIdxArr[i] : i;
                if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(idx, 0, "isFilterHide", sheetIdx)) || ej.isNullOrUndefined(this.XLEdit.getPropertyValue(idx, 0, "isRHide", sheetIdx))) {
                    obj = { height: sheet.rowsHeightCollection[idx] < this.model.rowHeight ? this.model.rowHeight : sheet.rowsHeightCollection[idx], rowidx: idx };
                    obj.className = this.XLEdit.getPropertyValue(idx, 0, "hRow", sheetIdx) ? "e-rowheader e-hrow " : "e-rowheader";
                    if (this.XLEdit.getPropertyValue(idx, 0, "isFilterHighlight", sheetIdx))
                        obj.className += " e-filterhiglight";
                    obj.wrap = this.XLEdit.getPropertyValue(idx, 0, "wrapRow", sheetIdx) ? " e-sswraprow" : "";
                    if (this.model.allowSelection && this._inRow(sheet.selectedRange, idx)) {
                        obj.className += " e-rowhighlight";
                        if (sheet._isRowSelected)
                            obj.className += " e-rowselected";
                    }
                    data.push(obj);
                }
                i++;
            }
            return $.render[this._id + "JSONRowHdrTemplate" + sheetIdx](data);
        },

        _refreshDataSrc: function (range, sheetIdx) {
            var j, k, l, m, n, data, setting, len, formatClass, dataObj, srange, field, showHdr, isSheetData, i = 0,
                sheet = this.getSheet(sheetIdx), settings = this.getDataSettings(sheetIdx);
            showHdr = isSheetData = false;
            if (!sheet.rangeSettings.length && sheet.dataSource)
                isSheetData = true;
            if (settings) {
                len = settings.length;
                while (i < len) {
                    setting = settings[i];
                    if (setting.range) {
                        srange = setting.range; // settings range
                        showHdr = isSheetData ? (!setting.fieldAsColumnHeader && setting.showHeader) : setting.showHeader;
                        if (setting.headerStyles && this.getObjectLength(setting.headerStyles) && this.model.allowCellFormatting)
                            formatClass = this.XLFormat._createFormatClass(setting.headerStyles);
                        if (range) {
                            j = range[0], k = range[2], m = range[3];
                            while (j <= k) {
                                if (this._inRow(srange, j)) {
                                    l = range[1];
                                    while (l <= m) {
                                        if (this._inColumn(srange, l)) {
                                            field = setting.fields[l - setting.range[1]];
                                            if (showHdr && j === srange[0]) {
                                                data = setting._jsonData[j - setting.range[0]];
                                                if (data)
                                                    this._refreshCell(j, l, sheetIdx, setting, data, field, false, formatClass);
                                            }
                                            else {
                                                data = setting._jsonData[j - (setting.range[0] + (showHdr ? 1 : 0))];
                                                if (data)
                                                    this._refreshCell(j, l, sheetIdx, setting, data, field, true);
                                            }
                                        }
                                        l++;
                                    }
                                }
                                j++;
                            }
                        }
                        else {
                            j = 0, k = srange[0], m = srange[1], l = srange[2];
                            if (showHdr) {
                                data = setting._jsonData[j];
                                for (n in data) {
                                    this._refreshCell(k, m, sheetIdx, setting, data, n, false, formatClass);
                                    m++;
                                }
                                k++;
                            }
                            while (k <= l) {
                                data = setting._jsonData[j];
                                m = srange[1];
                                for (n in data) {
                                    this._refreshCell(k, m, sheetIdx, setting, data, n, true);
                                    m++;
                                }
                                j++, k++;
                            }
                        }
                    }
                    i++;
                }
            }
        },

        _refreshCell: function (rowIdx, colIdx, sheetIdx, setting, data, field, isCont, formatClass) {
            var dataObj, cmplxObj = this._iterateComplxObj(data[field], field), isSheetData, sheet = this.getSheet(sheetIdx);
            dataObj = this.XLEdit._parseValue(isCont ? cmplxObj.value : cmplxObj.prop, { rowIndex: rowIdx, colIndex: colIdx });
            dataObj.sheetIdx = sheetIdx;
            if (setting.rangeName)
                dataObj.rangeName = setting.rangeName;
            if (isCont) {
                if (setting.primaryKey === field)
                    dataObj.isReadOnly = true;
            }
            else {
                if (formatClass) {
                    dataObj.format = formatClass;
                    dataObj.formats = setting.headerStyles;
                }
                if (!sheet.rangeSettings.length && sheet.dataSource)
                    dataObj.isReadOnly = true;
            }
            this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: colIdx }, { dataObj: dataObj, sheetIdx: sheetIdx, skipCell: true });
        },

        _iterateComplxObj: function (obj, prop, cxprop) {
            var i, value, sep, cmplxProp = cxprop || prop, reslt = { prop: cmplxProp, value: obj };
            if (this._isObject(obj)) {
                sep = ".";
                for (i in obj) {
                    value = obj[i];
                    if (this.isUndefined(value))
                        return reslt;
                    else {
                        if (obj.hasOwnProperty(i) && this._isObject(value) && !this._isDateTime(value)) {
                            cmplxProp += sep + i;
                            reslt = this._iterateComplxObj(value, i, cmplxProp);
                        }
                        else {
                            reslt.prop += sep + i;
                            reslt.value = value;
                            return reslt;
                        }
                    }
                }
            }
            return reslt;
        },

        _refreshCellData: function (range, sheetIdx) {
            var i, j, row, cell, cells, colIdx, dataObj, cellData, userName, isFormula, formatObj, len, l, rowIdx = 0, sheet = this.getSheet(sheetIdx), cellData = sheet.rows, hideColsCln = sheet.hideColumns, borderColl = sheet.border;
            if (cellData) {
                for (i = 0, len = cellData.length; i < len; i++) {
                    colIdx = 0;
                    row = cellData[i];
                    cells = cellData[i].cells;
                    if (row.index)
                        rowIdx = row.index;
                    if ((!range || this._inRow(range, rowIdx)) && cells) {
                        for (j = 0, l = cells.length; j < l; j++) {
                            cell = cells[j];
                            if (cell.index)
                                colIdx = cell.index;
                            if ((!range || this._inColumn(range, colIdx))) {
                                dataObj = this.isUndefined(cell.value) ? {} : (cell.format && cell.format.type == "text") ? { type: "text", value: cell.value, value2: cell.value } : this.XLEdit._parseValue(cell.value, { rowIndex: rowIdx, colIndex: colIdx });
                                dataObj.value = this.isUndefined(dataObj.value) ? (this.isUndefined(this.XLEdit.getPropertyValue(rowIdx, colIdx)) ? "" : this.XLEdit.getPropertyValue(rowIdx, colIdx)) : dataObj.value;
                                isFormula = this.isFormula(dataObj.value);
								if (isFormula)
                                    this.XLEdit._refreshCalcEngine(rowIdx, colIdx, true, dataObj.value, sheetIdx);
                                if (cell.format) {
                                    formatObj = this.XLFormat._getFormatObj(cell.format);
                                    dataObj.type = cell.format.type;
                                    dataObj.formatStr = formatObj.format.formatStr;
                                    dataObj.decimalPlaces = formatObj.format.decimalPlaces;
                                    dataObj.thousandSeparator = formatObj.format.thousandSeparator ? true : false;
                                }
                                dataObj.value2 = this.XLFormat._format(isFormula ? this.XLEdit.getPropertyValue(rowIdx, colIdx, "value2") : dataObj.value, { formatStr: dataObj.formatStr, type: dataObj.type, thousandSeparator: dataObj.thousandSeparator, decimalPlaces: dataObj.decimalPlaces, cellObj: dataObj });
                                if (cell.hyperlink) {
                                    if (cell.hyperlink.webAddr)
                                        dataObj.hyperlink = cell.hyperlink.webAddr.indexOf("http") === -1 ? { webAddr: "http://" + cell.hyperlink.webAddr } : { webAddr: cell.hyperlink.webAddr };
                                    else
                                        dataObj.hyperlink = { cellAddr: cell.hyperlink.cellAddr + "_" + cell.hyperlink.sheetIndex || sheetIdx };
                                    dataObj.formats = { "color": this._hlColor };
                                }
                                if (cell.comment) {
                                    userName = (this.model.userName.length ? this.model.userName : this._getLocStr("UserName")) + ":\n";
                                    dataObj.comment = { value: userName + (cell.comment.value || ""), isVisible: cell.comment.isVisible || false };
                                }
                                if (cell.isLocked) {
                                    dataObj.isLocked = true;
                                    this.protectSheet(true);
                                }
                                if (cell.style){
									if(cell.style.fontWeight){
										cell.style["font-weight"] = cell.style.fontWeight;
										delete cell.style["fontWeight"];
									}	
									if(cell.style.backgroundColor){
										cell.style["background-color"] = cell.style.backgroundColor;
										delete cell.style["backgroundColor"];
									}
									dataObj.formats = $.extend(dataObj.formats, cell.style);
								}
                                if (dataObj.formats)
                                    dataObj.format = this.XLFormat._createFormatClass(dataObj.formats);
                                this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: colIdx }, { dataObj: dataObj, sheetIdx: sheetIdx, skipCell: true });
                             	this.XLEdit._refreshCellAlignment({ cellIdx: { rowIndex: rowIdx, colIndex: colIdx }, value: dataObj.value, type: dataObj.type });
                                if (!isFormula)
                                    this.XLEdit._refreshCalcEngine(rowIdx, colIdx, false, null, sheetIdx);
                            }
                            colIdx++;
                        }
                    }
                    rowIdx++;
                }
                if (this.model.scrollSettings.allowVirtualScrolling)
                    sheet._virtualTBodyHgt = sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1] + sheet.rowsHeightCollection[sheet.rowsHeightCollection.length - 1];
            }
            if (hideColsCln.length && this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = hideColsCln.length; i < len; i++) {
                    if (!sheet.hideColsCollection[hideColsCln[i]])
                        this._updateHiddenColumns({ rowIndex: 0, colIndex: hideColsCln[i] }, sheetIdx);
                }
                this.XLScroll._getColWidths(sheetIdx, hideColsCln.sort()[0]);
            }
            if (borderColl.length && this.model.scrollSettings.allowVirtualScrolling) {
                for (i = 0, len = borderColl.length; i < len; i++)
                    this._updateCellBorder(borderColl[i], sheetIdx);
            }
        },

        _updateCellBorder: function (border, sheetIdx) {
            var i, len, border1, option, borderColl, range = this.getRangeIndices(border.range);
            border1 = {
                top: { top: "1px solid" },
                right: { right: "1px solid" },
                bottom: { bottom: "1px solid" },
                left: { left: "1px solid" },
                outside: { top: "1px solid", right: "1px solid", bottom: "1px solid", left: "1px solid" },
                allborder: { top: "1px solid", right: "1px solid", bottom: "1px solid", left: "1px solid" },
                thickbox: { top: "2px solid", right: "2px solid", bottom: "2px solid", left: "2px solid" },
                thickbottom: { bottom: "2px solid" },
                topandbottom: { top: "1px solid", bottom: "1px solid" },
                topandthickbottom: { top: "1px solid", bottom: "2px solid" }
            };
            option = border1[border.type];
            borderColl = this.getObjectKeys((option));
            if (borderColl.length) {
                for (i = 0, len = borderColl.length; i < len; i++) {
                    option[borderColl[i]] = option[borderColl[i]].concat(" " + border.color);
                }
            }
            option.skipCell = true;
            option["sheetIdx"] = sheetIdx;
            border.type === "allborder" ? this.XLFormat._applyAllBorderCss(option, range) : this.XLFormat._applyBorderCss(option, range);
        },

        _renderContTable: function (sheetIdx) {
            var table;
            if (this._sheetCopy.isSheetCopy)
                table = $(this._sheetCopy.sheetContent);
            else {
                table = ej.buildTag("table.e-table", this._sheets[sheetIdx]._contentColGroup.outerHTML);
                if (this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal)
                    $(table).width(this._getEntireColWidth(sheetIdx));
                else
                    this.addClass(table, "e-ss-rowhdrspacing");
                if (this.model.scrollSettings.allowVirtualScrolling)
                    table.append("<tbody class='e-ss-virtualtop'></tbody><tbody></tbody><tbody class='e-ss-virtualbottom'></tbody>");
                else
                    table.append("<tbody></tbody>");
            }
            this._setContTBody(table.find("tbody").eq(this.model.scrollSettings.allowVirtualScrolling ? 1 : 0), sheetIdx);
            return table;
        },

        _initViewPortCont: function (sheetIdx) {
            var rangeData, sheet = this.getSheet(sheetIdx), props = ["value", "value2", "comment", "hyperlink", "format", "border", "type", "isFilterHide", "isRHide", "isFHide",
                "isFilterHeader", "isFilterVisible", "filterState", "isMHide", "merge", "hRow", "isLocked", "wrap", "isOverflow", "align", "picture", "cFormatRule", "isOfBrdr", "formatStr"];
            if (this.model.scrollSettings.allowVirtualScrolling) {
                this._refreshViewport(this._initLoad ? 0 : this._isFrozen(this.getFrozenRows()) ? sheet._contScrollTop : sheet._scrollTop, sheetIdx);
            }
            else {
                rangeData = this.getRangeData({ property: props, sheetIdx: sheetIdx, rowIdxs: sheet._rowIdxColl, withRowIdx: true });
                this._getContTBody(sheetIdx).html(this._renderData(rangeData, sheetIdx));
                if (this.model.allowComments)
                    this.XLComment._updateCmntArrowPos(null, sheetIdx);
            }
            sheet._isVPRendered = true;
        },

        _processCellTypes: function (cellTypes, sheetIdx) {
            var i, len, arr = [];
            for (i = 0, len = cellTypes.length; i < len; i++) {
                if (cellTypes[i]['cellType']['type'] === "DatePicker")
                    arr.push({ 'range': this._getAlphaRange(sheetIdx, cellTypes[i].rowIndex, cellTypes[i].colIndex, cellTypes[i].rowIndex, cellTypes[i].colIndex), 'settings': { 'type': cellTypes[i]['cellType']['type'], 'value': cellTypes[i]['value'] } });
                else
                    arr.push({ 'range': this._getAlphaRange(sheetIdx, cellTypes[i].rowIndex, cellTypes[i].colIndex, cellTypes[i].rowIndex, cellTypes[i].colIndex), 'settings': { 'type': cellTypes[i]['cellType']['type'], 'isChecked': cellTypes[i]['cellType']['isChecked'] } });
            }
            this.XLCellType._rangeCellTypes(arr, sheetIdx);
            this._celltypes = [];
        },

        _initDependencies: function () {
            var i = 1, model = this.model;
            this._renderAlertdlg();
            this._renderAlertDlgContent($("#" + this._id + "_alertdlg"), "Alert", "");
            this._initEditForm();
            if (model.allowClipboard)
                this.XLClipboard._initCopyPaste();
            if (model.allowEditing) {
                this.XLEdit._processEditing();
                this.getMainPanel().append(this.XLEdit._editElem);
                this.XLEdit._editElem.hide();
            }
            this._renderDDownList();
            this.clearUndoRedo();
            if (model.showRibbon)
                this.XLRibbon._disableButtons(['clearfilter'], 'ejButton');
            if (model.allowDataValidation)
                this.XLValidate._addDVMethod();
            if (model.enableContextMenu)
                this.XLCMenu._initCMenuFooter();
            if (model.allowFiltering)
                this.XLFilter._renderExcelFilter();
            if (model.allowFreezing)
                this.XLFreeze._initFreeze();
        },

        _initComplete: function () {
            if (this._reqCnt === this._resCnt) {
                !this._isRefresh && this._trigger("loadComplete", {});
                this.isDirty = false;
                this.clearUndoRedo();
                this.hideWaitingPopUp();
                this.XLRibbon.updateRibbonIcons();
            }
        },

        _showDialog: function (id, type) {
            var dlgHt, dlg, dlgclass = "e-dialog", model = this.model;
            switch (id) {
                case this._id + "_Ribbon_Home_Styles_ConditionalFormatting":
                    dlg = $("#" + this._id + "_CFDialog");
                    if (!dlg.length && model.allowConditionalFormats)
                        dlg = this.XLRibbon._initCFDialog();
                    dlg.ejDialog("open");
                    break;
                case this._id + "_chartname":
                    var dlg = $("#" + this._id + "_chartnamedlg");
                    if (!dlg.length)
                        this.XLRibbon._renderChartNameDlg();
                    break;
                case this._id + "_Ribbon_ChartDesign_Type_ChangeChartType":
                    var dlg = $("#" + this._id + "_charttypedlg");
                    if (!dlg.length)
                        dlg = this.XLRibbon._renderChartTypeDialog();
                    break;
                case this._id + "_ImportPasswordDialog":
                    var dlg = $("#" + this._id + "_ImportPasswordDialog");
                    if (!dlg.length)
                        dlg = this._importPasswordDlg();
                    dlg.ejDialog("open");
                    break;
                case this._id + "_Ribbon_Insert_Links_Hyperlink":
                    if (!this.model.isReadOnly) {
                        if (model.allowHyperlink && !this._hasClass(document.getElementById(this._id + "_HLDialog"), dlgclass))
                            this.XLRibbon._initHLDialog();
                        this._hlDlgOpen();
                    }
                    break;
                case this._id + "_Ribbon_SparklineDesign_Sparkline_EditData":
                         this.XLSparkline._initSparklineDialog();
                        this.XLSparkline._renderSparklineDialog();
                        this.XLSparkline._renderSparklineDesignDlg();
                    break;
                case this._id + "_Ribbon_Others_Cells_InsertCellOptions":
                    if (model.allowInsert) {
                        if (!this._hasClass(document.getElementById(this._id + "_insertdeletedlg"), dlgclass))
                            this._renderInsertDeleteDialog();
                        this._refreshInsDelDialog("Insert");
                    }
                    break;
                case this._id + "_Ribbon_Insert_Sparkline_Column" :
                case this._id + "_Ribbon_Insert_Sparkline_Line" :
                case this._id + "_Ribbon_Insert_Sparkline_Pie" :
                case this._id + "_Ribbon_Insert_Sparkline_Area" :
                case this._id + "_Ribbon_Insert_Sparkline_Winloss" :
                    if(model.allowSparkline && !this._hasClass(document.getElementById(this._id + "_SparklineDialog"), dlgclass)) {
                        this.XLSparkline._initSparklineDialog();
                        this.XLSparkline._renderSparklineDialog();
                }
                break;
                case this._id + "_Ribbon_Others_Cells_DeleteCellOptions":
                    if (model.allowDelete) {
                        if (!this._hasClass(document.getElementById(this._id + "_insertdeletedlg"), dlgclass))
                            this._renderInsertDeleteDialog("delete");
                        this._refreshInsDelDialog("Delete");
                    }
                    break;
                case this._id + "_FormatCells":
                    if (model.allowCellFormatting && !this._hasClass(document.getElementById(this._id + "_formatdlg"), dlgclass))
                        this.XLCellFrmtDlg._renderCellFrmtDlg();
                    this.XLCellFrmtDlg._initFormatCellDlg();
                    break;
                case this._id + "_MoveorCopy":
                    if (!this._hasClass(document.getElementById(this._id + "_moveCopyDlg", dlgclass)))
                        this._initMoveCopyDlg();
                    this._renderMoveCopyDlg();
                    break;
                case this._id + "_UnhideSheet":
                    if (!this._hasClass(document.getElementById(this._id + "_UnhideDlg", dlgclass)))
                        this._initUnhideDlg();
                    this._renderUnhideDlg();
                    break;
                case this._id + "_Ribbon_Data_DataTools_DataValidation":
                case this._id + "_Ribbon_Data_DataTools_DataValidationOptions":
                    if (this.model.allowDataValidation && !this._hasClass(document.getElementById(this._id + "_ValDialog"), dlgclass)) {
                        dlgHt = this.XLRibbon._initValDialog();
                        this.XLRibbon._renderValDialog(dlgHt);
                    }
                    break;
                case this._id + "_Filter":
                    if (!document.getElementById(this._id + type + "_excelDlg") && !document.getElementById(this._id + "_filter_custom_" + type))
                        this.XLFilter._renderFilterDialogs(type);
                    break;
                case this._id + "_Ribbon_Review_Changes_ProtectWorkbook":
                    if (!this._hasClass(document.getElementById(this._id + "_PasswordDialog"), dlgclass))
                        this._passwordDlg();
                    break;
                case this._id + "_Ribbon_Insert_Tables_Table":
                    if (model.allowFormatAsTable && !this._hasClass(document.getElementById(this._id + "_fatnamedlg"), dlgclass))
                        this.XLRibbon._renderFATNameDlg();
                    break;
                case this._id + "_Ribbon_Insert_Tables_PivotTable":
                    if (model.enablePivotTable && !this._hasClass(document.getElementById(this._id + "_PvtDialog"), dlgclass)) {
                        this.XLRibbon._initPvtDialog();
                        this.XLRibbon._renderPvtDialog();
                    }
                    break;
                case this._id + "_Ribbon_Others_Editing_FindSelect":
                    if (model.allowSearching && !this._hasClass(document.getElementById(this._id + "_FRDialog"), dlgclass)) {
                        this.XLRibbon._initFRDialog();
                        this.XLRibbon._renderFRDialog();
                        if (!this.model.isReadOnly) {
                            dlgHt = this.XLRibbon._initGoToDialog();
                            this.XLRibbon._renderGoToDialog(dlgHt);
                        }
                    }
                    if (this.model.isReadOnly)
                        $("#" + this._id + "_FRDialog_FPDlgTab").ejTab("option", { disabledItemIndex: [1, 2] });
                    else
                        $("#" + this._id + "_FRDialog_FPDlgTab").ejTab("option", { enabledItemIndex: [1, 2] });
                    break;
                case this._id + "_Ribbon_ChartDesign_Data_SelectData":
                    if (model.allowCharts && !this._hasClass(document.getElementById(this._id + "_chartrangedlg", dlgclass)))
                        this.XLChart._renderChartRangeDialog();
                    break;
                case this._id + "_Ribbon_Others_NameManager":
                    if (!document.getElementById(this._id + "_nmdlg"))
                        this.XLRibbon._renderNameManagerDlg();
                    else
                        $("#" + this._id + "_nmgrid").ejGrid("option", { dataSource: this.model.nameManager });
                    break;
                case this._id + "_Ribbon_Design_Tools_ResizeTable":
                    if (!document.getElementById(this._id + '_fatresizetabledlg'))
                        this.XLRibbon._renderFATResizeTableDlg();
                    break;
				case "exportxl":
				case "exportcsv":
				case "exportpdf":
                    if (!document.getElementById(this._id + '_ExportFileNameDialog'))
                        this.XLExport._exportFileNameDlg();
                    break;
                case this._id + "_CustomCellDialog":
                    if (!document.getElementById(this._id + '_CustomCellDialog')) {
                        this.XLFormat._customStyleDlg();
                        this.XLFormat._styleDlgOpen();
                    }
                    else this.XLFormat._styleDlgOpen();
                    break;
            }
        },

        _generateHeaderText: function (colIndex) {
            var alphabet = "Z";
            if (colIndex / 26 > 1)
                return this._generateHeaderText((colIndex % 26 === 0) ? (colIndex / 26 - 1) : Math.floor(colIndex / 26)) + String.fromCharCode((colIndex % 26) === 0 ? alphabet.charCodeAt(alphabet) : 64 + (colIndex % 26));
            else
                return String.fromCharCode(64 + (colIndex));
        },

        _generateColCount: function (text) {
            var colCount = 0;
            text = text.split('').reverse().join('');
            for (var i = text.length - 1; i >= 0  ; i--) {
                colCount += (text[i].charCodeAt(text[i]) - 64) * (Math.pow(26, i));
            }
            return colCount;
        },

        _getSheetIndex: function (sheetIdx) {
            return sheetIdx || this.getActiveSheetIndex();
        },

        _getSheetIdxFromSheetValue: function (name) {
            var i = 1, sheets = this.model.sheets, len = sheets.length - 1;
            while (i <= len) {
                if (sheets[i].sheetInfo.value.toLowerCase() === name.toLowerCase())
                    return i;
                i++;
            }
            return -1;
        },

        getAlphaRange: function (sRIndex, sCIndex, eRIndex, eCIndex) {
            if (this.isUndefined(eRIndex) && this.isUndefined(eCIndex)) {
                eRIndex = sRIndex;
                eCIndex = sCIndex;
            }
            return this._getAlphaRange(null, sRIndex, sCIndex, eRIndex, eCIndex);
        },

        _getAlphaRange: function (sindex, srindex, scindex, erindex, ecindex) {
            srindex = srindex + 1, scindex = scindex + 1, erindex = erindex + 1, ecindex = ecindex + 1;
            return srindex === erindex && scindex === ecindex ? this._generateHeaderText(scindex) + srindex : this._generateHeaderText(scindex) + srindex + ":" + this._generateHeaderText(ecindex) + erindex;
        },

        _getProperAlphaRange: function (sindex, minrindex, mincindex, maxrindex, maxcindex) {
            var range = this._getAlphaRange(sindex, minrindex, mincindex, maxrindex, maxcindex);
            return range.indexOf(':') === -1 ? range + ':' + range : range;
        },

        _getDollarAlphaRange: function (range, checkRange) {
            var sheetIdx = this.getActiveSheetIndex(), sName = this.getSheet(sheetIdx).sheetInfo.text, sNameStr = sName.match(/\s/g) ? "'" + sName + "'" : sName;
            if (checkRange && !this.isRange(range))
                return sNameStr + "!$" + this._generateHeaderText(range[1] + 1) + "$" + (range[0] + 1);
            else
                return sNameStr + "!$" + this._generateHeaderText(range[1] + 1) + "$" + (range[0] + 1) + ":$" + this._generateHeaderText(range[3] + 1) + "$" + (range[2] + 1);
        },

        _toIntrnlRange: function (range, sheetIdx) {
            if (!range)
                range = this.getSheet(sheetIdx).selectedRange;
            else if (this._isString(range))
                range = this.getRangeIndices(range);
            return range;
        },

        _getMaxRowColCnt: function (sheets, fromUsedRange, sheetIdx) {
            var rowCount, colCount, sheet, rcnt = 0, ccnt = 0, sheets = sheets ? sheets : this.model.sheets,
                i = sheetIdx ? sheetIdx : 1, len = sheetIdx ? sheetIdx + 1 : sheets.length;
            while (i < len) {
                sheet = sheets[i];
                if (fromUsedRange && sheet.usedRange) {
                    rowCount = sheet.usedRange.rowIndex;
                    colCount = sheet.usedRange.colIndex;
                }
                else {
                    rowCount = sheet.rowCount;
                    colCount = sheet.colCount;
                }
                if (rcnt < rowCount)
                    rcnt = rowCount;
                if (ccnt < colCount)
                    ccnt = colCount;
                i++;
            }
            return { rowCount: rcnt, colCount: ccnt };
        },

        _generateEJMenu: function (type, orientation, cssClass) {
            return {
                menuType: (type === "normal") ? ej.MenuType.NormalMenu : ej.MenuType.ContextMenu,
                orientation: (orientation === "vertical") ? ej.Orientation.Vertical : ej.orientation.Horizontal,
                cssClass: cssClass
            };
        },

        _generateEJDD: function (datasource, fields, selectedIndex, width, height, evt) {
            return {
                dataSource: datasource,
                fields: fields,
                selectedItemIndex: selectedIndex,
                width: width,
                cssClass: "e-" + this._id + "-ddl",
                change: $.proxy(this.XLRibbon._frTypeChange, this, evt)
            };
        },

        _heightWidthCalculation: function (sheetIdx, args) {
            var height, actpanel = this.getActivationPanel(), isVisible = actpanel.is(':visible');
            if (!this._isDisplayHeader)
                height = (this.XLRibbon._ribbonState) ? this.element.find('.e-ribbon').height() - 1 : this.element.find('.e-ribbon .e-header').height();
            else {
                height = $("#" + this._id + "_Ribbon").height();
                this._isDisplayHeader = false;
            }
            this._refreshSheetWithScreen(sheetIdx);
            this._updateResponsiveSettings();
            this._initViewPort(sheetIdx);
            this._setSheetWidthHeight(sheetIdx, { width: this._responsiveWidth, height: this._responsiveHeight }, height, "refresh", args.action);
            isVisible && actpanel.height(this.getMainPanel().height() - 1);
            this.refreshContent(sheetIdx);
        },

        _refreshSheetWithScreen: function (sheetIdx) {
            $("#" + this._id + "GroupPanel")[0].style.height = "0px";
            $("#" + this._id + "MainPanel")[0].style.height = "0px";
            this.model.allowFormulaBar && (this.element.find('.e-formulabar')[0].style.width = "0px");
            this.getSheetElement(sheetIdx).find(".e-spreadsheetcontentcontainer")[0].style.height = "0px";
            this.getSheetElement(sheetIdx).find(".e-spreadsheetrowheader")[0].style.height = "0px";
        },

        _refreshWidthHeight: function (sheetIdx, settings, ribbonHeight, action, status) {
            var footer, colHdrHeight = 1, rowHdrHeight = 0, cont = this._getContent(sheetIdx), contentHt, formulaHeight, pagerHt = this.model.pageSettings.pagerHeight + 1, actTab,
                sheet = this.getSheet(sheetIdx), sheetRowHdr = this._getJSSheetRowHeader(sheetIdx), ribHgt, diffHt, ribContHeight = -1, ribObj = $("#" + this._id + "_Ribbon").ejRibbon("instance");
			actTab = this.model.showRibbon ? (ribObj.model.selectedItemIndex < 1 ? 1 : ribObj.model.selectedItemIndex)  : 0;
            this.XLRibbon._ribbonState && (ribContHeight = $("#" + this._id + "_Ribbon").find(".e-content:eq(" + actTab + ")").height());
            ribHgt = this._phoneMode ? $("#" + this._id + "_Ribbon").height() : $("#" + this._id + "_Ribbon").find(".e-header").height() + ribContHeight + 2;
            formulaHeight = (this.model.allowFormulaBar && this.element.find("#" + this._id + "_formulabar").is(":visible")) ? this._formulaHeight : 0;
            ribbonHeight = (ribHgt && this.model.showRibbon && $("#" + this._id + "_Ribbon").is(":visible")) ? ribHgt : 0;
            if (sheet.showHeadings) {
                colHdrHeight = 20 + 2; // column header 20 + 2 //Border
                rowHdrHeight = sheetRowHdr.width();
            }
            if (!this._isAutoWHMode) {
                contentHt = settings.height - (ribbonHeight + formulaHeight + 1);
                this.getGroupPanel().height(contentHt - 1); // for Border
                this.getMainPanel().height(contentHt - 1); // for Border
                (!this.model.showPager || (action !== "initial" && !this.element.find(".e-spreadsheetfooter").is(":visible"))) && (pagerHt = 1);
                diffHt = (this._browserDetails.name === "chrome") ? 1 : 2;
                settings.height = settings.height - (colHdrHeight + pagerHt + formulaHeight + ribbonHeight + diffHt);
                this.element.find(".e-spreadsheet-list")[0].style.height = "";
            }
            if (this.model._isActPanelVisible)
                settings.width = (settings.width - (this.model.activationPanelWidth + 2)); //0.5 for border alignment
            else 
                (!ej.isNullOrUndefined(settings.isActPanel) && !settings.isActPanel) && (settings.width = settings.width + this.model.activationPanelWidth + 2);
            var orgSettings = this.model.scrollSettings;
            this.getMainPanel().width(!this.model._isActPanelVisible && orgSettings.isResponsive ? "100%" : settings.width);
            if (cont.find("#hscrollBar").length > 0) {
                cont.find("#hscrollBar").remove();
                sheetRowHdr.removeClass("e-scrollrowcss");
                this._getJSSheetRowHeaderContent(sheetIdx).height(settings.height);
                this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content").height(settings.height - 1);
            }
            if (cont.find("#vscrollBar").length > 0) {
                var top = sheet._scrollTop;
                cont.find("#vscrollBar").data("ejScrollBar").scroll(0);
                sheet._scrollTop = top;
                cont.find("#vscrollBar").remove();
                this._getJSSheetHeader(sheetIdx).removeClass("e-scrollcss");
                this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content").width(orgSettings.isResponsive ? settings.width - 2 : settings.width);
            }
            if (!this._isAutoWHMode) {
                cont.height(settings.height);
                sheetRowHdr.height(settings.height);
            }
            this._getJSSheetContent(sheetIdx).width(orgSettings.isResponsive ? "100%" : settings.width);
            footer = this.getFooter();
            if (footer)
                footer.width(orgSettings.isResponsive ? "100%" : settings.width);
            this._alignFormulaBar(this._responsiveWidth);
            this._initViewPort(sheetIdx);
            this.model.allowFreezing && this.XLFreeze._refreshFreeze();
            settings.width = settings.width - rowHdrHeight; // is for row Header  
            settings.height = settings.height;
            return settings;
        },

        _setSheetWidthHeight: function (sheetIdx, settings, ribbonHeight, status, action) {
            var sheet = this.getSheet(sheetIdx), content = $(document), cont = this._getContent(sheetIdx), hScroll, vScroll, hScrollObj, vScrollObj, contentHt, sheetRowHdr = this._getJSSheetRowHeader(sheetIdx);
            var currSettings, isResponsive = this.model.scrollSettings.isResponsive, rowHdrWidth = sheet.showHeadings ? sheetRowHdr.width() : 0;
            if (isResponsive) {
                if (action != "initial" && status != "resize") {
                    this._refreshSheetWithScreen(sheetIdx);
                    this._updateResponsiveSettings();
                    settings = { width: this._responsiveWidth, height: this._responsiveHeight };
                }
                this._resizeColl[sheetIdx - 1] = this._isResized;
                if (status === "resize" && (!this.model.allowResizing || (this.model.allowResizing && !this.XLResize._resizeStart)) && (action != "toggleBtn"))
                    this.model.activationPanelWidth = Math.floor(settings.width / 3);
                if (status === "refresh") {
                    var browser = this._browserDetails;
                    if (browser.name.indexOf("msie") > -1)
                        content = (this.model.showRibbon) ? $(document) : $('body');
                }
                currSettings = this._refreshWidthHeight(sheetIdx, $.extend(true, {}, settings), ribbonHeight, action, status);
                this._updateResponsiveSettings();
                if (status === "resize" && (!this.model.allowResizing || (this.model.allowResizing && !this.XLResize._resizeStart)) && (action != "toggleBtn"))
                    this.model.activationPanelWidth = Math.floor(settings.width / 3);
                settings = currSettings;
            }
            else {
                if (!this._isAutoWHMode)
                    settings.width = settings.width - 2; // border 2px
                settings = this._refreshWidthHeight(sheetIdx, $.extend(true, {}, settings), ribbonHeight, action, status);
            }
            this.getMainPanel().width(!this.model._isActPanelVisible && isResponsive ? "100%" : settings.width + rowHdrWidth);
            if (this.model.scrollSettings.allowScrolling) {
                if (this.model._isActPanelVisible)
                    settings.width += 2;
                this._renderScroller(sheetIdx, $.extend(true, {}, settings), action);
                vScroll = cont.find("#vscrollBar");
                hScroll = cont.find("#hscrollBar");
                if (vScroll.length > 0)
                    this._getJSSheetHeader(sheetIdx).addClass("e-scrollcss");
                if (hScroll.length > 0) {
                    contentHt = cont.height();
                    sheetRowHdr.height(contentHt - 18);
                    this._getJSSheetRowHeaderContent(sheetIdx).height(contentHt - (hScroll[0].style.display === "none" ? 0 : 18));
                    sheetRowHdr.addClass("e-scrollrowcss");
                }
                if (action != "initial") {
                    vScrollObj = vScroll.data("ejScrollBar");
                    hScrollObj = hScroll.data("ejScrollBar");
                    vScrollObj.scroll(sheet._scrollTop);
                    hScrollObj.scroll(sheet._scrollLeft);
                }
            }
            if (!sheet.showHeadings)
                cont.find(".e-content")[!this.model.allowFormulaBar ? "removeClass" : "addClass"]("e-viewbrdr");
            if (!this._isAutoWHMode) {
                this._dlgWidth = (this._phoneMode || this._tabMode || this._responsiveWidth < 350) ? this._responsiveWidth - 2 : this._responsiveWidth / 2;
                this._dlgHeight = (this._phoneMode || this._tabMode || this._responsiveHeight < 350) ? this._responsiveHeight - 2 : this._responsiveHeight / 1.5;
            }
        },

        setWidthToColumns: function (widthColl, sheetIndex) {
            var cellIdx, sheetIdx = sheetIndex || this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), col, hdrcol, staticWidth = 0, width, colIdx, isObj = false, overflowCells;
            if (this.isUndefined(sheet)) return;
            if (typeof (widthColl[0]) == "object")
                isObj = true;
            if (sheet._isLoaded) {
                col = this._getContent(sheetIdx).find("col");
                hdrcol = this._getJSSheetHeader(sheetIdx).find("col");
            }
            for (var i = 0, len = widthColl.length; i < len; i++) {
                width = isObj ? widthColl[i].width : widthColl[i];
                colIdx = isObj ? widthColl[i].colIndex : i;
                overflowCells = this.XLEdit._getPropWithCellIdx([0, colIdx, sheet.rowCount - 1, colIdx], "isOfBrdr", sheetIdx);
                (width === 0) && (width = 64);
                if (width < sheet.columnsWidthCollection[colIdx] && this.XLEdit.getPropertyValue(0, colIdx, "wrapCol")) {
                    staticWidth += width;
                    continue;
                }
                if (sheet._isLoaded) {
                    hdrcol[colIdx].style["width"] = width + "px";
                    col[colIdx].style["width"] = width + "px";
                }
                staticWidth += width;
				this.XLShape && this.XLShape._refreshShapePosOnResize(colIdx, width, true, sheetIdx);
                if (this.XLEdit.getPropertyValue(0, colIdx, "isCHide", sheetIdx)) {
                    sheet.hideColsCollection[colIdx] = width;
                    sheet.columnsWidthCollection[colIdx] = 0;
                }
                else
                    sheet.columnsWidthCollection[colIdx] = width;
                this.XLScroll._getColWidths(sheetIdx, colIdx);
                for (var j = 0; j < overflowCells.length; j++) {
                    cellIdx = overflowCells[j];
                    this._textClip(cellIdx.rowIdx, cellIdx.colIdx, 'delete', '', true);
                    this._textClip(cellIdx.rowIdx, cellIdx.colIdx, 'add', '', true);
                }
            }
            sheet.staticWidth = staticWidth;
            if (sheet._isLoaded && this.model.scrollSettings.allowScrolling)
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "horizontal");
            if (sheet._isFreezed) {
                this.XLFreeze._refreshFreezeRowDiv();
                this.XLFreeze._refreshFreezeColDiv();
            }
            if (!sheet._isImported || sheet._isLoaded) {
                if (this.model.allowSelection)
                    this.XLSelection._refreshBorder();
                if (this.model.allowAutoFill)
                    this.XLDragFill.positionAutoFillElement();
                if (this.model.allowComments)
                    this.XLComment._updateCmntArrowPos();
                if (this._isAutoWHMode)
                    this._autoSSWidthHeight();
            }
        },

        setHeightToRows: function (heightColl) {
            var vPrtRIdx, height, rowIdx, hgt = "height", px = "px", sheetIdx = this.getActiveSheetIndex(), staticHeight = 0, sheet = this.getSheet(sheetIdx), isObj = false, rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowHdrs = rowColl[0];
            if (typeof (heightColl[0]) == "object")
                isObj = true;
            for (var i = 0, len = heightColl.length; i < len; i++) {
                height = isObj ? heightColl[i].height : heightColl[i];
                rowIdx = isObj ? heightColl[i].rowIndex : i;
                (height === 0) && (height = 22);
                if (height < sheet.rowsHeightCollection[rowIdx] && this.XLEdit.getPropertyValue(rowIdx, 0, "wrapRow")) {
                    staticHeight += height;
                    continue;
                }
                if (this._isRowViewable(sheetIdx, rowIdx) && rowIdx != -1) {
                    vPrtRIdx = this._getRowIdx(rowIdx, sheetIdx);
                    rows[vPrtRIdx].style["height"] = height + "px";
                    rowHdrs[vPrtRIdx].style["height"] = height + "px";
                }
				this.XLShape && this.XLShape._refreshShapePosOnResize(rowIdx, height, false, sheetIdx);
                staticHeight += height;
                sheet.rowsHeightCollection[rowIdx] = height;
            }
            if (this.model.scrollSettings.allowScrolling && !this._isScrolling) {
                this.XLScroll._getRowHeights(sheetIdx, 1);
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "vertical");
				this.XLScroll._getFirstRow(sheetIdx);
            }
            if (this.model.allowSelection)
                if (!sheet._isImported || sheet._isLoaded) {
                    this.XLSelection._refreshBorder();
                    if (this.model.allowAutoFill)
                        this.XLDragFill.positionAutoFillElement();
                }
        },

        _refreshRowColCnt: function (sheetIdx, status) {
            var totHgt, totWth, diff, srowCnt, pagerHt = -1, rowCnt, buffHgt, buffWth, actPnlWidth, ribbonHgt, formulaHgt, settings = this.model.scrollSettings,
                vPortWth, scrollerHgt, scrollerWth, colHdrHgt, rowHdrWth, isInfinite = settings.scrollMode === ej.Spreadsheet.scrollMode.Infinite,
                sheet = this.getSheet(sheetIdx), contHgt = this._responsiveHeight, contWth = this._responsiveWidth;
            rowCnt = buffHgt = buffWth = actPnlWidth = ribbonHgt = formulaHgt = vPortWth = scrollerHgt = scrollerWth = colHdrHgt = rowHdrWth = 0;
            if (sheet.rowCount > this._maxRowCnt)
                sheet.rowCount = this._maxRowCnt;
            totHgt = this._getMaxHgt(sheetIdx, this.isImport);
            if (isInfinite) {
                buffHgt = sheet._vPortHgt + (this._bufferCnt * sheet.rowHeight);
                if (totHgt < buffHgt) {
                    diff = buffHgt - totHgt;
                    rowCnt = Math.ceil(diff / sheet.rowHeight);
                    sheet.rowCount += rowCnt;
                    totHgt += rowCnt * sheet.rowHeight;
                }
            }
            if (settings.allowVirtualScrolling) {
                srowCnt = sheet.rowCount - (sheet.hideRowsCollection.length + (this.isImport ? sheet._hiddenFreezeRows.length : 0));
                if (isInfinite) {
                    diff = srowCnt % sheet._virtualBlockRowCnt;
                    if (diff) {
                        rowCnt = sheet._virtualBlockRowCnt - diff;
                        sheet.rowCount += rowCnt;
                        srowCnt += rowCnt;
                        totHgt += rowCnt * sheet.rowHeight;
                    }
                }
                sheet._virtualBlockCnt = Math.ceil(srowCnt / sheet._virtualBlockRowCnt);
                sheet._virtualTBodyHgt = totHgt;
            }
            if (sheet.colCount > this._maxColCnt) //col
                sheet.colCount = this._maxColCnt;
            else if (isInfinite) {
                buffWth = sheet._vPortWth + (this._bufferCnt * sheet.columnWidth);
                totWth = this.isImport ? this._getMaxWth(sheetIdx) : sheet.colCount * sheet.columnWidth;
                if (totWth < buffWth) {
                    diff = buffWth - totWth;
                    sheet.colCount += Math.ceil(diff / sheet.columnWidth);
                }
            }
        },

        _getMaxHgt: function (sheetIdx, fromHgtColl, processHide) {
            var len, i, val, sheet = this.getSheet(sheetIdx);
            i = val = 0;
            if (fromHgtColl) {
                len = sheet.rowsHeightCollection.length;
                while (i < len) {
                    if (!processHide || (sheet.hideRowsCollection.indexOf(i) === -1))
                        val += sheet.rowsHeightCollection[i];
                    i++;
                }
            }
            else
                val = (sheet.rowCount - (sheet.hideRowsCollection.length + sheet._hiddenFreezeRows.length)) * sheet.rowHeight;
            return val;
        },

        _getMaxWth: function (sheetIdx) {
            var val = 0, i = 0, sheet = this.getSheet(sheetIdx), len = sheet.columnsWidthCollection.length;
            while (i < len) {
                val += sheet.columnsWidthCollection[i];
                i++;
            }
            return val;
        },

        _refreshTemplates: function (sheetIdx, skipRowHdr, stColIdx, colCount) {
            var colWth, col, data, colHdr, htmlStr, i = ej.isNullOrUndefined(stColIdx) ? 0 : stColIdx, templates = {}, sheet = this.getSheet(sheetIdx),
                colgrp = ej.buildTag("colgroup"), style="", isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, len = ej.isNullOrUndefined(colCount) ? sheet.colCount : colCount;
            htmlStr = isVirtualScroll ? "<tr style = 'height: {{:height}}px' data-idx = '{{:rowidx}}'>" : "<tr style = 'height: {{:height}}px'>";
            while (i < len) {
                colWth = sheet.columnsWidthCollection[i];
                colHdr = this._generateHeaderText(i + 1);
                col = document.createElement("col");
                if (colWth < 1)
                    col.setAttribute("class", "e-hide");
                else if (sheet._hiddenFreezeCols.indexOf(i) > -1)
                    col.setAttribute("class", "e-fcol-hide");
                col.style["width"] = colWth + "px";
                htmlStr += "<td class='{{:" + colHdr + "_className}}' rowspan= {{:" + colHdr + "_rspan}} colspan= {{:" + colHdr + "_cspan}} style={{:" + colHdr + "_Colors}} >{{:" + colHdr + "_value}}</td>";
                colgrp.append(col);
                i++;
            }
            templates[this._id + "JSONTemplate" + sheetIdx] = htmlStr + "</tr>";
            if (!skipRowHdr)
                templates[this._id + "JSONRowHdrTemplate" + sheetIdx] = isVirtualScroll ? "<tr class='{{:wrap}}' style='height:{{:height}}px' data-idx='{{:rowidx}}'><td class='{{:className}}'>{{:rowidx + 1}}</td></tr>" : "<tr class='{{:wrap}}' style='height:{{:height}}px'><td class='{{:className}}'>{{:rowidx + 1}}</td></tr>";
            $.templates(templates);
            this._sheets[sheetIdx]._contentColGroup = colgrp.get(0);
        },

        _renderData: function (rangeData, sheetIdx, stColIdx, colCount, isPrint, stRowIdx, rowCount) {
            var j, cls, val, obj, prop, text, data, rSpan, cSpan, mSpan, rowCnt, rowIdx, colIdx, colHdr, fltrStr, rowHgt, cFormat,
                isSelect, isVisible, sheetData, isVisCmnt, i, eCol, spc = " ", viewData = [], sheet = this.getSheet(sheetIdx),
                colCnt = isPrint ? colCount : sheet.colCount, goTo = sheet._goToCollection, goToLen = goTo.selected.length, rng, rowSpan, CFColors = "e-redft e-yellowft e-greenft e-redf e-redt", container = this._dataContainer.sheets[sheetIdx];
            eCol = 0;
            i = stRowIdx ? stRowIdx : 0;
            if (rangeData) {
                data = rangeData.data;
                rowCnt = data.length / colCnt;
                while (i < rowCnt) {
                    obj = {}, j = eCol;
                    rowIdx = rangeData.rowIdx[i];
                    colIdx = isPrint ? stColIdx : 0;
                    while (j < (eCol + colCnt)) {
                        prop = data[j];
                        if (prop) {
                            colHdr = this._generateHeaderText(colIdx + 1);
                            cls = colHdr + "_className";
                            val = colHdr + "_value";
                            obj[cls] = "e-rowcell e-wrapword ";
                            if (!sheet.showGridlines)
                                obj[cls] += " e-hborder";
                            if (!isPrint && !goTo.multiple && goToLen && goTo.selected.indexOf(rowIdx + ":" + colIdx) > -1)
                                obj[cls] += " e-selected";
                            if (colIdx in sheet.hideColsCollection)
                                obj[cls] += " e-soverflow";
                            if (sheet._hiddenFreezeCols.indexOf(colIdx) > -1)
                                obj[cls] += " e-fcol-hide";
                            if (!isPrint && this.model.allowSelection && this.inRange(sheet.selectedRange, rowIdx, colIdx)) {
                                isSelect = true;
                                if (goTo.multiple) {
                                    isSelect = false;
                                    if (goToLen && goTo.selected.indexOf(rowIdx + ":" + colIdx) > -1)
                                        isSelect = true;
                                }
                                if (isSelect)
                                    obj[cls] += " e-selected";
                                if (sheet._activeCell.rowIndex === rowIdx && sheet._activeCell.colIndex === colIdx)
                                    obj[cls] += " e-activecell";
                            }
                            if (this.isImport && this.model.allowCellType && this.model.allowAutoCellType) {
                                if (prop.type == "shortdate" || prop.type == "longdate")
                                    this._celltypes.push({ rowIndex: rowIdx, colIndex: colIdx, sheetIndex: sheetIdx, cellType: { 'type': 'DatePicker' }, value: prop.value2 });
                                if (prop.value2 && ['true', 'yes', 'false', 'no'].indexOf(prop.value2.toLowerCase()) > -1)
                                    this._celltypes.push({ rowIndex: rowIdx, colIndex: colIdx, sheetIndex: sheetIdx, cellType: { 'type': 'CheckBox', 'isChecked': ['yes', 'true'].indexOf(prop.value2.toLowerCase()) > -1 ? true : false } });
                            }
                            if (this.isImport && prop.type == "date")
                                this.XLFormat.addCustomFormatSpecifier(null,  prop.formatStr && prop.formatStr.replace(/^\{0\:|\}$/g, ""), prop.type);
                            if ((prop.type == "shortdate" || prop.type == "longdate" || prop.type == "date" || prop.type == "time") && !this._isDateTime(prop.value) && Date.parse(prop.value))
                                prop.value = new Date(prop.value);
                            // format
                            if (prop.format) {
                                obj[cls] += spc + prop.format;
                                if (this._isClassHasProperty(prop.format, 'text-align', 'right'))
                                    obj[cls] += " e-rightalign";
                            }
                            if (prop.border)
                                obj[cls] += spc + prop.border;
                            if (prop.align) {
                                if (prop.align === ej.Spreadsheet.Align.Center)
                                    obj[cls] += spc + this._cAlign;
                                else if (prop.align === ej.Spreadsheet.Align.Right && ((typeof prop.value === "object" && this._isDateTime(prop.value)) || this.isNumber(this.isFormula(prop.value) ? (container[rowIdx][colIdx]["calcValue"] ? container[rowIdx][colIdx]["calcValue"] : prop.value2) : prop.value)))
                                    obj[cls] += spc + this._rAlign;
                            }
                            else if (this._isGeneral(prop.type) && ((typeof prop.value === "object" && this._isDateTime(prop.value)) || this.isNumber(prop.value)))
                                obj[cls] += spc + this._rAlign;
                            // merge
                            if (prop.isMHide) {
                                obj[cls] += " e-mc-hide";
                                obj[cls] += " e-moverflow";
                            }
                            if (prop.isOfBrdr)
                                obj[cls] += " e-ofbrdr";
                            if (prop.isOverflow === false)
                                obj[cls] += " e-overflow";
                            rSpan = colHdr + "_rspan";
                            cSpan = colHdr + "_cspan";
                            if (prop.merge) {                               
                                mSpan = prop.merge.mSpan;
                                obj[rSpan] = mSpan.rowSpan;
                                obj[cSpan] = mSpan.colSpan;
                                obj[cls] += " e-moverflow";
                                if (prop.merge.isCenterAlign)
                                    obj[cls] += spc + this._cAlign;
                            }
                            else {
                                obj[rSpan] = 1;
                                obj[cSpan] = 1;
                            }
                            // conditional format
                            if (prop.cFormatRule) {
                                for (var k = 0, len = prop.cFormatRule.length; k < len; k++) {
                                    cFormat = prop.cFormatRule[k].split("_");
                                    if (cFormat[8] === "true") {
                                        if (cFormat[4].length > 0 && CFColors.indexOf(cFormat[4]) > -1)
                                            obj[cls] += " e-" + cFormat[4];
                                        else {
                                            obj[colHdr + "_Colors"] = this.isUndefined(obj[colHdr + "_Colors"]) ? "" : obj[colHdr + "_Colors"];
                                            if (CFColors.indexOf(cFormat[4]) < 0)
                                                obj[colHdr + "_Colors"] += "color:" + cFormat[4] + ";";
                                            if (CFColors.indexOf(cFormat[5]) < 0)
                                                obj[colHdr + "_Colors"] += "background-color:" + cFormat[5] + ";";
                                        }
                                    }
                                }
                            }
                            text = ej.isNullOrUndefined(prop.value2) ? "" : prop.value2;
							if (this.isUndefined(prop["wrap"]) && text.toString().match(/\n/g))
								prop["wrap"] = true;
                            //wrap
                            if (prop.wrap && ((sheet._isImported && !this.isFormula(prop.value)) || !sheet._isImported)) {
                                obj[cls] += " e-sswraptext";
                                sheetData = this._dataContainer.sheets[sheetIdx];
                                (this.isUndefined(sheetData[rowIdx])) && (sheetData[rowIdx] = {});
                                (this.isUndefined(sheetData[rowIdx][0])) && (sheetData[rowIdx][0] = {});
                                if (!sheetData[rowIdx][colIdx]["wrap"])
                                    sheetData[rowIdx][colIdx]["wrap"] = true;
                                sheetData[rowIdx][0].wrapRow = true;
                                (this.isUndefined(sheetData[0])) && (sheetData[0] = {});
                                if (this.isUndefined(sheetData[0][colIdx]))
                                    sheetData[0][colIdx] = { wrapCol: true, wrapWidth: sheet.columnsWidthCollection[colIdx] };
                                else {
                                    sheetData[0][colIdx]["wrapCol"] = true;
                                    sheetData[0][colIdx]["wrapWidth"] = sheet.columnsWidthCollection[colIdx];
                                }
                               if (!sheet._wrapColl[rowIdx] || (sheet._wrapColl[rowIdx] && !sheet._wrapColl[rowIdx][colIdx])) {
									this._wrapTextLenCln([{rowIndex:rowIdx, colIndex:colIdx}], sheet, "renderdata", sheetIdx);
                                    this._wrapCollection(rowIdx, colIdx, this._getWrapCellHeight(sheetIdx, rowIdx, colIdx).rowHt, sheetIdx);
								}
                            }
                            // data & hyperlink
                            if (prop.hyperlink) {
                                if (!isPrint) {
                                    if (prop.hyperlink.webAddr)
                                        obj[val] = String.format("<a href=\{0}\ class='e-hyperlinks' target='_blank'>\{1}\</a>", prop.hyperlink.webAddr, text);
                                    else
                                        obj[val] = String.format("<a class='e-hyperlinks'>\{0}\</a>",text);
                                }
                                else {
                                    obj[cls] += " e-hyperlinks";
                                    obj[val] = text;
                                }
                            }
                            else if(prop.merge) {
								rowSpan = 0;
								rng = this.getRangeIndices(prop.merge.mRange);
								for(var k = rng[0]; k <= rng[2]; k++) {
									if(rangeData.rowIdx.indexOf(k) < 0)
										rowSpan++;
								}							
								obj[val] = "<div id =" + this._id + "_Merge style = 'border :0px;overflow: hidden;max-height:" + (Math.floor(sheet._rowHeightCollection[rowIdx + (prop.merge.mSpan.rowSpan - rowSpan)] - sheet._rowHeightCollection[rowIdx]) - 1) + "px'>" + text + "</div>"; //-1 to set the height less than cell height to avoid misalignment
							}
                            else
                                obj[val] = text;
                            // comment
                            if (prop.comment) {
                                obj[cls] += " e-commentcell";
                                isVisCmnt = prop.comment.isVisible ? "visible" : "none";
                                obj[val] = String.format("<span class='e-comment'><span class='e-celltoparrow'></span><textarea class='e-comment-txtarea' style='display:\{0}\;z-index:9;text-align:left'>\{1}\</textarea></span>", isVisCmnt, prop.comment.value) + obj[val];
                            }
                            // validation
                            if (prop.rule && prop.rule.isApply && !(this.XLValidate._checkValidation(obj[val], prop.rule.customVal.split("_"), true, sheetIdx)))
                                obj[cls] += " e-hlcell";
                            // filter
                            if (prop.isFilterHeader && !this.isUndefined(sheet._filterColl[rowIdx]) && !this.isUndefined(sheet._filterColl[rowIdx][colIdx])) {
                                fltrStr = 'e-icon e-spanfilter e-filterspan ' + sheet._filterColl[rowIdx][colIdx].status;
                                isVisible = prop.isFilterVisible ? 'display: visible' : 'display: none';
                                obj[val] = String.format("<span class=\"{0}\" style=\"{1}\"></span>", fltrStr, isVisible) + obj[val];
                                obj[cls] = obj[cls].replace("e-ralign", "");
                                spc = spc.replace("e-ralign", "");
                            }
                            //Alt Text - unwrap state
                            if (prop.altTxt && !prop.wrap)
                                obj[cls] += " e-alt-unwrap";
                        }
                        colIdx++;
                        j++;
                    }
                    obj["rowidx"] = rowIdx;
                    rowHgt = sheet.rowsHeightCollection[rowIdx];
                    obj["height"] = (this.isUndefined(rowHgt) || rowHgt < this.model.rowHeight) ? this.model.rowHeight : rowHgt;
                    viewData.push(obj);
                    eCol = j;
                    i++;
                }
            }
            else {
                rowCnt = this.model.scrollSettings.allowVirtualScrolling ? sheet._virtualBlockRowCnt : rowCount ? rowCount : sheet.rowCount;
                rowCnt = i + rowCnt;
                while (i < rowCnt) {
                    obj = {}, j = 0;
                    while (j < colCnt) {
                        colHdr = this._generateHeaderText(j + 1);
                        cls = colHdr + "_className";
                        obj[cls] = "e-rowcell e-wrapword ";
                        j++;
                    }
                    rowHgt = sheet.rowsHeightCollection[i];
                    obj["height"] = (this.isUndefined(rowHgt) || rowHgt < this.model.rowHeight) ? this.model.rowHeight : rowHgt;
                    obj["rowidx"] = rowIdx;
                    viewData.push(obj);
                    i++;
                }
            }
            return $.render[this._id + "JSONTemplate" + sheetIdx](viewData);
        },

        _isGeneral: function (type) {
            if (this.isUndefined(type))
                type = ej.Spreadsheet.CellType.General;
            return type === ej.Spreadsheet.CellType.General;
        },

        _isFormulaError: function (error) {
            var i, len, formulaErr = ["#NA", "#DIV/0!", "#NAME?", "circular reference", "TypeError", "wrong"];
            for (i = 0, len = formulaErr.length; i < len; i++) {
                if (typeof error == "string" && error.indexOf(formulaErr[i]) > -1)
                    return true;
            }
            return false;
        },

        _refreshViewport: function (top, sheetIdx) {
            var rangeData, rowCnt, rowIdxs, currIdx, nstartIdx, currRIdx, cendRIdx, nstartIdx, nstartRIdx, nendRIdx, pstartIdx, pstartRIdx, sheet = this.getSheet(sheetIdx), idx = this.XLShape._getCellIndexFromOffset(top, 0),
                props = ["value", "value2", "comment", "hyperlink", "rule", "cFormatRule", "format", "border", "type", "isFilterHide", "isRHide", "isFHide",
                        "isFilterHeader", "isFilterVisible", "filterState", "isMHide", "merge", "hRow", "isLocked", "wrap", "isOverflow", "align", "isOfBrdr", "altTxt", "formatStr", "cellType"];
            sheet._virtualContBlockIdx = this._getVirtualBlockIdx(sheetIdx, idx.rowIndex).idx;
            currIdx = (sheet._virtualContBlockIdx - 1) * sheet._virtualBlockRowCnt;
            currRIdx = this._getRowIdx(currIdx, sheetIdx, true);
            nstartIdx = sheet._virtualContBlockIdx * sheet._virtualBlockRowCnt;
            nstartRIdx = this._getRowIdx(nstartIdx, sheetIdx, true);
            sheet._virtualContTBodyOffset.top = this._getRowOffsetTop(sheet, currRIdx);
            if (sheet._virtualBlockCnt === 1) {
                sheet._virtualTopTBodyOffset.top = sheet._virtualTopTBodyOffset.bottom = sheet._virtualTopTBodyHgt = 0;
                sheet._virtualBottomTBodyOffset.top = sheet._virtualBottomTBodyOffset.bottom = sheet._virtualBottomTBodyHgt = 0;
                sheet._virtualContTBodyOffset.bottom = this._getRowOffsetBottom(sheet._rowIdxColl[sheet._rowIdxColl.length - 1], sheetIdx);
                rowIdxs = sheet._rowIdxColl;
                sheet._isVirtualTopReached = sheet._isVirtualEndReached = true;
            }
            else if (sheet._virtualContBlockIdx === 1) {
                sheet._virtualTopTBodyOffset.top = sheet._virtualTopTBodyOffset.bottom = sheet._virtualTopTBodyHgt = 0;
                sheet._virtualContTBodyOffset.bottom = sheet._virtualBottomTBodyOffset.top = this._getRowOffsetTop(sheet, nstartRIdx);
                nendRIdx = this._getRowIdx(nstartIdx + (sheet._virtualBlockRowCnt - 1), sheetIdx, true);
                sheet._virtualBottomTBodyOffset.bottom = this._getRowOffsetBottom(nendRIdx, sheetIdx);
                sheet._virtualBottomTBodyHgt = sheet._virtualTBodyHgt - ((sheet._virtualContTBodyOffset.bottom - sheet._virtualContTBodyOffset.top) + (sheet._virtualBottomTBodyOffset.bottom - sheet._virtualBottomTBodyOffset.top));
                rowIdxs = sheet._rowIdxColl.slice(0, sheet._rowIdxColl.indexOf(nendRIdx) + 1);
                sheet._isVirtualTopReached = true;
                sheet._isVirtualEndReached = false;
            }
            else if (sheet._virtualContBlockIdx === sheet._virtualBlockCnt) {
                pstartIdx = (sheet._virtualContBlockIdx - 2) * sheet._virtualBlockRowCnt;
                sheet._virtualBottomTBodyOffset.top = sheet._virtualBottomTBodyOffset.bottom = sheet._virtualBottomTBodyHgt = 0;
                cendRIdx = this._getRowIdx(currIdx + (sheet._virtualBlockRowCnt - 1), sheetIdx, true);
                sheet._virtualContTBodyOffset.bottom = this._getRowOffsetBottom(cendRIdx, sheetIdx);
                pstartRIdx = this._getRowIdx(pstartIdx, sheetIdx, true);
                sheet._virtualTopTBodyOffset.top = this._getRowOffsetTop(sheet, pstartRIdx);
                sheet._virtualTopTBodyOffset.bottom = sheet._virtualContTBodyOffset.top;
                sheet._virtualTopTBodyHgt = sheet._virtualTBodyHgt - ((sheet._virtualContTBodyOffset.bottom - sheet._virtualContTBodyOffset.top) + (sheet._virtualTopTBodyOffset.bottom - sheet._virtualTopTBodyOffset.top));
                rowIdxs = sheet._rowIdxColl.slice(sheet._rowIdxColl.indexOf(pstartRIdx), sheet._rowIdxColl.indexOf(cendRIdx) + 1);
                sheet._isVirtualEndReached = true;
                sheet._isVirtualTopReached = false;
            }
            else {
                pstartIdx = currIdx - sheet._virtualBlockRowCnt;
                pstartRIdx = this._getRowIdx(pstartIdx, sheetIdx, true);
                sheet._virtualTopTBodyOffset.top = this._getRowOffsetTop(sheet, pstartRIdx);
                sheet._virtualTopTBodyOffset.bottom = sheet._virtualContTBodyOffset.top;
                sheet._virtualContTBodyOffset.bottom = sheet._virtualBottomTBodyOffset.top = this._getRowOffsetTop(sheet, nstartRIdx);
                nendRIdx = this._getRowIdx(nstartIdx + (sheet._virtualBlockRowCnt - 1), sheetIdx, true);
                sheet._virtualBottomTBodyOffset.bottom = this._getRowOffsetBottom(nendRIdx, sheetIdx);
                sheet._virtualTopTBodyHgt = top - ((sheet._virtualTopTBodyOffset.bottom - sheet._virtualTopTBodyOffset.top) + (top - sheet._virtualContTBodyOffset.top));
                sheet._virtualBottomTBodyHgt = sheet._virtualTBodyHgt - sheet._virtualBottomTBodyOffset.bottom;
                rowIdxs = sheet._rowIdxColl.slice(sheet._rowIdxColl.indexOf(pstartRIdx), sheet._rowIdxColl.indexOf(nendRIdx) + 1);
                sheet._isVirtualTopReached = sheet._isVirtualEndReached = false;
            }
            rangeData = this.getRangeData({ property: props, sheetIdx: sheetIdx, rowIdxs: rowIdxs, withRowIdx: true });
            this._getRowHdrTBody(sheetIdx).html(this._renderRowHdr(rangeData.rowIdx, sheetIdx));
            this._getContTBody(sheetIdx).html(this._renderData(rangeData, sheetIdx));
            this._refreshRows(sheetIdx);
            this._refreshTBodiesHgt(sheetIdx);
            if (this.model.allowComments)
                this.XLComment._updateCmntArrowPos(null, sheetIdx);
            sheet._virtualRowIdx = rangeData.rowIdx;
            if (this.model.allowCellType)
                this.XLCellType._rangeCellTypes(sheet.cellTypes, sheetIdx);
			if (this.model.allowSparkline)
				this.XLSparkline._refreshContentWithSparkline(sheetIdx);
            this._refreshViewVar(top, sheet._isLoaded ? null : 0, sheetIdx);   
        },

        refreshOverflow: function (range, sheetIdx) {
            this._refreshOverflow(range, sheetIdx);
        },

        _refreshOverflow: function (range, sheetIdx) {
            sheetIdx = this._getSheetIndex(sheetIdx);
            var i, cell, rowIdx, colIdx, cells, sheet = this.getSheet(sheetIdx);
            range = range || [0, 0, sheet.usedRange.rowIndex, sheet.usedRange.colIndex];
            cells = this.XLEdit._getPropWithCellIdx(range, 'value2');
            for (i = cells.length - 1; i > -1; i--) {
                rowIdx = cells[i].rowIdx, colIdx = cells[i].colIdx;
                if (this.model.allowOverflow)
                    this._textClip(rowIdx, colIdx, 'add', '', true);
                else {
                    if (this._isRowViewable(sheetIdx, rowIdx))
                        cell = this.getCell(rowIdx, colIdx)[0];
                    this._removeClass(cell, 'e-overflow');
                    this._textClip(rowIdx, colIdx, 'delete', '', true);
                    this.addClass(cell, 'e-overflow');
                    this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: colIdx }, { dataObj: { isOverflow: false }, skipCell: true });
                }
            }
        },

        _getVirtualBlockIdx: function (sheetIdx, rowIdx, withAllIdx) {
            var vrowIdx, i = 1, obj = {}, sheet = this.getSheet(sheetIdx);
            vrowIdx = this._getRowIdx(rowIdx, sheetIdx, false, true);
            while (i <= sheet._virtualBlockCnt) {
                if (vrowIdx < (i * sheet._virtualBlockRowCnt)) {
                    obj.idx = i;
                    break;
                }
                i++;
            }
            if (withAllIdx) {
                i = 0;
                while (++i) {
                    if (rowIdx < (i * sheet._virtualBlockRowCnt)) {
                        obj.orgIdx = i;
                        break;
                    }
                }
            }
            return obj;
        },

        _getBlockInfo: function (rowIdx, sheetIdx, withAllIdx) {
            var blkIdx, sheet = this.getSheet(sheetIdx), range = [0, 0, 0, sheet.colCount - 1];
            blkIdx = this._getVirtualBlockIdx(sheetIdx, rowIdx, withAllIdx);
            range[0] = (sheet._virtualBlockRowCnt * (blkIdx.idx - 1));
            range[2] = (sheet._virtualBlockRowCnt * blkIdx.idx) - 1;
            blkIdx.range = range;
            if (withAllIdx) {
                range = [0, 0, 0, sheet.colCount - 1];
                range[0] = (sheet._virtualBlockRowCnt * (blkIdx.orgIdx - 1));
                range[2] = (sheet._virtualBlockRowCnt * blkIdx.orgIdx) - 1;
                blkIdx.orgRange = range;
            }
            return blkIdx;
        },

        _getRowOffsetTop: function (sheet, rowIdx) {
            return sheet._rowHeightCollection[rowIdx];
        },

        _getRowOffsetBottom: function (rowIdx, sheetIdx) {
            return this.getSheet(sheetIdx)._rowHeightCollection[rowIdx] + this.getSheet(sheetIdx).rowsHeightCollection[rowIdx];
        },

        _getColOffsetLeft: function (sheet, colIdx) {
            return sheet._colWidthCollection[colIdx];
        },

        _getCellIdx: function (cell) {
            return { rowIndex: this.model.scrollSettings.allowVirtualScrolling ? Number(cell.parentNode.attributes.getNamedItem("data-idx").value) : cell.parentNode.rowIndex, colIndex: cell.cellIndex };
        },

        _getMidCell: function () {
            var diff, obj = {}, sheet = this.getSheet();
            diff = (sheet._bottomRow.idx - sheet._topRow.idx) + 1;
            obj.rowIdx = sheet._topRow.idx + Math.floor(diff / 2);
            diff = (sheet._rightCol.idx - sheet._leftCol.idx) + 1;
            obj.colIdx = sheet._leftCol.idx + Math.floor(diff / 2);
            return obj;
        },

        _removeRange: function (idx, cnt) {
            var sheetIdx = this.getActiveSheetIndex(), rowHdrTBody = this._getRowHdrTBody(sheetIdx), rowHdrRows = $(this._getRowHdrTBody(sheetIdx)[0].rows),
                contTBody = this._getContTBody(sheetIdx), contRows = $(this._getContTBody(sheetIdx)[0].rows);
            rowHdrRows.splice(idx, cnt);
            contRows.splice(idx, cnt);
            this.setRows([rowHdrRows, contRows], sheetIdx);
            contTBody.html(contRows);
            rowHdrTBody.html(rowHdrRows);
			this._getContent(sheetIdx).find(".e-ss-sparkline").remove();
        },

        _refreshTBodiesHgt: function (sheetIdx) {
            var px = "px", sheetIdx = this._getSheetIndex(sheetIdx), sheet = this.getSheet(sheetIdx), hdrTBody = this._getJSSheetRowHeaderContent(sheetIdx)[0].getElementsByTagName("tbody"),
                contTBody = this._getContent(sheetIdx)[0].getElementsByTagName("tbody");
            hdrTBody[0].style.height = contTBody[0].style.height = (sheet._virtualTopTBodyHgt < this.model.rowHeight ? 0 : sheet._virtualTopTBodyHgt) + px;
            hdrTBody[2].style.height = contTBody[2].style.height = sheet._virtualBottomTBodyHgt + px;
        },

        _renderTD: function (className, styles, innerHtml) {
            return String.format("<td class='{0}' style='{1}' >{2}</td>", className, styles, innerHtml);
        },

        _renderDIV: function (className, innerHtml, title) {
            return title ? String.format("<div class='{0}' title='{2}'>{1}</div>", className, innerHtml, title) : String.format("<div class='{0}'>{1}</div>", className, innerHtml);
        },

        _renderTR: function (tdData, i, sheetIdx) {
            var trHeight = this._sheetCopy.isSheetCopy ? this.getSheet(sheetIdx).rowsHeightCollection[i] : this.model.rowHeight,
                height = "height:" + trHeight + "px";
            return String.format("<tr style='{0}'>" + tdData + "</tr>", height);
        },

        _renderFooter: function () {
            var scrollSettings = this.model.scrollSettings, pgrWidth, div = ej.buildTag('div.e-spreadsheetfooter', "", { "display": this.model.showPager ? "block" : "none" }), table = ej.buildTag("table.e-table", "", {}, {}),
                tbody = $(document.createElement("tbody")), tr = $(document.createElement("tr")), td = $(document.createElement("td")), settings = this.model.scrollSettings, pagerHt;
            this._updateResponsiveSettings();
            pgrWidth = scrollSettings.isResponsive ? "100%" : this._responsiveWidth - 2;
            td.append(this._renderSpreadSheetPager());
            td.find(".e-pagercontainer").append(ej.buildTag("div#" + this._id + "_AddSheet.e-new e-icon e-default", "", null, { title: this._getLocStr("NewSheet") }));
            tr.append(td);
            tbody.append(tr);
            table.append(tbody);
            div.append(table);
            this.getMainPanel().append(div);
            if (!(this.model.scrollSettings.isResponsive || this._isAutoWHMode))
                pgrWidth = pgrWidth;
            this._refreshSpreadSheetPager();
            pagerHt = this.element.find(".e-spreadsheetfooter").outerHeight();
            if (this.model.showPager && pagerHt > this.model.pageSettings.pagerHeight)
                this.model.pageSettings.pagerHeight = pagerHt < 37 ? pagerHt : 36; //pager max height
            div.width(pgrWidth).height(this.model.showPager ? this.model.pageSettings.pagerHeight : 0);
            this.element.find(".e-spreadsheetfooter .e-table").height(this.model.pageSettings.pagerHeight);
            this.setFooter(div);
        },

        //Pager
        gotoPage: function (sheetIdx, newSheet) {
            if ((!newSheet && sheetIdx > this.model.sheetCount) || sheetIdx < 1)
                return;
            var insertIndex, sheet, sheets = this.model.sheets, pagerObj = this.getPager(), settings = {}, impData = this._impData, scrollTop, scrollLeft,
                args = { reqType: "gotoSheet", gotoIndex: sheetIdx, newSheet: newSheet, prevSheetIdx: this.getActiveSheetIndex() }, cell, listProp, ribCollapsed = !this.XLRibbon._ribbonState,
                evtArgs = { reqType: args.reqType, gotoSheetIndex: args.gotoIndex, isNewSheet: args.newSheet, prevSheetIndex: args.prevSheetIdx }, pgrItemsCnt = pagerObj.ejPager("option", "totalRecordsCount"), sheetCount = this.model.sheetCount;
            if (newSheet)
                newSheet = (sheetIdx <= sheetCount) ? false : true;
            if (newSheet) {
                (sheetCount + 1 < sheetIdx) && (sheetIdx = sheetCount + 1);
                (pgrItemsCnt == sheetCount) && pagerObj.ejPager("option", { totalRecordsCount: pgrItemsCnt + 1 });
            }
            this._gotoPageArgs = $.extend(true, {}, args);
            this._isSheetNavigate = newSheet ? false : true;
            if (this._trigActionBegin(evtArgs))
                return;
            this.setActiveSheetIndex(sheetIdx);
			this.model.pageSettings.currentPage = sheetIdx;
            sheet = sheets[sheetIdx];
            if (!newSheet && !sheet._isRequested && sheet._isImported)
                this._importSheet(sheetIdx);
            else {
                this.element.find(".e-sheet").hide();
                if (newSheet) {
                    this._addSheet(sheetIdx);
                    sheet = sheets[sheetIdx];
                }
                if (this._isSheetInsert) {
                    insertIndex = pagerObj.ejPager("option", "currentPage");
                    this._swapSheetDtCntr(sheets.length - 1, insertIndex);
                    this.model.activeSheetIndex = sheetIdx = insertIndex;
                    this._isSheetInsert = false;
                }
                if (this._isNew || ((this.model.scrollSettings.allowVirtualScrolling || this.model.scrollSettings.allowSheetOnDemand) && !sheet._isLoaded)) {
                    this.showWaitingPopUp();
                    this._initSheet(sheetIdx);
                }
                else {
                    this.element.find("#" + this._id + "_" + sheet.sheetInfo.value).show();
                    !newSheet && this._initSelection();
                    if (this._isAutoWHMode) {
                        this._autoSSWidthHeight();
						!sheet._isOpened && this._refreshOverflow(undefined, sheetIdx);
					}
                    if (this._gotoPageArgs)
                        this._pageLoadComplete(sheetIdx);
                }
                if (sheet._isResized) {
                    this._refreshSheetWithScreen(sheetIdx);
                    this._updateResponsiveSettings();
                    settings.width = this._responsiveWidth;
                    settings.height = this._responsiveHeight;
                    this._setSheetWidthHeight(sheetIdx, settings, null, "refresh");
                    sheet._isResized = false;
                }
                if (!this.model.scrollSettings.allowVirtualScrolling && !sheet._isOpened)
                    this._updateHiddenRows(sheetIdx);
                if (this.model.allowFreezing)
                    this.XLFreeze._refreshFreeze();
                this._isSheetNavigate = false;
            }
            sheet._isOpened = true;
			if (!this.isImport)
                this.hideActivationPanel();
            if (impData && !this._isExport && !sheet._isImpSLoad && sheet._isImported) {
                scrollTop = impData.model.sheets[sheetIdx]._scrollTop, scrollLeft = impData.model.sheets[sheetIdx]._scrollLeft;
                (scrollTop > 0) && this.XLScroll._vScroller(sheetIdx).scroll(scrollTop);
                (scrollLeft > 0) && this.XLScroll._hScroller(sheetIdx).scroll(scrollLeft);
                sheet._isImpSLoad = true;
            }
            cell = this.getActiveCell(sheetIdx);
            listProp = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "rule", sheetIdx);
            if (listProp && listProp.type === "list")
                this._setddlCell();
            if (sheet._isRibCollapsed != ribCollapsed) {
                this._heightWidthCalculation(this.getActiveSheetIndex(), $.extend(true, {}, this.model.scrollSettings));
                sheet._isRibCollapsed = ribCollapsed;
            }
			if (this._isAutoWHMode) {
				var dimension = this._getElementDimension();
                this.element.css({ height: dimension.height, width: dimension.width });
			}
        },

        insertSheet: function () {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            var pager = this.getPager(), insertPage = pager.ejPager("option", "totalRecordsCount") + 1;
            pager.ejPager("option", { totalRecordsCount: insertPage });
            this._isSheetInsert = true;
            this.gotoPage(insertPage, true);
            this.setSheetFocus();
        },

        _renameSheet: function (sName) {
            var trgt = this.element.find(".e-currentitem"), input = ej.buildTag("input#" + this._id + "_Sheet_RenamePanel", "", { width: trgt.width() + 5 + "px", padding: 0 }, { type: "input", value: sName || trgt.text(), maxlength: "31" });
            trgt.hide();
            input.insertAfter(trgt).select().focus();
            this._isSheetRename = true;
            if (this.model.showRibbon)
                this.XLRibbon._disableRibbonIcons();
            if (this.model.enableContextMenu)
                $("#" + this._id + "_contextMenuFooter").data("ejMenu")._contextMenuEvents("_off"); //for enable default contextmenu - clipboard actions
        },

        deleteSheet: function (index, alertStatus) {
            if (!this.model.allowDelete || this.model.isReadOnly)
                return;
            var actShtIdx = this.getActiveSheetIndex(), sheetCount = this._getSheetNames(true).length;
            index = index || actShtIdx;
            if (sheetCount > 1) {
                if (index !== actShtIdx)
                    this.gotoPage(index, false);
                if (this.getObjectLength(this._dataContainer.sheets[index]) && alertStatus)
                    this._showAlertDlg("", "SheetDeleteAlert", "sheetDeleteActn", 470);
                else
                    this._removeSheet(index);
            }
            else
                this._showAlertDlg("Alert", "SheetDeleteErrorAlert", "", 430);
        },

        hideSheet: function (shtInfo) {
            if (this.model.isReadOnly)
                return;
            var visibeSht = this._getSheetNames(true), shtNames = this._getSheetNames(),
                idx = $.isNumeric(shtInfo) ? shtInfo : this._getSheetIndexByName(shtInfo) || this.getActiveSheetIndex();
            if (visibeSht.length > 1) {
                shtNames[idx - 1].isVisible = false;
                this.gotoPage(this._getNxtVisibleSheet(idx, null, visibeSht));
            }
            else
                this._showAlertDlg("Alert", "SheetDeleteErrorAlert", "", 377);
        },

        unhideSheet: function (shtInfo) {
            if (this.model.isReadOnly)
                return;
            var shtNames = this._getSheetNames(), idx = $.isNumeric(shtInfo) ? shtInfo : this._getSheetIndexByName(shtInfo);
            if (!shtNames[idx - 1].isVisible) {
                shtNames[idx - 1].isVisible = true;
                this.gotoPage(idx);
            }
            this.hideWaitingPopUp();
        },

        _getNxtVisibleSheet: function (idx, isReverseDir, visibleSheets) {
            var shtNames = this._getSheetNames(), limit = shtNames.length, optr1 = "<=", optr2 = 1, visibeShts = this._getSheetNames(true),
                isLastSht = shtNames[idx - 1].value === (visibleSheets && visibleSheets[visibleSheets.length - 1].value || visibeShts[visibeShts.length - 1].value);
            if (isReverseDir || isLastSht) {
                limit = 0;
                optr1 = ">=";
                optr2 = -1;
            }
            while (this.operators[optr1](idx, limit)) {
                if (shtNames[idx - 1].isVisible)
                    return idx;
                idx = idx + optr2;
            }
        },

        _renderSpreadSheetPager: function () {
            var inst, parent, pagerModel = {}, div = $(document.createElement("div"));
            this.model.pageSettings.change = $.proxy(this._spreadSheetPagerClickHandler, this);
            this.model.pageSettings.totalRecordsCount = this.model.sheetCount;
            this.model.pageSettings.locale = this.model.locale
            $.extend(pagerModel, this.model.pageSettings);
            pagerModel.currentPage = this.getActiveSheetIndex();
            pagerModel.pageSize = 1;
            pagerModel.showGotoPage = false;
            this.setPager(div);
            div.ejPager(pagerModel);
            inst = div.data("ejPager");
            inst._$first[0].title = this._getLocStr("Firstsheet");
            inst._$last[0].title = this._getLocStr("Lastsheet");
            inst._$next[0].title = this._getLocStr("Nextsheet");
            inst._$prev[0].title = this._getLocStr("Prevsheet");
            div.find(".e-parentmsgbar").remove();
            parent = div.find(".e-pagercontainer")[0];
            parent.appendChild(div.find("a.e-PP")[0]);
            parent.appendChild(div.find(".e-numericcontainer")[0]);
            parent.appendChild(div.find("a.e-NP")[0]);
            return div;
        },

        _getPageCount: function () {
            var isResponsive = this.model.scrollSettings.isResponsive, count = this.model.pageSettings.pageCount;
            if (isResponsive) {
                var pageCount = 0, sheetTxt, isIE8Bwsr, spanElem, pager = this.getPager(), cavsElem, cavsTxt, currentItem = pager.find('.e-currentitem'), numericcontainer = pager.find(".e-numericcontainer"),
                    sheetNames = this._getSheetNames(), totalwidth = pager.width(), width = 250, //total width except numeric container
                    visibleLinks = numericcontainer.children(':visible'), actIdx = this.getActiveSheetIndex(), startPgIdx = $(visibleLinks[0]).data("index"), isFoundCnt = true;

                isIE8Bwsr = (this._browserDetails.name === "msie" && this._browserDetails.version === "8.0");
                if (isIE8Bwsr) {
                    spanElem = $('#' + this._id + '_emptySpan');
                    spanElem.css({ 'font-size': currentItem.css('font-size'), 'font-family': currentItem.css("font-family") });
                }
                else {
                    cavsElem = document.createElement("canvas");
                    cavsTxt = cavsElem.getContext("2d");
                    cavsTxt.font = currentItem.css('font-size') + " " + currentItem.css("font-family");
                }
                while (actIdx > (startPgIdx - 1)) {
                    if (isIE8Bwsr)
                        width += (spanElem.text(sheetNames[actIdx - 1].text).width() + 19);
                    else
                        width += (cavsTxt.measureText(sheetNames[actIdx - 1].text).width + 19); //19 for padding & border
                    if (totalwidth <= width)
                        return pageCount || 1;
                    actIdx--;
                    pageCount++;
                }

                actIdx = this.getActiveSheetIndex();
                while (isFoundCnt) {
                    if (this.isUndefined(sheetNames[actIdx]))
                        sheetTxt = this._getLocStr("Sheet") + actIdx;
                    else
                        sheetTxt = sheetNames[actIdx].text;
                    if (isIE8Bwsr)
                        width += (spanElem.text(sheetTxt).width() + 19);
                    else
                        width += (cavsTxt.measureText(sheetTxt).width + 19);
                    if (totalwidth <= width) {
                        isFoundCnt = false;
                        break;
                    }
                    actIdx++;
                    pageCount++;
                }
                isIE8Bwsr && this._refreshGlobalSpan();

                return pageCount || 1;
            }
            else
                return count;
        },

		_spreadsheetPagerCustomBtnHandler: function (event) {
			var currentPage = this.getPager().ejPager("option", "currentPage");
			this._spreadSheetPagerClickHandler({"currentPage": currentPage, "event": event, "isInteraction": true});
		},
		
        _spreadSheetPagerClickHandler: function (sender) {
			if(!sender.isInteraction)
				return;
            var div, newPage, addnew = false, masterObj = this, args, trgt = $(sender.event.target), pagerObj = masterObj.getPager().data("ejPager"), fStartCell, fEndCell;
            masterObj._filterClose(trgt);
            if ((trgt.hasClass("e-new") && masterObj.model.exportSettings.password))
                return;
            if (((masterObj.model.allowComments && masterObj.XLComment._isCommentEdit) || masterObj.XLEdit._isEdit || !masterObj.model.allowInsert || masterObj.model.isReadOnly) && (sender.event && (trgt.hasClass("e-pager") || trgt.hasClass("e-new")) || (masterObj.element.find(".e-field-validation-error").length)))
                return;
            else {
                masterObj.model.allowComments && masterObj.XLComment._isCommentEdit && masterObj.XLComment._updateCurCmntVal();
                if (masterObj.XLEdit._isEdit && !masterObj.XLEdit._isFormulaEdit)
                    masterObj.XLEdit.saveCell();
                else {
				   var formulaText = masterObj.element.find("#" + masterObj._id + "_Edit").text();
				   if(formulaText.substr(formulaText.length-1).indexOf(",")>-1) {
					  fStartCell = {rowIndex:0, colIndex:0};
					  fEndCell = {rowIndex:0, colIndex:0};
				  }
				else {
				     fStartCell = masterObj._dStartCell;
				     fEndCell = masterObj._dEndCell;
				   }
				   masterObj.XLSelection._clearBorder(masterObj._arrayAsString(masterObj._ctrlFormulaBorder.concat(masterObj._formulaBorder)));
                    this.element.focus();
					}
            }
            if (!ej.isNullOrUndefined(sender.event) && (trgt.hasClass("e-prevpage") || trgt.hasClass("e-nextpage") || trgt.hasClass("e-firstpagedisabled") || trgt.hasClass("e-lastpagedisabled")))
                sender.currentPage = masterObj._getNxtVisibleSheet(sender.currentPage, (trgt.hasClass("e-prevpage") || trgt.hasClass("e-lastpage")) || trgt.hasClass("e-lastpagedisabled"));
            args = {
                activeSheet: masterObj.getActiveSheetIndex(),
                gotoSheet: sender.currentPage,
                newSheet: sender.event && trgt.hasClass("e-new")
            };
            if (args.newSheet) {
                div = masterObj.getPager();
                newPage = div.ejPager("option", "totalRecordsCount") + 1;
                args.gotoSheet = newPage;
            }
            else
                args.gotoSheet = sender.currentPage;
            sender.currentPage = args.gotoSheet;
            if ((!ej.isNullOrUndefined(sender.event) && sender.event.target.id.indexOf("_Sheet_RenamePanel") > -1) || (masterObj._isSheetRename && !masterObj._updateSheetNames(null, false)) || (pagerObj._prevPageNo === sender.currentPage))
                return;
            else if (args.newSheet) {
                div.ejPager("option", { totalRecordsCount: newPage, currentPage: newPage });
                sender.currentPage = newPage;
                addnew = true;
            }
            masterObj._pageClickArgs = $.extend(true, {}, args);
            masterObj.gotoPage(sender.currentPage, addnew);
			if (masterObj.XLEdit._isEdit && masterObj.XLEdit._isFormulaEdit) {
			    masterObj._dStartCell = fStartCell;
				masterObj._dEndCell = fEndCell;
				masterObj.XLSelection._processFormulaRange(masterObj._ctrlFormulaBorder, "" , sender.currentPage);
				}
            if (!$(sender.event.target).hasClass("e-pager")) {
                masterObj._completeAction({ reqType: "paging", sheetIndex: args.activeSheet, nSheetIndex: sender.currentPage });
                masterObj._trigActionComplete({ reqType: "paging", sheetIndex: args.activeSheet, newSheetIndex: sender.currentPage });
            }
            return false;
        },
          
        _pageLoadComplete: function (sheetIdx) {
            var sheetCont, evtArgs, sheet = this.getSheet(sheetIdx), opt = "option", chkd = "checked", args = this._gotoPageArgs, isSelect = this.model.allowSelection;
            if (isSelect && (sheetIdx !== args.prevSheetIdx) && (this.XLSelection._isGridBordering || this.XLSelection._isOutsideBordering)) {
                this._getContent(args.prevSheetIdx).find("div:first-child").removeClass("e-ss-drwbrdrcursor e-ss-drwbrdrgridcursor").addClass("e-ss-cursor");
                this.XLSelection._isGridBordering = this.XLSelection._isOutsideBordering = false;
            }
            if ((!sheet._isImported || sheet._isLoaded) && this.model.enableContextMenu)
                this.XLCMenu.hideCMenu();
            this._refreshSpreadSheetPager(args.newSheet);
            if (isSelect && this.getSheetElement(sheetIdx).find(".e-ss-activeimg").length)
                this.XLSelection._cleanUp(true);
            if (this.model.showRibbon) {
                this._updateRibbonTab(sheet._activeCell);
                if (!this.isImport) {
                    if (this.model.allowLockCell) {
                        (sheet.isSheetProtected || this.XLEdit._isFormulaEdit) ? this.XLRibbon._disableRibbonIcons() : this.XLRibbon._enableRibbonIcons();
                        this.XLRibbon._updateRibbonIcons();
                    }
                    if (this.model.allowComments)
                        this.XLComment._updateCmntRibIcons();
                }
                $("#" + this._id + "_Ribbon_PageLayout_Show_Headings").ejCheckBox(opt, chkd, sheet.showHeadings);
                $("#" + this._id + "_Ribbon_PageLayout_Show_Gridlines").ejCheckBox(opt, chkd, sheet.showGridlines);
            }
            if (this.model.allowCellFormatting) {
                sheetCont = this.getSheetElement(sheetIdx).find(".e-content")[0];
                if (this.XLFormat._formatEnable) {
                    this._removeClass(sheetCont, "e-ss-cursor");
                    this.addClass(sheetCont, "e-ss-fpcursor");
                }
                else {
                    this.addClass(sheetCont, "e-ss-cursor");
                    this._removeClass(sheetCont, "e-ss-fpcursor");
                }
            }
            if (this._pageClickArgs) {
                this._pageClickArgs.activeSheet = this.getActiveSheetIndex();
                if (this._trigger("pagerClick", this._pageClickArgs))
                    return;
                if (this.model.scrollSettings.isResponsive)
                    if (this._isResized && !this._resizeColl[sheetIdx - 1]) {
                        this._refreshSheetonResize();
                        if (this._resizeColl.toString().indexOf("f") < 0) {
                            this._isResized = false;
                            this._resizeColl.fill(false);
                        }
                    }
            }
            this.hideWaitingPopUp();
            this._pageClickArgs = this._gotoPageArgs = null;
            evtArgs = { gotoSheetIndex: args.gotoIndex, isNewSheet: args.newSheet, prevSheetIndex: args.prevSheetIdx, reqType: args.reqType };
            if (this._trigActionComplete(evtArgs))
                return;
        },

        _createTemplateElement: function (index, column) {
            var scriptElement = document.createElement("script");
            scriptElement.id = (this._id + index + column["field"] + $.inArray(column, this.getSheet(index).columns) + "_Template").split(" ").join("");
            scriptElement.type = "text/x-jsrender";
            scriptElement.text = column["templateContent"] ? column["templateContent"] : $(column["templateID"]).html();
            $("body").append(scriptElement);
            $(column["templateID"]).hide();
            return scriptElement;
        },

        _refreshSpreadSheetPager: function (refreshPgCnt) {
            var pager = this.getPager(), model = { currentPage: this.getActiveSheetIndex() }, prePgHght = pager.height(), curHght;
            if (this.isImport || this._isNew || pager === null)
                model.totalRecordsCount = this.model.sheetCount;
            if (refreshPgCnt || this._isInitLoad || this._isSheetInsert || this._isNew)
                this.model.pageSettings.pageCount =  model.pageCount = this._getPageCount();
            pager.ejPager("option", model).ejPager("refreshPager");
            this._updatePageContainer(pager, model.currentPage);
            curHght = pager.height();
            if (prePgHght !== curHght) {
                model.pageCount = this._getPageCount();
                pager.ejPager("option", model).ejPager("refreshPager");
                this._updatePageContainer(pager, model.currentPage);
            }
            if (!this.model.allowInsert)
                this.addClass(document.getElementById(this._id + "_AddSheet"), "e-disable");
        },

        _updatePageContainer: function (pagerContainer, currentPage) {
            var isFirst, isLast, index, pagerelem, sheetText, sheetinfo, i = 0, j = 0, pagerObj = pagerContainer.data("ejPager"), sheets = this.model.sheets,
                pager = pagerContainer.find(".e-numericcontainer").children(':visible'), pageCnt = pagerObj.model.pageCount, first = [pagerObj._$first[0], pagerObj._$prev[0]],
                firstcls = ["e-firstpagedisabled e-disable", "e-firstpage e-default", "e-prevpagedisabled e-disable", "e-prevpage e-default"],
                last = [pagerObj._$last[0], pagerObj._$next[0]], lastcls = ["e-lastpagedisabled e-disable", "e-lastpage e-default", "e-nextpagedisabled e-disable", "e-nextpage e-default"],
                len = pager.length, isSingleSht = ((i + 1) === len);
            pagerObj._$next[0].className = pagerObj._$next[0].className.replace("-2x", "");
            pagerObj._$prev[0].className = pagerObj._$prev[0].className.replace("-2x", "");
            while (i < len) {
                pagerelem = $(pager[i]);
                index = pagerelem.data("index");
                sheetinfo = sheets[index].sheetInfo;
                sheetText = sheetinfo.text;
                if (isSingleSht) {
                    var isIE8Bwsr, spanElem, pgrWidth = pagerContainer.outerWidth(), width, cavsElem,
                        cavsTxt, iterateElpstxt = true, temp = sheetText, sIdx = 3;
                    isIE8Bwsr = (this._browserDetails.name === "msie" && this._browserDetails.version === "8.0");
                    while (iterateElpstxt) {
                        if (isIE8Bwsr) {
                            spanElem = $('#' + this._id + '_emptySpan');
                            spanElem.css({ 'font-size': pagerelem.css('font-size'), 'font-family': pagerelem.css("font-family") });
                            width = 248 + (spanElem.text(temp).width() + 19);
                        }
                        else {
                            cavsElem = document.createElement("canvas");
                            cavsTxt = cavsElem.getContext("2d");
                            cavsTxt.font = pagerelem.css('font-size') + " " + pagerelem.css("font-family");
                            width = 248 + (cavsTxt.measureText(temp).width + 19); //total width except numeric container - 19(border & padding)
                        }
                        if (pgrWidth <= width && sheetText.length >= sIdx) {
                            temp = sheetText.slice(0, sheetText.length - sIdx++) + "...";
                            continue;
                        }
                        iterateElpstxt = false;
                        sheetText = temp;
                    }
                    isIE8Bwsr && this._refreshGlobalSpan();
                }
                pagerelem.text(sheetText);
                if (sheetinfo.isVisible)
                    isLast = index % pageCnt;
                else
                    pagerelem.hide();
                if (!isFirst && sheetinfo.isVisible)
                    isFirst = index % pageCnt;
                i++;
            }
            if (isFirst === currentPage) {
                for (i = 0; i < 2; i++) {
                    this.addClass(first[i], firstcls[j]);
                    this._removeClass(first[i], firstcls[j + 1]);
                    j += 2;
                }
            }
            j = 0;
            if (isLast === currentPage) {
                for (i = 0; i < 2; i++) {
                    this.addClass(last[i], lastcls[j]);
                    this._removeClass(last[i], lastcls[j + 1]);
                    j += 2;
                }
            }
        },

        _updateSheetNames: function (updatedValue, isCancel) {
            var args, pName, gridObj, rfrTo, calcObj, nMngr, pagerContainer = this.getPager(), i, len, $sheet = pagerContainer.find(".e-currentitem"),
                sheets = this.model.sheets, $input = $("#" + this._id + "_Sheet_RenamePanel"), isValidName = true,
                temp = [], cellRefrs, sheetNames, cellRef, fValue, rowIdx, colIdx, sheetIdx, regx, isReplaced, i, j, k, l, keys = [], calcDependent;
            if (ej.isNullOrUndefined(updatedValue))
                updatedValue = $input.val().trim();
            pName = sheets[$sheet.data("index")].sheetInfo.text;
            args = { reqType: "renameSheet", prevName: pName, newName: updatedValue };
            if (this._trigActionBegin(args))
                isCancel = true;
            updatedValue = args.newName;
            //Cancel rename action
            if (isCancel) {
                $input.remove();
                $sheet.show();
                if (this.model.showRibbon)
                    this.XLRibbon._enableRibbonIcons();
                if (this.model.enableContextMenu)
                    $("#" + this._id + "_contextMenuFooter").data("ejMenu")._contextMenuEvents("_on"); //for disable default contextmenu - clipboard actions
                this._isSheetRename = false;
                return false;
            }
            if (updatedValue.match(new RegExp(".*[\\[\\]\\*\\\\\/\\?].*")))
                updatedValue = false;
            if (!updatedValue) {
                this._showAlertDlg("Alert", ["SheetRenameEmptyAlert", "SheetRenameEmptyCharExceedAlert", "SheetRenameEmptySplCharAlert", "SheetRenameEmptyBlankAlert"], "sheetRenameActn", 500);
                return false;
            }
            //Check isValid name
            for (i = 1, len = sheets.length; i < len; i++) {
                if ($sheet.text() !== sheets[i].sheetInfo.text && updatedValue.toLowerCase() === sheets[i].sheetInfo.text.toLowerCase())
                    isValidName = false;
            }
            if (isValidName) {
                if (this.model.enablePivotTable)
                    this.XLPivot._updateSheetName(updatedValue);
                if (sheets[$sheet.data("index")].sheetInfo.text = updatedValue) {
                    $input.remove();
                    $sheet.show();
                    calcObj = this._calcEngine;
                    calcDependent = calcObj.getDependentCells().items;
                    for (var key in calcDependent)
                        if (calcDependent.hasOwnProperty(key))
                            keys.push(key);
                    cellRefrs = keys;
                    sheetNames = this._getSheetNames();
                    for (i = 0; i < cellRefrs.length; i++) {
                        cellRef = calcDependent[cellRefrs[i]];
                        for (j = 0; j < cellRef.length; j++) {
                            fValue = calcObj.getFormulaInfoTable().items[cellRef[j]];
                            if (fValue) {
                                fValue = fValue.getFormulaText();
                                for (k = 0; k < sheetNames.length; k++) {
                                    if (sheetNames[k].text !== sheetNames[k].value) {
                                        regx = new RegExp(sheetNames[k].value + '(?=[\'!])(?=[^"]*(?:"[^"]*"[^"]*)*$)', 'gi');
                                        if (fValue.match(regx)) {
                                            fValue = fValue.replace(regx, k + "/");
                                            temp.push(k);
                                            isReplaced = true;
                                        }
                                    }
                                }
                            }
                            if (isReplaced) {
                                l = 0;
                                while (l < temp.length) {
                                    regx = new RegExp(temp[l] + '/(?=[\'!])(?=[^"]*(?:"[^"]*"[^"]*)*$)', 'gi');
                                    fValue = fValue.replace(regx, sheetNames[temp[l]].text);
                                    l++;
                                }
                                rowIdx = calcObj.rowIndex(cellRef[j]) - 1;
                                colIdx = calcObj.colIndex(cellRef[j]) - 1;
                                sheetIdx = this._getSheetIdxFromSheetValue(this._getLocStr("Sheet") + (parseInt(cellRef[j].split("!")[1]) + 1));
                                this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: colIdx }, { dataObj: { value: fValue }, sheetIdx: sheetIdx });
                                isReplaced = false;
                            }
                        }
                    }
                    this._isSheetRename = false;
                }
                this._refreshSpreadSheetPager(true);
                this.model.allowFormulaBar && this.updateFormulaBar();
                //Refresh NM coll
                nMngr = this.model.nameManager;
                for (i in nMngr) {
                    rfrTo = nMngr[i].refersto;
                    if (rfrTo && rfrTo.indexOf(pName) > -1) {
                        rfrTo = rfrTo.replace(/[\']/g, "");
                        nMngr[i].refersto = rfrTo.replace(pName, updatedValue.match(/\s/g) ? "'" + updatedValue + "'" : updatedValue);
                    }
                }
                if (this.model.showRibbon) {
                    this.XLRibbon._enableRibbonIcons();
                    gridObj = $("#" + this._id + "_nmgrid").data("ejGrid");
                    if (gridObj) {
                        gridObj.refreshContent();
                        $("#" + this._id + "_nmrange").val("");
                    }
                }
                if (this.model.enableContextMenu)
                    $("#" + this._id + "_contextMenuFooter").data("ejMenu")._contextMenuEvents("_on"); //for disable default contextmenu - clipboard actions
                args = { reqType: "renameSheet", prevName: pName, newName: updatedValue };
                this._trigActionComplete(args);
                return true;
            }
            else
                this._showAlertDlg("Alert", "SheetRenameAlert", "sheetRenameActn", 325);
        },

        _getSheetIndexByName: function (sheetName) {
            var sheetNameCol = this._getSheetNames(), i, len;
            sheetName = sheetName && sheetName.replace(/^'|'$/g, '');
            if (sheetName)
                sheetName = sheetName.toLowerCase();
            for (i = 0, len = sheetNameCol.length; i < len; i++) {
                if (sheetNameCol[i].text.toLowerCase() === sheetName)
                    return (i + 1);
            }
            return false;
        },

        _removeSheet: function (index) {
            var sheetCount = this.model.sheetCount, shtDtCntr = this._dataContainer.sheets, i, sheets = this.model.sheets, args,
                j, cellRef, frmlaRefVal, frmlaVal, cellRefrs = [], regx, sIdx, rfr, delShtVal, nMngr, rfrTo, nMngrRefrs = [], calcObj, gridObj, calcDpdntCells;
            if (sheetCount > 1) {
                delShtVal = sheets[index].sheetInfo.value;
                this._getAutoFillOptElem().appendTo(this.element);
                this.element.find("#" + this._id + "_" + delShtVal).remove();
                if (sheetCount === this.getActiveSheetIndex()) {
                    for (i = 1; i < sheetCount; i++) {
                        if (sheets[index - i].sheetInfo.isVisible) {
                            this.setActiveSheetIndex(index - i);
                            break;
                        }
                    }
                }
                else
                    this.setActiveSheetIndex(index);
                this._swapSheetDtCntr(index, sheetCount);
                sheetCount in shtDtCntr && delete shtDtCntr[sheetCount];
                this._sheets.splice(sheetCount, 1);
                sheets.splice(sheetCount, 1);
                sheetCount = --this.model.sheetCount;
                this.getPager().ejPager("option", { totalRecordsCount: sheetCount, pageCount: this._getPageCount() });
                this.gotoPage(this.getActiveSheetIndex(), false);
                this._getAutoFillOptElem().appendTo(this._getJSSheetContent(this.getActiveSheetIndex()).find(".e-spreadsheetcontentcontainer > .e-content"));
                //Rebind sheet scroller event after delete sheets(index changed)
                this._rebindScrollEvnt();

                //Refresh NM coll
                nMngr = this.model.nameManager;
                for (i in nMngr) {
                    rfrTo = nMngr[i].refersto;
                    if (rfrTo.indexOf(delShtVal) > -1) {
                        nMngrRefrs.push(nMngr[i].name);
                        nMngr[i].refersto = "#REF!";
                    }
                }

                calcObj = this._calcEngine;
                calcDpdntCells = calcObj.getDependentCells().items;
                for (i in calcDpdntCells)
                    if (calcDpdntCells.hasOwnProperty(i))
                        cellRefrs.push(i);
                for (i = 0; i < cellRefrs.length; i++) {
                    cellRef = calcDpdntCells[cellRefrs[i]];
                    for (j = 0; j < cellRef.length; j++) {
                        frmlaRefVal = calcObj.getFormulaInfoTable().items[cellRef[j]];
                        sIdx = this._getSheetIdxFromSheetValue(this._getLocStr("Sheet") + (parseInt(cellRef[j].split("!")[1]) + 1));
                        if (frmlaRefVal && sIdx > -1) {
                            frmlaVal = frmlaRefVal.getFormulaText();
                            regx = new RegExp(delShtVal + '(?=[\'!])(?=[^"]*(?:"[^"]*"[^"]*)*$)', 'gi');
                            if (frmlaVal.match(regx)) {
                                frmlaVal = frmlaVal.replace(regx, "#REF");
                                this.XLEdit._updateDataContainer({ rowIndex: calcObj.rowIndex(cellRef[j]) - 1, colIndex: calcObj.colIndex(cellRef[j]) - 1 }, { dataObj: { value: frmlaVal }, sheetIdx: sIdx });
                                calcObj.refresh(frmlaRefVal.getParsedFormula());
                            }

                            for (rfr in nMngrRefrs)
                                if (frmlaVal.indexOf(nMngrRefrs[rfr]) > -1)
                                    calcObj.refresh(frmlaRefVal.getParsedFormula());
                        }
                    }
                }
                if (this.model.showRibbon) {
                    gridObj = $("#" + this._id + "_nmgrid").data("ejGrid");
                    if (gridObj) {
                        gridObj.refreshContent();
                        $("#" + this._id + "_nmrange").val("");
                    }
                }
                args = { sheetIndex: index, reqType: "remove-sheet" };
                this.clearUndoRedo();
                if (this._trigActionComplete(args))
                    return;
            }
        },

        _rebindScrollEvnt: function () {
            for (var i = 1; i <= this.model.sheetCount; i++) {
                if (this.getSheet(i)._isLoaded) {
                    this._getJSSheetContent(i).find(".e-spreadsheetcontentcontainer > .e-content").off("scroll");
                    this.element.find("#" + this._id + "_" + this.model.sheets[i].sheetInfo.value).find(".e-headercontent").off("scroll");
                    this._refreshScrollerEvent(i);
                }
            }
        },

        _getSheetNames: function (visible) {
            var i, len, sheetNames = [], sheets = this.model.sheets;
            for (i = 1, len = sheets.length; i < len; i++) {
                if (!this.isUndefined(visible) && ((visible && !sheets[i].sheetInfo.isVisible) || (!visible && sheets[i].sheetInfo.isVisible)))
                    continue;
                sheetNames.push(sheets[i].sheetInfo);
            }
            return sheetNames;
        },

        _initMoveCopyDlg: function () {
            var dlgId = this._id + "_moveCopyDlg", $dlg, $content, $okBtn, $cancelBtn, $btndiv, $listUl, $chkbox, $listCtn, $btnctnr;
            $dlg = ej.buildTag("div#" + dlgId, "", { display: "none" });
            $content = ej.buildTag("div#" + dlgId + "_sheetContent.e-dlgctndiv e-dlg-fields", ej.buildTag("label.e-dlg-fields", this._getLocStr("Beforesheet")));
            $listCtn = ej.buildTag("div.e-dlg-fields"), $listUl = ej.buildTag("ul#" + dlgId + "_list");
            $content.append($listCtn.append($listUl));
            $chkbox = ej.buildTag("input#" + dlgId + "_createcopy");
            $content.append($chkbox);
            $chkbox.ejCheckBox({ cssClass: "e-dlg-fields" });
            $chkbox.parent().append(ej.buildTag("label", this._getLocStr("CreateaCopy"), { "margin-left": 6 }));
            $dlg.append($content);
            $btndiv = ej.buildTag("div#" + dlgId + "_btndiv.e-dlg-btnfields");
            $btnctnr = ej.buildTag("div.e-dlg-btnctnr");
            $okBtn = ej.buildTag("input#" + dlgId + "_okbtn", "");
            $cancelBtn = ej.buildTag("input#" + dlgId + "_cnlbtn");
            $okBtn.ejButton({ text: this._getLocStr("Ok"), showRoundedCorner: true, click: ej.proxy(this._moveCopyBtnClick, this, "ok") , cssClass: "e-ss-okbtn", width: 60});
            $cancelBtn.ejButton({ text: this._getLocStr("Cancel"), click: ej.proxy(this._moveCopyBtnClick, this, "cancel"), showRoundedCorner: true, width: 60 });
            $btndiv.append($btnctnr.append($okBtn, $cancelBtn));
            $dlg.append($btndiv);
            this.element.append($dlg);
            $dlg.ejDialog({ showOnInit: false, enableModal: true, enableResize: false, allowKeyboardNavigation: false, title: this._getLocStr("MoveorCopy"), width: "auto", height: "auto", cssClass: "e-ss-dialog e-" + this._id + "-dlg e-ss-movedlg" });
            $listUl.ejListBox({
                dataSource: this._getSheetNames(),
                height: "197px",
                width: "250px",
                fields: { text: "text", value: "value" }
            });
        },

        _renderMoveCopyDlg: function () {
            var $dlg = $("#" + this._id + "_moveCopyDlg"), lbObj = $("#" + this._id + "_moveCopyDlg_list").data("ejListBox"), lbDataSrc = this._getSheetNames();
            lbDataSrc.push({ text: this._getLocStr('MoveToEnd'), value: this._getLocStr('MoveToEnd') });
            $dlg.ejDialog("open");
            lbObj.model.dataSource = lbDataSrc;
            lbObj.option("fields", { dataSource: lbDataSrc });
            lbObj.unSelectAll();
            lbObj.selectItemByIndex(0);
        },

        _initUnhideDlg: function () {
            var dlgId = this._id + "_UnhideDlg", $dlg, $content, $okBtn, $cancelBtn, $btndiv, $listUl, $btnctnr;
            $dlg = ej.buildTag("div#" + dlgId, "", { display: "none" });
            $content = ej.buildTag("div#" + dlgId + "_sheetContent.e-dlgctndiv e-dlg-fields", ej.buildTag("label.e-dlg-fields", this._getLocStr("UnhideDlgText")));
            $listUl = ej.buildTag("ul#" + dlgId + "_list");
            $content.append($listUl);
            $dlg.append($content);
            $btndiv = ej.buildTag("div#" + dlgId + "_btndiv.e-dlg-btnfields");
            $btnctnr = ej.buildTag("div.e-dlg-btnctnr");
            $okBtn = ej.buildTag("input#" + dlgId + "_okbtn");
            $cancelBtn = ej.buildTag("input#" + dlgId + "_cnlbtn");
            $okBtn.ejButton({ text: this._getLocStr("Ok"), showRoundedCorner: true, width: "25%", click: ej.proxy(this._unhideBtnClick, this, "ok"), cssClass: "e-ss-okbtn" });
            $cancelBtn.ejButton({ text: this._getLocStr("Cancel"), click: ej.proxy(this._unhideBtnClick, this, "cancel"), showRoundedCorner: true, width: "25%" });
            $btndiv.append($btnctnr.append($okBtn, $cancelBtn));
            $dlg.append($btndiv);
            this.element.append($dlg);
            $dlg.ejDialog({ showOnInit: false, enableModal: true, enableResize: false, allowKeyboardNavigation: false, title: this._getLocStr("UnhideSheet"), width: 280, height: "auto", cssClass: "e-ss-dialog e-" + this._id + "-dlg" });
            $listUl.ejListBox({
                dataSource: this._getSheetNames(),
                height: "197px",
                width: "250px",
                fields: { text: "text", value: "value" }
            });
        },

        _renderUnhideDlg: function () {
            var dlg = $("#" + this._id + "_UnhideDlg"), lbObj = $("#" + this._id + "_UnhideDlg_list").data("ejListBox"), lbDataSrc = this._getSheetNames(false);
            if (lbDataSrc.length > 0) {
                dlg.ejDialog("open");
                lbObj.model.dataSource = lbDataSrc;
                lbObj.option("fields", { dataSource: lbDataSrc });
                lbObj.unselectAll();
                lbObj.selectItemByIndex(0);
            }
        },

        _moveCopyBtnClick: function (action, e) {
            switch (action) {
                case "ok":
                    var args, spliceIndex, i, len, cpySheetName, isValid = false, sheetNameCount = 2, index, selectedItem = $(this.element).find(".e-currentitem"), lbObj = $("#" + this._id + "_moveCopyDlg_list").data("ejListBox"), checkObj = $("#" + this._id + "_moveCopyDlg_createcopy").data("ejCheckBox"), sText = lbObj.getSelectedItems()[0].text, mainIndex = lbObj.getIndexByText(sText), modelSheet = this.model.sheets;

                    //Check is same sheet
                    if (!checkObj.isChecked() && (sText === selectedItem.text())) {
                        $("#" + this._id + "_moveCopyDlg").ejDialog("close");
                        this.setSheetFocus();
                        return;
                    }

                    //Getting splice index and sheet position index
                    for (i = 1; i < modelSheet.length; i++) {
                        (sText === modelSheet[i].sheetInfo.text) && (spliceIndex = i);
                        (selectedItem.text() === modelSheet[i].sheetInfo.text) && (index = i);
                    }

                    args = { reqType: "moveSheet", toSheetIndex: mainIndex, fromSheetIndex: index, isCopy: checkObj.isChecked() };
                    if (this._trigActionBegin(args)) {
                        $("#" + this._id + "_moveCopyDlg").ejDialog("close");
                        return false;
                    }
                    mainIndex = args.toSheetIndex;
                    index = args.fromSheetIndex;

                    //Check is Copy sheet
                    if (checkObj.isChecked()) {
                        // Getting unique sheet name
                        if (selectedItem.text().match('.*[ ]+[(]+[0-9]+[)]$') === null) {
                            cpySheetName = selectedItem.text() + " (" + sheetNameCount + ")";
                        }
                        else {
                            if (selectedItem.text().lastIndexOf(' ') !== -1) {
                                sheetNameCount = parseInt(selectedItem.text().substring(selectedItem.text().lastIndexOf("(") + 1, selectedItem.text().lastIndexOf(")")));
                                cpySheetName = selectedItem.text().substring(0, selectedItem.text().lastIndexOf(" ")) + " (" + sheetNameCount + ")";
                            }
                        }
                        while (!isValid) {
                            cpySheetName = cpySheetName.substring(0, cpySheetName.lastIndexOf(" ")) + " (" + sheetNameCount + ")";
                            for (i = 1, len = modelSheet.length; i < len; i++) {
                                (cpySheetName === modelSheet[i].sheetInfo.text) && sheetNameCount++;
                            }
                            (sheetNameCount === parseInt(cpySheetName.substring(cpySheetName.lastIndexOf("(") + 1, cpySheetName.lastIndexOf(")")))) && (isValid = true);
                        }
                        this._copySheet = true;
                        //Copy Sheet Process      
                        this._copySheetProcess(index, cpySheetName);
						this._copySheet = false;

                        index = this.model.sheetCount;
                        ej.isNullOrUndefined(spliceIndex) && (spliceIndex = index);
                    }
                    else {
                        !ej.isNullOrUndefined(spliceIndex) && spliceIndex > index && (spliceIndex = spliceIndex - 1);
                    }

                    ej.isNullOrUndefined(spliceIndex) && (spliceIndex = mainIndex);

                    //Sheets[] updates
                    if (!checkObj.isChecked() && spliceIndex === index) {
                        $("#" + this._id + "_moveCopyDlg").ejDialog("close");
                        this.setSheetFocus();
                        break;
                    }

                    //Update DataContainer positions
                    this._swapSheetDtCntr(index, spliceIndex);

                    $("#" + this._id + "_moveCopyDlg").ejDialog("close");

                    spliceIndex <= index && (mainIndex = mainIndex + 1);
                    this.getPager().ejPager("option", { currentPage: mainIndex });
                    this.gotoPage(mainIndex, false);
                    this._rebindScrollEvnt();
                    args = { reqType: "moveSheet", toSheetIndex: mainIndex, fromSheetIndex: index, isCopy: checkObj.isChecked() };
                    this._trigActionComplete(args);

                    //uncheck copy sheet checkbox
                    checkObj._unChecked();
                    checkObj._isChecked = false;

                    this.setSheetFocus();
                    break;
                case "cancel":
                    $("#" + this._id + "_moveCopyDlg").ejDialog("close");
                    break;
            }
        },

        _unhideBtnClick: function (action, e) {
            if (action === "ok") {
                var lbObj = $("#" + this._id + "_UnhideDlg_list").data("ejListBox");
                this.unhideSheet(lbObj.getSelectedItems()[0].text);
            }
            $("#" + this._id + "_UnhideDlg").ejDialog("close");

        },

        _swapSheetDtCntr: function (index, spliceIdx) {
            var sheetDtMngr = this._dataContainer.sheets, modelSheet = this.model.sheets, dtSheets = this._sheets, shtValue = this._getLocStr("Sheet"), backupDtCntr = [{}], newIdx,
                bckupModel = this._getSheetNames();
            for (var ind in sheetDtMngr) {
                if (sheetDtMngr.hasOwnProperty(ind))
                    backupDtCntr[parseInt(modelSheet[ind].sheetInfo.value.replace(shtValue, ""))] = sheetDtMngr[ind];
            }
            modelSheet.splice(spliceIdx, 0, modelSheet.splice(index, 1)[0]);
            dtSheets.splice(spliceIdx, 0, dtSheets.splice(index, 1)[0]);
            for (var indx = 1, len = modelSheet.length; indx < len; indx++) {
                newIdx = parseInt(modelSheet[indx].sheetInfo.value.replace(shtValue, ""));
                this._dataContainer.sheets[indx] = backupDtCntr[newIdx];
            }
            this.clearUndoRedo();
        },

        _copySheetProcess: function (index, cpySheetName) {
            var cellIdx, csheet, i, len, newSheetIdx, sheetvalue, shapeMngr, shapeDtl, pager = this.getPager(), newPage = pager.ejPager("option", "totalRecordsCount") + 1, modelSheet = this.model.sheets;
            this._impData && this.XLExport._renderAll();
            pager.ejPager("option", { totalRecordsCount: newPage, currentPage: newPage });
            //Sheet settings Copy
            modelSheet.push(jQuery.extend(true, {}, modelSheet[index]));
            modelSheet[modelSheet.length - 1]._isImported = false;
            this._sheetCopy = { isSheetCopy: true, sheetContent: this._getContent(index).find(".e-table").clone(true).get(0), sheetIndex: index };

            newSheetIdx = this.model.sheetCount + 1;
            modelSheet[newSheetIdx].sheetInfo.text = cpySheetName;
            sheetvalue = modelSheet[newSheetIdx].sheetInfo.value = this._getLocStr("Sheet") + this._newSIndex;
            this._newSIndex++;
            this.setActiveSheetIndex(newSheetIdx);

            //Copy Data Container
            this._dataContainer.sheets[newSheetIdx] = $.extend(true, {}, this._dataContainer.sheets[index]);
            csheet = this._sheets[newSheetIdx] = { _contentColGroup: null, _content: null, _sheetRowHeaderContent: null, _sheetHeader: null, _sheetRowHeader: null, _sheetContent: null, _Rows: null };

            this._initSheet(newSheetIdx);
            this.model.sheetCount++;

            this._sheetCopy = { isSheetCopy: false, sheetContent: null, sheetIndex: null };


            //To register in calc engine
            this._calcEngine.registerGridAsSheet(sheetvalue, sheetvalue, this._calcID);

            //To update picture
            shapeMngr = modelSheet[newSheetIdx].shapeMngr.picture;
            len = this.getObjectLength(shapeMngr);
            for (i = 1; i <= len; i++) {
                shapeDtl = shapeMngr[this._id + "_picture" + i];
                this.XLShape._createPicture(newSheetIdx, { rowIndex: shapeDtl.rowIndex, colIndex: shapeDtl.colIndex }, this.getSheet(newSheetIdx).shapeMngr.sharedPics[shapeDtl.data], shapeDtl.top, shapeDtl.left, shapeDtl.width, shapeDtl.height, null, shapeDtl.bcolor, shapeDtl.bstyle, shapeDtl.bwidth);
            }

            //Comments update
            if (!this.model.scrollSettings.allowVirtualScrolling) {
                var commentCells = this._getContent(newSheetIdx).find(".e-commentcell"), elem, i, len;
                for (i = 0, len = commentCells.length; i < len; i++) {
                    elem = $(commentCells[i]);
                    cellIdx = this._getCellIdx($(".e-commentcell")[0]);
                    elem.removeClass("e-commentcell") && this.XLComment.setComment([cellIdx.rowIndex, cellIdx.colIndex, cellIdx.rowIndex, cellIdx.colIndex], null, false);
                }
            }
            if (this.model.allowComments)
                this.XLComment._updateCmntArrowPos();
        },

        showActivationPanel: function (rangeName) {
            var rangeInfo, sheetIdx = this.getActiveSheetIndex(), actpanel = this.getActivationPanel(), settings = this.model.scrollSettings;
            if (!this.model.enablePivotTable || this._phoneMode)
                return false;
            if (this.isUndefined(rangeName)) {
                if (this._getContent(sheetIdx).find(".e-ss-activepivot").length && this.XLPivot._displayActPanel) {
                    this.model._isActPanelVisible = true;
                    this._setSheetWidthHeight(sheetIdx, { width: this._responsiveWidth, height: this._responsiveHeight, isActPanel: true }, null, "refresh");
                    this._refreshActivationPanel();
                }
            }
            else {
                rangeInfo = this.getSheet(sheetIdx).rangeSettings[rangeName];
                if (rangeInfo.showPanel) {
                    if (this._trigger("beforePanelOpen", { activationPanel: actpanel, range: rangeInfo, sheetIndex: sheetIdx }))
                        return;
                    this.model._isActPanelVisible = true;
                    this._setSheetWidthHeight(sheetIdx, { width: this._responsiveWidth, height: this._responsiveHeight, isActPanel: true }, null, "refresh");
                    this._refreshActivationPanel();
                }
            }
            if (this.model.showPager)
                this._refreshSpreadSheetPager(true);
        },

        _refreshActivationPanel: function () {
            var actpanel = this.getActivationPanel(), height = this.getMainPanel().height(), scrObj = actpanel.data("ejScroller"), desObj;
            actpanel.width(this.model.activationPanelWidth - 1).height(height);
            actpanel.find(".e-ss-pivotfield").hide();
            actpanel.find("#" + this._id + "_PivotTableSchema_" + this._getContent(this.getActiveSheetIndex()).find(".e-ss-activepivot")[0].id).show();
            actpanel.find(".e-ss-pivotfield").width(this.model.activationPanelWidth - 20); //20 for scrollbar width
            actpanel.show();
            desObj = this.getActivationPanel().find("#" + this._id + "_PivotTableSchema_" + this._getContent(this.getActiveSheetIndex()).find(".e-ss-activepivot")[0].id).data("ejPivotSchemaDesigner");
            desObj._reSizeHandler();
            if (scrObj) {
                scrObj.option({ width: this.model.activationPanelWidth - 1, height: height });
                scrObj.refresh();
            }
        },

        hideActivationPanel: function () {
            var actpanel = this.getActivationPanel(), settings = this.model.scrollSettings;
            if (actpanel.is(":visible")) {
                actpanel.find(".e-ss-pivotfield").hide();
                this.model._isActPanelVisible = false;
                actpanel.hide();
                if (!this._isNew)
                    this._setSheetWidthHeight(this.getActiveSheetIndex(), { width: this._responsiveWidth, height: this._responsiveHeight }, null, "refresh");
                if (this.model.showPager)
                    this._refreshSpreadSheetPager(true);
            }
        },

        _addSheet: function (index) {
            this._sheetSettings(index);
            this._dataContainer.sheets[index] = {};
            this._initSheet(index);
            this._newSIndex++;
            this.model.sheetCount++;
        },

        addNewSheet: function () {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            this.element.find(".e-pager .e-new").click();
        },

        _createFocusElement: function () {
            this.setFocusTopElem($("<div class='e-focustop e-hide' ></div>"));
            this.setFocusRightElem($("<div class='e-focusright e-hide' ></div>"));
            this.setFocusBottomElem($("<div class='e-focusbottom e-hide' ></div>"));
            this.setFocusLeftElem($("<div class='e-focusleft e-hide' ></div>"));
        },

        _createAutoFillElement: function () {
            var html, sheetCont = this._getJSSheetContent(this.getActiveSheetIndex()).find(".e-spreadsheetcontentcontainer > .e-content");
            if (this.model.allowAutoFill) {
                html = $("<div class='e-autofill e-hide'></div>");
                sheetCont.append(html);
                this.setAutoFillElem(html);
            }
            this.element.append(ej.buildTag("ul.e-spreadsheet", "", { "width": "auto" }, { id: this._id + "_ctxtmenu" }));
            html = $("<div class='e-splitspan e-hide' title=" + this._getLocStr("AutoFillTitle") + "><button id=" + this._id + "_dragfilloptionbtn type='button'></button></div>");
            sheetCont.append(html);
            this._setAutoFillOptElem(html);
            this._initializeSplitButton();
        },

        _initializeSplitButton: function () {
            this._getAutoFillOptElem().find("button").ejSplitButton({
                size: "normal",
                contentType: "imageonly",
                targetID: this._id + "_ctxtmenu",
                prefixIcon: "e-icon e-ss-autofill",
                isSeparator: false,
                buttonMode: ej.ButtonMode.Dropdown,
                imagePosition: ej.ImagePosition.ImageLeft,
                arrowPosition: ej.ArrowPosition.Right,
                fields: { dataSource: this._fillOptionMenuData, id: "id", parentId: "parentId", text: "text", spriteCssClass: "sprite" },
                beforeOpen: $.proxy(this.model.allowAutoFill && this.XLDragFill._autoFillClick, this),
                itemSelected: $.proxy(this.model.allowAutoFill && this.XLDragFill._autoFillOptionClick, this),
                width: "42px",
                height: "24px",
                cssClass: "e-spreadsheet e-autofillbtn"
            });
        },

        // formula bar
        _renderFormulaBar: function (isSetModel) {
            var inputBox, formulabar = "<div id=" + this._id + "_formulabar class='e-formulabar' ><div id=" + this._id + "_indexbox class='e-indexbox' title='" + this._getLocStr("NameBox") + "'></div><div class='e-inputbox' ><input id=" + this._id + "_inputbox type='text' title='" + this._getLocStr("FormulaBar") + "'/></div></div>", frmlaBarHt;
            if (isSetModel)
                this.model.showRibbon ? $("#" + this._id + "_Ribbon").after(formulabar) : this.element.prepend(formulabar);
            else
                this.element.append(formulabar);
            this._setIndexBox($("#" + this._id + "_indexbox"));
            inputBox = $("#" + this._id + "_inputbox");
            this._setInputBox(inputBox);
            this.XLEdit._renderAutoComplete(inputBox, "", 26);
            this._alignFormulaBar();
            frmlaBarHt = this.element.find(".e-formulabar").height();
            if (frmlaBarHt > 36)
                this._formulaHeight = frmlaBarHt;
            if (this.model.isReadOnly)
                this.element.find('.e-formulabar')[0].disabled = true;
        },

        _alignFormulaBar: function (width) {
            var orgSettings = this.model.scrollSettings;
            width = width || this._responsiveWidth;
            this.element.find('.e-formulabar').width(orgSettings.isResponsive ? width - 2 : width);
            width = parseInt(width);
            var idxWt, iptWt, inputBox;
            idxWt = width / 10;
            iptWt = width - (idxWt + 24); // 24 is for border and padding for the index box and input box
            inputBox = this.element.find(".e-inputbox");
            inputBox.hide();
            inputBox.width(Math.floor(iptWt));
            this.element.find(".e-indexbox").width(Math.floor(idxWt));
            inputBox.show();
        },

        hideFormulaBar: function () {
            $("#" + this._id + "_formulabar").hide();
            if (!this._isInitLoad) {
                this._setSheetWidthHeight(this._getSheetIndex(), { width: this._responsiveWidth, height: this._responsiveHeight });
                for (var i = 1, len = this.model.sheets.length; i < len; i++)
                    this.getSheet(i)._isResized = (i != this.getActiveSheetIndex());
            }
        },

        showFormulaBar: function () {
            if (this.model.allowFormulaBar) {
                $("#" + this._id + "_formulabar").show();
                this._setSheetWidthHeight(this._getSheetIndex(), { width: this._responsiveWidth, height: this._responsiveHeight });
                for (var i = 1, len = this.model.sheets.length; i < len; i++)
                    this.getSheet(i)._isResized = (i != this.getActiveSheetIndex());
                this.updateFormulaBar();
            }
        },

        _getlocaleNumVal: function (value, isCulValue) {
            value = (typeof value !== "object" && Number(value)) ? Number(value) : ((!ej.isNullOrUndefined(value) && typeof value !== "object") ? ej.parseFloat(value + "", this.model.locale) : null);
            if (value && isCulValue) {
                var culNumFmt = ej.preferredCulture(this.model.locale).numberFormat, temp = value.toString();
                if (culNumFmt["."] != "." && temp.indexOf(culNumFmt["."]) < 0)
                    value = temp.replace(".", culNumFmt["."]);
            }
            return value;
        },

        _getEditValOfDateTime: function (rowIdx, colIdx) {
            var type = this.XLEdit.getPropertyValue(rowIdx, colIdx, "type"), cellData = this.getRangeData({ range: [rowIdx, colIdx, rowIdx, colIdx], property: ["value", "value2"] })[0];
            if (!this._isDateTime(cellData.value))
                return cellData.value2;
            if (type == "longdate" || type == "date") {
                if (cellData.value.toLocaleTimeString() != "12:00:00 AM")
                    return this.formatting("{0:" + ej.preferredCulture(this.model.locale).calendar.patterns["dT"] + "}", cellData.value, this.model.locale);
                else 
                    return this.formatting("{0:" + ej.preferredCulture(this.model.locale).calendar.patterns["d"] + "}", cellData.value, this.model.locale);
            }
            else {
                if ((cellData.value.toLocaleDateString() != "1/1/1990" && cellData.value.toLocaleTimeString() != "12:00:00 AM") || (type == "time" && cellData.value.toLocaleDateString() != "1/1/1990"))
                    return this.formatting("{0:" + ej.preferredCulture(this.model.locale).calendar.patterns["dT"] + "}", cellData.value, this.model.locale);
                else
                    return cellData.value2;
            }
        },

        updateFormulaBar: function () {
            if (this.model.isReadOnly)
                return;
            var val, cellData, text, sheetIdx = this.getActiveSheetIndex(), activecell = this.getSheet(sheetIdx)._activeCell,
                trgt = this._getContent(sheetIdx).find(".e-ss-activeimg")[0], culNumFmt, regExp;
            cellData = this.getRangeData({ range: [activecell.rowIndex, activecell.colIndex, activecell.rowIndex, activecell.colIndex], property: ["value", "value2", "isLocked"] })[0];
            if (!ej.isNullOrUndefined(cellData))
                val = ej.isNullOrUndefined(cellData.value) ? "" : cellData.value;
            else
                val = "";
            if (this._isDateTime(val))
                val = this._getEditValOfDateTime(activecell.rowIndex, activecell.colIndex);
            if (this.model.locale !== "en-US" && this.isNumber(val)) {
                culNumFmt = ej.preferredCulture(this.model.locale).numberFormat, regExp = new RegExp("\\" + culNumFmt[","] + "\\d{3}"), val = val + "";
                if (culNumFmt[","] == "." && (regExp.test(val) || cellData.value != cellData.value2))
                    val = this._getlocaleNumVal(val, true);
            }
            if (this.XLEdit.getPropertyValue(activecell.rowIndex, activecell.colIndex, "type") === "percentage")
                val = this.isFormula(cellData.value) ? cellData.value : cellData.value2; 
            this._getInputBox().val(val);
            if (this.XLEdit.getPropertyValue(activecell.rowIndex, activecell.colIndex, "isReadOnly") || (this.model.allowLockCell && this.getSheet(sheetIdx).isSheetProtected && cellData.isLocked))
                this._getInputBox().attr("readonly", "readonly");
            else
                this._getInputBox().prop("readonly", false);
            if (trgt && (trgt.id.indexOf(this._id + "_picture") > -1 || trgt.id.indexOf(this._id + "_chart") > -1))
                text = trgt.id.replace($(trgt).data("parentID") + "_", "");
            else
                text = this._generateHeaderText(activecell.colIndex + 1) + (activecell.rowIndex + 1);
            this._getIndexBox().html(text);
        },

        _initSelection: function () {
            var range, model = this.model, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx),
                scont = this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content"), type = model.selectionSettings.selectionType,
                types = ej.Spreadsheet.SelectionType, actCell = model.selectionSettings.activeCell;
            if (model.allowSelection) {
                if (!this.getFocusTopElem())
                    this._createFocusElement();
                scont.append(this.getFocusTopElem(), this.getFocusRightElem(), this.getFocusBottomElem(), this.getFocusLeftElem());
                if (actCell) {
                    range = this.getRangeIndices(actCell);
                    if (!this.isRange(range) && (range[0] < sheet.rowCount && range[1] < sheet.colCount))
                        sheet._startCell = sheet._endCell = sheet._activeCell = { rowIndex: range[0], colIndex: range[1] };
                }
                if ((!sheet._isImported || sheet._isLoaded) && sheet._selectedCells.length) {
                    this.XLSelection.selectRange(sheet._selectedCells[0], sheet._selectedCells[sheet._selectedCells.length - 1]);
                    this.XLSelection._refreshBorder();
                }
                else {
                    this.XLSelection._processBoundary();
                    if (type === types.Row || sheet._isRowSelected)
                        this.XLSelection.selectRows(sheet._startCell.rowIndex, sheet._endCell.rowIndex);
                    else if (type === types.Column || sheet._isColSelected)
                        this.XLSelection.selectColumns(sheet._startCell.colIndex, sheet._endCell.colIndex);
                    else
                        this.XLSelection.selectRange(sheet._startCell, sheet._endCell);
                }
            }
            if (model.allowAutoFill) {
                if (!this.getAutoFillElem())
                    this._createAutoFillElement();
                this.getAutoFillElem().appendTo(scont);
                this.XLDragFill.positionAutoFillElement();
                if (model.autoFillSettings.showFillOptions && model.allowAutoFill) {
                    this._getAutoFillOptElem().appendTo(scont);
                    this.XLDragFill.hideAutoFillOptions();
                }
            }
            if (model.allowSelection && sheet._isFreezed)
                this.XLFreeze._refreshSelection();
        },

        _updateRibbonTab: function (cellIdx) {
            var actShape, tname, sheetIdx = this.getActiveSheetIndex(), robj = $("#" + this._id + "_Ribbon").data("ejRibbon"), xlRibbon = this.XLRibbon,
                ctabs = this.element.find(".e-ribbon .e-contextual a:visible"), len = ctabs.length,
                ribTabPinEle = robj.element.find("#" + this._id + "_Ribbon_togglebutton");
            if (cellIdx)
                tname = this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex, "tableName", sheetIdx);
            if (len) {
                while (len--)
                    robj.hideTab(ctabs[len].text);
            }
            xlRibbon._toggleAnalyzeTab();
            if (ribTabPinEle.is(":visible") && ribTabPinEle.hasClass("e-ribbonpin"))
                this._refreshSheetonResize();
            actShape = this._getContent(sheetIdx).find(".e-ss-activeimg");
            if (actShape.length)
                actShape[0].id.indexOf("chart") > -1 ? this.XLRibbon._chartDesignTabUpdate(actShape) : this.XLRibbon._formatTabUpdate();
            else if (tname)
                xlRibbon._designTabUpdate(this._getTableID(tname), cellIdx);
            else if (this._getContent(sheetIdx).find(".e-ss-activepivot").length) {
                xlRibbon._analyzeTabUpdate();
                this.XLSelection._cleanUp(true);
                this.getActivationPanel().find("#" + this._id + "_PivotTableSchema_" + this._getContent(sheetIdx).find(".e-ss-activepivot")[0].id).show();
                this.showActivationPanel();
            }
        },

        _updateCellType: function () {
            var i, ctype = ej.Spreadsheet.CellType;
            for (i in ctype)
                this._dataContainer.cellType.push(ctype[i]);
        },

        _updateFormulaCollection: function () {
            var i, libraryFunc = this._calcEngine.getLibraryFunctions(), arr = [];
            for (i in libraryFunc.items)
                arr.push({ text: "=" + i, display: i });
            this._formulaCollection = arr;
        },

        _renderScroller: function (sheetIdx, settings, action) {
            this.XLScroll._createScroller(sheetIdx, settings, action);
            this._refreshScrollerEvent(sheetIdx);
        },

        _refreshScrollerEvent: function (sheetIdx) {
            this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content").scroll(ej.proxy(function (e) {
                var sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), scrollLeft = this._isFrozen(this.getFrozenColumns(sheetIdx)) ? $(e.target).scrollLeft() : sheet._scrollLeft;
                this._getJSSheetHeader(sheetIdx).find(".e-headercontent").scrollLeft(scrollLeft);
                this._getJSSheetRowHeaderContent(sheetIdx).scrollTop($(e.currentTarget).scrollTop());
            }, this));

            this.element.find("#" + this._id + "_" + this.model.sheets[sheetIdx].sheetInfo.value).find(".e-headercontent").scroll(ej.proxy(function (e) {
                var sheetIdx = this.getActiveSheetIndex(), scrollLeft = this._isFrozen(this.getFrozenColumns(sheetIdx)) ? $(e.target).scrollLeft() : this.getSheet(sheetIdx)._scrollLeft;
                this._getContent(sheetIdx).find(".e-content").scrollLeft(scrollLeft);
                this.getSheet(sheetIdx)._scrollLeft = this._getContent(sheetIdx).find(".e-content").scrollLeft();
            }, this));
        },

        _clickHandler: function (e) {
            this.XLEdit._isFEdit = false;
            if (this._hasClass(e.target, "e-ssfilter")) {
                if (this._excelFilter._openedFltr && $(this._excelFilter._openedFltr).is(":visible"))
                    this._excelFilter.closeXFDialog();
                else
                    this.XLFilter._filterClickHandler(e);
            }
            else {
                if (e.target.tagName === "TD" && $(e.target).parents("div")[0].className.indexOf("e-content") > -1 && e.target.className.indexOf('e-rowcell') > -1 && $(e.target).find('.e-chk-image').length < 1) {
                    this._clkCellObj = this._getCellIdx(e.target);
                }
				if(e.target.localName === "svg" || e.target.localName === "path" || e.target.localName === "rect" || e.target.localName === "circle" || (e.target.localName === "div" && e.target.className.indexOf("e-sparkline") > -1)) {
					this._clkCellObj = this._getCellIdx($(e.target).closest("td")[0]);
				}
				if(e.target.tagName === "DIV" && e.target.id.indexOf("_Merge") > -1)
					this._clkCellObj = this._getCellIdx(e.target.parentElement);
                if (this._isExport || !this.model.cellClick)
                    return false;
                var args, target = e.target, sheetIdx = this.getActiveSheetIndex(), colIndex, rowIndex, column;
                if (e.target.tagName === "TD" && $(e.target).parents("div")[0].className.indexOf("e-content") > -1 && e.target.className.indexOf('e-rowcell') > -1 && $(e.target).find('.e-chk-image').length < 1) {
                    colIndex = target.cellIndex, rowIndex = $.inArray($(target).closest("tr").get(0), this.getRows(sheetIdx)[1]);
                    column = this.getSheet(sheetIdx).columns[colIndex];
                    args = {
                        columnName: column.field, value: this.XLEdit.getPropertyValue(rowIndex, colIndex), columnIndex: colIndex, rowIndex: rowIndex, columnObject: column, cell: target, eventArgs: e, event: e,
                        target: e.target
                    };
                    if (this._trigger("cellClick", args))
                        return;
                }
                else if (!ej.isNullOrUndefined($(e.target).parents("div")) && $(e.target).parents("div")[0].className.indexOf("e-content") > -1 && e.target.className.indexOf('e-rowcell') > -1 && $(e.target).find('.e-chk-image').length < 1) {
                    target = $(e.target).parents("td").get(0);
                    if (!ej.isNullOrUndefined(target)) {
                        colIndex = target.cellIndex, rowIndex = $.inArray($(target).closest("tr").get(0), this.getRows(sheetIdx)[1]);
                        column = this.getSheet(sheetIdx).columns[colIndex];
                        args = {
                            columnName: column.field, value: this.XLEdit.getPropertyValue(rowIndex, colIndex), columnIndex: colIndex, rowIndex: rowIndex, columnObject: column, cell: target, eventArgs: e, event: e,
                            target: e.target
                        };
                        if (this._trigger("cellClick", args))
                            return;
                    }
                }
            }
        },

        _wireEvents: function (action) {
            var elem = this.element, id = this._id;
            if (this.model.enableTouch && parseInt(this._browserDetails.version) > 8)
                this._wireTouchEvts("_on");
            else
                this._wireTouchEvts("_off");
            this[action](elem, "mousedown", ".e-spreadsheetcontentcontainer .e-content, .e-spreadsheetrowheader, .e-spreadsheetheader, .e-spreadsheetactpanel, .e-ribbon, .e-spreadsheetcontentcontainer .e-vscroll, .e-spreadsheetcontentcontainer .e-hscroll", this._mouseDownHandler);
            this[action](elem, "mousemove", this._mouseMoveHandler);
            this[action](elem, "mouseup", this._mouseUpHandler);
            this[action](elem, "keydown", this._keyDownHandler);
            this[action](elem, "keyup", this._keyUpHandler);
            this[action](elem, "click", ".e-spreadsheetcontentcontainer .e-content,.e-spreadsheetrowheader,.e-spreadsheetheader,.e-spreadsheetactpanel, .e-ss-object, .e-ss-sparkline", this._clickHandler);
            this[action](elem, ($.isFunction($.fn.doubletap) && (this.model.enableTouch && (parseInt(this._browserDetails.version) > 8)) && !this._browserDetails.isMSPointerEnabled) ? "doubletap" : "dblclick", ".e-spreadsheetcontentcontainer, .e-spreadsheetheader, .e-spreadsheetrowheader, .e-numericcontainer .e-numericitem, .e-ss-sparkline", this._dblClickHandler);
            this[action](elem, "mouseleave", ".e-spreadsheetrowheader, .e-spreadsheetheader, .e-viewhdrlbl, .e-vheading, .e-viewlinlbl, .e-vgridlines", this._mouseLeaveHandler);
            this[action](elem, "mouseover", ".e-spreadsheetcontentcontainer .e-content .e-rowcell, .e-viewhdrlbl, .e-vheading, .e-viewlinlbl, .e-vgridlines, .e-rowheadercontent, .e-vscrollbar, .e-hscrollbar, .e-spreadsheetfooter, .e-spreadsheetheader", this._mouseHoverHandler);
            if (this.model.allowFormulaBar && this.XLEdit)
                this[action](this._getInputBox(), "input", this.XLEdit._formulaBoxInputChange);
            this[action]($(".e-" + id + ".e-chartcell"), "click", this._chartClickHandler);
            this[action]($('#' + id + '_cellstyles'), "click", this._cellStyleClick);
            this[action]($('#' + id + '_formatastable'), "click", this._formatAsTableClick);
            this[action]($('#' + id + '_nmuseinformula'), "click", ".e-nmuseinformularow", this._useInFormulaClick);
			this[action]($("#" + id + "_AddSheet"), "click", this._spreadsheetPagerCustomBtnHandler);
			if (this.model.scrollSettings.allowScrolling && this.XLScroll)
                this[action](this.element.find(".e-spreadsheet-list"), 'mousewheel DOMMouseScroll', $.proxy(this.XLScroll._spreadMouseWheel, this.XLScroll));
            if (this.model.scrollSettings.isResponsive)
                this[action]($(window), "resize", $.proxy(this._resizeHandler, this));            
        },

        _wireTouchEvts: function (action) {
            if (this._browserDetails.name != "msie" || ["11.0", "10.0"].indexOf(this._browserDetails.version) === -1)
                this[action](this.element, this._getBrowserEvt(), ".e-spreadsheetcontentcontainer .e-content, .e-spreadsheetrowheader, .e-spreadsheetheader, .e-spreadsheetactpanel, .e-ribbon, .e-spreadsheetcontentcontainer .e-vscroll, .e-spreadsheetcontentcontainer .e-hscroll", this._mouseDownHandler);
            this[action](this.element, this._getBrowserEvt("move"), this._mouseMoveHandler);
            this[action](this.element, this._getBrowserEvt("end"), this._mouseUpHandler);
            this[action](this.element, "swipeleft swiperight", ".e-spreadsheetfooter", this._swipeHandler);
        },

        _getBrowserEvt: function (type, isMouse) {
            var evt;
            if (type === "move")
                evt = this._browserDetails.isMSPointerEnabled ? (this._browserDetails.pointerEnabled ? "pointermove" : "MSPointerMove") : (isMouse ? "mousemove" : "touchmove");
            else if (type === "end")
                evt = this._browserDetails.isMSPointerEnabled ? (this._browserDetails.pointerEnabled ? "pointerup" : "MSPointerUp") : (isMouse ? "mouseup" : "touchend");
            else
                evt = this._browserDetails.isMSPointerEnabled ? (this._browserDetails.pointerEnabled ? "pointerdown" : "MSPointerDown") : "touchstart";
            return evt;
        },

        _swipeHandler: function (e) {
            var sheetIdx = this.getActiveSheetIndex();
            this.gotoPage(e.type === "swiperight" ? --sheetIdx : ++sheetIdx);
        },

        _isTouchEvent: function (e) {
            if (this.model.enableTouch && (e.type.indexOf("touch") > -1 || e.type.indexOf("pointer") > -1) && e.originalEvent.pointerType !== "mouse" && e.originalEvent.pointerType !== 4)
                return true;
            return false;
        },

        _getOriginalEvt: function (e) {
            if (e.originalEvent.changedTouches)
                return e.originalEvent.changedTouches[0];
            return e.originalEvent;
        },

        _allChartType: function (e) {
            $("#" + this._id + "_allchart").find(".e-chartimg").removeClass("e-chartselect");
            $(e.target).addClass("e-chartselect");
        },

        refreshSpreadsheet: function () {
            if (this._responsiveHeight > 350) {
                this._refreshSheetonResize();
                if (this.model.showRibbon)
                    $("#" + this._id + "_Ribbon").data("ejRibbon")._ribbonResize();
            }
        },
		
		refresh: function() {
			this._isRefresh = true;
			this._destroy();
			for(var i = 1; i <= this.model.sheetCount; i++)
				this.model.sheets[i]._isLoaded = false;
			this.addClass(this.element[0], this._rootCSS);
			this._init();
			this._isRefresh = false;
		},
		
        _resizeHandler: function () {
            var resizeTimer, proxy = this;
            if (proxy.element.is(":hidden"))
                return;
            if (resizeTimer) {
                clearTimeout(resizeTimer);
            }
            resizeTimer = setTimeout(function () {
                proxy._refreshSheetonResize();
                for (var i = 1, len = proxy.model.sheets.length; i < len; i++)
                    proxy.getSheet(i)._isResized = (i != proxy.getActiveSheetIndex());
            }, 100);
        },

        _refreshSheetonResize: function () {
            var contentrows, rowhdrrows, sheetIdx = this.getActiveSheetIndex(), settings, popupElem = $('.e-menu:visible[id^=' + this._id + '], .e-ddl-popup:visible[id^=' + this._id + ']'), inputBox = $("#" + this._id + "_inputbox_suggestion"), elemId, sElem,
                popupIds = ["CFormat", "Validation", "PageSize", "FPane", "Ins", "Del", "FindRep"], pEleIds = ["Home_Styles_ConditionalFormatting", "Data_DataTools_DataValidationOptions", "PageLayout_PageLayout_PageSizeOptions", "Others_Window_FreezePanes", "Others_Cells_InsertCellOptions", "Others_Cells_DeleteCellOptions", "Others_Editing_FindSelect"],
                ePanel, sRnmVal, isPhoneMode = this._phoneMode;
            this._resizeColl[sheetIdx - 1] = this._isResized = true;
            this.element.find(".e-inputbox").hide();
			if (!ej.isNullOrUndefined(this._getFormulaSuggElem()))
            {
                this._isFormulaSuggestion = false;
                this._getFormulaSuggElem().hide();
            }
            if (!ej.isNullOrUndefined(inputBox[0]) && inputBox[0].style.display == "block")
            {
                this._isFormulaSuggestion = false;
                inputBox.hide();
            }
            this.model.enablePivotTable && this.hideActivationPanel();
            this._phoneMode = this.model.scrollSettings.isResponsive && document.documentElement.clientWidth < 420;
            this._tabMode = this.model.scrollSettings.isResponsive && (document.documentElement.clientWidth > 419 && document.documentElement.clientWidth < 617);
            settings = { width: this._responsiveWidth, height: this._responsiveHeight };
            (this.model.showRibbon && (this._tabMode || this._responsiveHeight < 280)) && $("#" + this._id + "_Ribbon").ejRibbon("collapse");
            this._refreshSheetWithScreen(sheetIdx);
            this._updateResponsiveSettings();
            this._initViewPort(sheetIdx);
            this.refreshContent(sheetIdx);
            settings.width = this._responsiveWidth;
            settings.height = this._responsiveHeight;
            this._setSheetWidthHeight(sheetIdx, settings, null, "refresh");
            contentrows = this._getContTBody(sheetIdx).find("tr");
            rowhdrrows = this._getRowHdrTBody(sheetIdx).find("tr");
            this.setRows([rowhdrrows, contentrows], sheetIdx);
            this._dlgWidth = (this._phoneMode || this._tabMode || this._responsiveWidth < 350) ? this._responsiveWidth - 2 : this._responsiveWidth / 1.5;
            this._dlgHeight = (this._phoneMode || this._tabMode || this._responsiveHeight < 350) ? this._responsiveHeight - 2 : this._responsiveHeight / 1.2;
            if (this.model._isActPanelVisible)
                this._refreshActivationPanel();
            this.element.find(".e-inputbox").show();
            if (this.model.showPager) {
                if (this._isSheetRename) {
                    ePanel = this.getPager().find("#" + this._id + "_Sheet_RenamePanel");
                    sRnmVal = ePanel.val();
                    ePanel.remove();
                }
                this._refreshSpreadSheetPager(true);
                this._isSheetRename && this._renameSheet(sRnmVal);
            }
            if (this._phoneMode) {
                $("#" + this._id + "_CFormat").css("width", "");
                $("#" + this._id + "_Ribbon_Border").css("width", "");
                $('#' + this._id + '_indexbox').css({ 'text-overflow': 'ellipsis', 'overflow': 'hidden' });
            }
            if (this.model.showRibbon) {
                this.XLRibbon._refreshBackstageHeight();
                if (this._phoneMode && !isPhoneMode)
                    this.XLRibbon._hideRibbonElem();
            }
            //pop-up hide
            if (popupElem.length) {
                elemId = popupElem[0].id.split("_", 3);
                elemId.indexOf("Ribbon") === -1 && elemId.splice(1, 0, "Ribbon");
                elemId[2] = popupIds.indexOf(elemId[2]) > -1 ? pEleIds[popupIds.indexOf(elemId[2])] : elemId[2].toLowerCase();
                elemId = elemId.join("_");
                if (elemId.length) {
                    sElem = $("#" + elemId);
                    if (sElem.hasClass("e-splitbutton"))
                        sElem.ejSplitButton("hide");
                    if (sElem.hasClass("e-dropdownlist"))
                        sElem.ejDropDownList("hidePopup");
                }
            }
            this._isResized = false;
            if (this._isRibbonDestroyed) {
                var rbnObj = $("#" + this._id + "_Ribbon").ejRibbon("instance");
                if (this.model.ribbonSettings.enableOnDemand) {
                    tabText = rbnObj.getTabText(rbnObj.model.selectedItemIndex);
                    this.XLRibbon._createTabControls(tabText);
                }
                else {
                    var tabColl = [this._getLocStr("HOME"), this._getLocStr("DATATAB"), this._getLocStr("PAGELAYOUT"), this._getLocStr("OTHERS")];
                    for (var c = 0, cLen = tabColl.length; c < cLen; c++)
                        this.XLRibbon._updateRibCustomCss(tabColl[c]);
                }
                this._on($(".e-" + this._id + ".e-chartcell"), "click", this._chartClickHandler);
                this._on($('#' + this._id + '_cellstyles'), "click", this._cellStyleClick);
                this._on($('#' + this._id + '_formatastable'), "click", this._formatAsTableClick);
            }
            this._isRibbonDestroyed = false;
            this._trigger('refresh');
        },

        _chartClickHandler: function (e) {
            var trgt = $(e.target), prop = $.extend(true, {}, $(e.target).data());
            trgt.parents().eq(1).hide();
            this.XLChart.createChart(null, prop);
        },

        _useInFormulaClick: function (e) {  // defined names click
            var i, temp, formula, eql = "=", comma = ",", oBrkt = "(", isFrmla = false, txt = e.target.textContent, sheetIdx = this.getActiveSheetIndex(),
                actCell = this.getActiveCell(sheetIdx), editElem = this.XLEdit._editElem, text = editElem.text(), hasMergeIdx;
            hasMergeIdx = this.XLEdit.getPropertyValue(actCell.rowIndex, actCell.colIndex, "mergeIdx");
            this._intrnlReq = true;
            this.XLEdit.editCell(hasMergeIdx ? hasMergeIdx.rowIndex : actCell.rowIndex, hasMergeIdx ? hasMergeIdx.colIndex : actCell.colIndex, true);
            this._intrnlReq = false;
            if (text === eql)
                editElem.text(eql + txt);
            else {
                formula = this.XLDragFill._parseFormula(text)
                i = formula.length;
                if (i) {
                    while (i--) {
                        if (formula[i] === comma || formula[i] === oBrkt) {
                            formula.splice(i + 1, 0, txt);
                            isFrmla = true;
                            break;
                        }
                        else if (this._isCellReference(formula[i]) || this.isNumber(formula[i])) {
                            formula[i] = txt;
                            isFrmla = true;
                            break;
                        }
                    }
                    txt = isFrmla ? formula.join("") : txt;
                }
                editElem.text(eql + txt);
            }
            editElem.focusEnd();
            $("#" + this._id + "_nmuseinformula").hide();
        },

        _formatAsTableClick: function (e) {
            var tname, fatName, target = e.target,
            sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), scells = sheet._selectedCells;
            if (scells.length === 0)
                return;
            if (target.parentNode.className === 'e-formatastablecell') {
                tname = this.XLEdit.getPropertyValue(scells[0].rowIndex, scells[0].colIndex, "tableName", sheetIdx);
                this._showDialog(this._id + "_Ribbon_Insert_Tables_Table");
                if (tname) {
                    this.XLFormat._formatAsTableStyle = this._FATStyles[target.parentNode.id.replace(/ /g, '')];
                    this.XLFormat._createTable(this._getTableID(tname), this.XLFormat._formatAsTableStyle);
                }
                else if (scells.length > 1) {
                    fatName = $("#" + this._id + '_fatname');
                    $('#' + this._id + '_fatnamedlg').ejDialog("open");
                    $("#" + this._id + "_fatheader").data("ejCheckBox").option("checked", false);
                    fatName.val('Table' + (this._tableCnt)).focus().setInputPos(fatName.val().length);
                    if (this.model.allowCellFormatting)
                        this.XLFormat._formatAsTableStyle = this._FATStyles[target.parentNode.id.replace(/ /g, '')];
                }
                else
                    this._showAlertDlg("Alert", "FormatAsTableAlert", null, 445);
            }
            if (target.className.indexOf("back") > -1 || target.parentNode.className === 'e-formatastablecell')
                $('#' + this._id + '_Ribbon_Home_Styles_FormatAsTable').length && $('#' + this._id + '_Ribbon_Home_Styles_FormatAsTable').data("ejSplitButton")._hidePopup();
        },

        _borderSelectionClick: function (e) {
            var args = { ID: e.target.parentNode.id }, alphRange, target = e.target, sheetIdx = this.getActiveSheetIndex(), selCells = this.getSheet(sheetIdx)._selectedCells;
            if (selCells.length === 0)
                return;
            if ((this._borderStyles.indexOf(args.ID) > -1))
                this.XLRibbon._updateBordeStyle(args);
            hexcode = this._borderColor || '#000000';
            alphRange = this._getAlphaRange(sheetIdx, selCells[0].rowIndex, selCells[0].colIndex, selCells[selCells.length - 1].rowIndex, selCells[selCells.length - 1].colIndex);
            if (this.model.allowSelection && (this.XLSelection._isOutsideBordering || this.XLSelection._isGridBordering))
                !(this._borderStyles.indexOf(args.ID) > -1) && (args.ID.indexOf("bordercolor") < 0) && (this.XLSelection._isOutsideBordering = this.XLSelection._isGridBordering = false);
            else
                this.setBorder({ "type": args.ID, "color": hexcode, "style": this._borderStyle }, alphRange);
            if (target.className.indexOf("back") > -1 || target.parentNode.className === 'e-bordercell')
                $('#' + this._id + '_bordercontainer').hide();
        },

        _getTableID: function (classname, name) {
            var i, tmgr = this.getSheet(this.getActiveSheetIndex()).tableManager;
            if (name) {
                for (i in tmgr)
                    if (name === tmgr[i].name)
                        return Number(i);
            }
            else {
                for (i in tmgr) {
                    if (classname.indexOf('e-table' + i) > -1)
                        return Number(i);
                }
            }
        },

        _cellStyleClick: function (e) {
            var elem, range = this.model.sheets[this.getActiveSheetIndex()].selectedRange, cname = e.target.className, innerHtml = e.target.innerHTML, formatstr = this.XLFormat.getFormatClass(cname), container = this._dataContainer;
            var details = { range: range, sheetIndex: this.getActiveSheetIndex(), reqType: "cell-styles", opr: e.target.innerHTML, beforeFormat: this.getRangeData({ range: range, property: ["format", "formats"] }) };
            if (cname.indexOf('e-cellstylecell') > -1 && ej.isNullOrUndefined(container.customCellStyle[innerHtml]))
                this.XLFormat.updateUniqueFormat(formatstr, range, e.target.innerHTML);
            if (cname.indexOf('e-cellstylecell') > -1 && !ej.isNullOrUndefined(container.customCellStyle[innerHtml])) {
                var formatObj = { style: container.customCellStyle[innerHtml].style }
                $.extend(formatObj, container.customCellStyle[innerHtml].NumFormat)
                this.XLFormat.format(formatObj);
            }
            if (cname.indexOf('e-cellstylecell') > -1 && innerHtml === this._getLocStr('NewCellStyle'))
                this._showDialog(this._id + "_CustomCellDialog");
            if (cname.indexOf('e-cellstylecell') > -1 || cname.indexOf("back") > -1)
                $('#' + this._id + '_Ribbon_Home_Styles_CellStyles').length && $('#' + this._id + '_Ribbon_Home_Styles_CellStyles').data("ejSplitButton")._hidePopup();
            details.afterFormat = this.getRangeData({ range: range, property: ["format", "formats"] });
            if (!this.isUndoRedo) {
                this._completeAction(details);
                this._trigActionComplete(details);
            }
            if (this.model.showRibbon)
                this.XLRibbon._updateRibbonIcons();
        },

        _mouseHoverHandler: function (e) {
            var trgt = e.target, cellIdx;
			if(e.target.localName == "svg" || e.target.localName === "rect" || e.target.localName === "path")
				return;
            if (this._hasClass(e.target, "e-viewhdrlbl") || this._hasClass(e.target, "e-vheading"))
                this.element.find(".e-vheading .e-chk-act, .e-vheading .e-chk-inact").addClass("e-chkhover");
            else if (this._hasClass(e.target, "e-viewlinlbl") || this._hasClass(e.target, "e-vgridlines"))
                this.element.find(".e-vgridlines .e-chk-act, .e-vgridlines .e-chk-inact").addClass("e-chkhover")
            else if (this.model.allowDragAndDrop && this.XLDragDrop._allowDragAndDrop && ($(e.target).parents('.e-vscrollbar').length > 0 || e.target.className.indexOf('e-rowheader') > -1 || $(e.target).parents('.e-spreadsheetfooter').length > 0 ||
                    e.target.className.indexOf('e-headercell') > -1 || e.target.className.indexOf('e-spreadsheetfooter') > -1 || $(e.target).parents('.e-hscrollbar').length > 0 || (this.getSheet()._isFreezed && e.target.className.indexOf('e-rowcell') > -1)))
                this.XLDragDrop._scrollHover(e);
            else if (this._hasClass(e.target, "e-rowcell")) {
                cellIdx = this._getCellIdx(trgt);
                this._trigger("cellHover", { target: trgt, event: e, cellIndex: cellIdx });
            }
        },

        _mouseDownHandler: function (e) {
            var x, y, lmt, tid, obj, cell, elem, cname, tname, cellIdx, trgtCell, isNavigate = true, imgNavigate = true, sparkline = "e-ss-sparkline", str = "e-ss-object", pvt = "e-ss-pivot",
                trgt = e.target, $trgt = $(trgt), sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx),
                sheetElem = this.getSheetElement(sheetIdx), robj = $('#' + this._id + '_Ribbon').data('ejRibbon');
            e.currentTarget.className.indexOf("e-ribbon") < 0 && this.element.find(".e-bordercontainer").hide();
            if (this.element.find("#" + this._id + "ddl_popup").has(trgt).length)
                return false;
            this._isTouchEvt = this._isTouchEvent(e);
            if (this._isTouchEvt) {
                this._touchArgs = e;
                this._startXY = this._setXY(e, navigator.userAgent.indexOf("WebKit") > -1);
                if (this.model.allowDragAndDrop)
                    this.XLDragDrop._dragtouch(this._startXY[0], this._startXY[1]);
                if (!this._hasClass(trgt, "e-autofill") && this.model.allowAutoFill) {
                    lmt = (this._hasClass(trgt, "e-headercell")) ? 10 : 20;
                    x = this._setXY(e), y = x[1], x = x[0];
                    x = Math.abs(x - this.getAutoFillElem().offset().left);
                    y = Math.abs(y - this.getAutoFillElem().offset().top);
                    if (x <= lmt && x >= 0 && y <= lmt && y >= 0) {
                        $trgt = this.getAutoFillElem();
                        trgt = e.target = $trgt[0];
                    }
                }
            }
            if ($trgt.parents(".e-ribbon").length || $trgt.parents(".e-vscroll").length || $trgt.parents(".e-hscroll").length) {
                if (this._excelFilter) {
                    this.XLFilter._isSearchEdit = false;
                    this._excelFilter.closeXFDialog();
                }
            }
            else if (this._hasClass(trgt, "e-ssddl"))
                this._ddlopen(e);
            else {
                e.target = this._changeTargetWithOffset(e);
                if (this.model.allowCharts && sheet._isChartBorderDrawn)
                    this.XLChart._clearChartRange(this._arrayAsString(this._chartBorder));
                if(this.model.allowSparkline && sheet._isSparklineBorder)
                    this.XLSparkline._clearSparkline(this._arrayAsString(this._chartBorder))

                if ((this.model.pictureSettings.allowPictures || this.model.allowCharts) && ($trgt.hasClass(str) || $($trgt).parents("." + str).length)) {
                    if (!$trgt.hasClass(str))
                        trgt = e.target = $($trgt).parents("." + str)[0];
                    this.XLShape._shapeMouseDown(e);
                }
                 else  if (( this.model.allowSparkline) && ($trgt.hasClass(sparkline) || $($trgt).parents("." + sparkline).length)) {
                    if (!$trgt.hasClass(sparkline))
						imgNavigate = false;
                    if(trgt.localName == "svg" || trgt.localName == "rect" || trgt.localName == "path") 
						this.sparkDiv = $($trgt).parents("." + sparkline)[0] || $trgt[0];
					var sparkRc =this._getCellIdx($(this.sparkDiv).closest("td")[0]), sparkline, sparklineObj, range, sparklineProp;
					// click sparkline
					if (this.model.showRibbon &&  this.model.allowSparkline && (this.sparkDiv.id.indexOf("Line") > -1 ||  this.sparkDiv.id.indexOf("Area") > -1 ||  this.sparkDiv.id.indexOf("Pie") > -1 ||  this.sparkDiv.id.indexOf("Column") > -1 ||  this.sparkDiv.id.indexOf("Winloss") > -1))
					   this.XLSparkline._sparklineDesignTabUpdate(this.sparkDiv.id);
					else if (this.model.showRibbon && this.model.allowSparkline && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("sparklinedesign") || robj.isVisible(this._getLocStr("SPARKLINEDESIGN"))))
						this.XLSparkline._toggleSparklineDesignTab();
					trgt = e.target = this.sparkDiv;
					//Prevent the Drag and Drop support
					//this.XLShape._shapeMouseDown(e);
                    this.performSelection({rowIndex: sparkRc.rowIndex, colIndex: sparkRc.colIndex},{rowIndex: sparkRc.rowIndex, colIndex: sparkRc.colIndex});
					this.XLShape._shapeType = "sparkline";
					sparkline = this.getSheet(this.getActiveSheetIndex()).shapeMngr.sparkline;
					sparklineObj = this.getObjectKeys(sparkline);
					for (var i = 0, len = sparklineObj.length; i < len; i++) {
						if(sparklineObj[i] == trgt.id) {
							sparklineProp = sparkline[sparklineObj[i]];
							range = this.getRangeIndices(sparklineProp.DataRange);
							this.XLSelection._focusBorder({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] }, ["e-bcborderright","e-bcborderbottom"]);
							this.getSheet(this.getActiveSheetIndex())._isSparklineBorder = true;
						}
					}
				}
                else {
                    imgNavigate = false;
                    if (!this.XLShape._shapeROStart || !this.XLShape._shapeRSStart)
                        this._getContent(sheetIdx).find(".e-ss-activeimg").removeClass("e-ss-activeimg e-ss-imgcresize e-ss-imgrresize");
                }
                if (trgt.nodeName === "TD" || trgt.nodeName === "TH")
                    this.XLRibbon._isPanelVisible = false;
                if (this.model.enablePivotTable) {
                    if (this._isPvtNameEdit) {
                        this._isPvtNameEdit = false;
                        this.XLPivot._changePvtName();
                    }
                    if ($trgt.hasClass(pvt) || $trgt.parents("." + pvt).length) {
                        if (!$trgt.hasClass(pvt))
                            trgt = e.target = $trgt.parents("." + pvt)[0];
                        this.XLPivot._pivotMouseDown(e);
                    }
                    else if (!($trgt.parents(".e-ss-pivotfield").length || $trgt.hasClass("e-ss-pivotfield")) && !($trgt.hasClass("e-vhandle") || $trgt.hasClass("e-hhandle")) && $trgt.css("cursor") !== "col-resize") {
                        this.hideActivationPanel();
                        this.getSheetElement(sheetIdx).find(".e-ss-activepivot").removeClass("e-ss-activepivot");
                    }
                }
                cname = trgt.className;
                if (trgt.id.indexOf("picture") === -1) {
                    if (this.model.showRibbon && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("format") || robj.isVisible(this._getLocStr("FORMAT"))))
                        this.XLRibbon._toggleFormatTab();
                }
                //Click the Chart
                if (this.model.showRibbon && trgt.id.indexOf("chart") > -1)
                    this.XLRibbon._chartDesignTabUpdate($(trgt));
                else if (this.model.showRibbon && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("cdesign") || robj.isVisible(this._getLocStr("CHARTDESIGN"))))
                    this.XLRibbon._toggleChartDesignTab();
                 //Click the Sparkline
               if (this.model.showRibbon && this.model.allowSparkline && (trgt.id.indexOf("Line") > -1 ||  trgt.id.indexOf("Area") > -1 ||  trgt.id.indexOf("Pie") > -1 ||  trgt.id.indexOf("Column") > -1 ||  trgt.id.indexOf("Winloss") > -1))
                    this.XLSparkline._sparklineDesignTabUpdate(this.sparkDiv.id);
                else if (this.model.showRibbon  && this.model.allowSparkline && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("sparklinedesign") || robj.isVisible(this._getLocStr("SPARKLINEDESIGN"))))
                    this.XLSparkline._toggleSparklineDesignTab();
                if (this.XLEdit._isEdit && trgt.nodeName != "TD" && !(this._hasClass(trgt, "e-autofill")))
                    return;
                if (this.model.allowDragAndDrop && this.XLDragDrop._isDragAndDropStart && (cname !== "e-autofill" && cname.indexOf("e-filterspan") < 0))
                    this.XLDragDrop._dMouseDown(e);
                if (this.model.allowResizing && !this.XLEdit._isEdit) {
                    if ($(trgt).hasClass("e-headercelldiv") || $(trgt).hasClass("e-headercell"))
                        this.XLResize._headerMouseDown(e);
                    else if ($(trgt).hasClass("e-rowheader"))
                        this.XLResize._rowMouseDown(e);
                    else if ($(trgt).hasClass("e-spreadsheetactpanel") || $(trgt).parents(".e-spreadsheetactpanel").length)
                        this.XLResize._apMouseDown(e);
                }
                if ($(trgt).parents("div.e-spreadsheetactpanel").length > 0)
                    return;
                if (this.model.allowEditing && this.XLEdit._isEdit && this.XLEdit._editElem.html() === "=") {
                    this._isFormulaSuggestion = false;
                    this.XLEdit._isFormulaEdit = true;
                }
                isNavigate = this.XLEdit._isEdit ? (this._isFormulaSuggestion || !this.XLEdit._isFormulaEdit) && this.XLEdit.saveCell() : true;
                if (!isNavigate && !this.XLEdit._isFormulaEdit)
                    return false;
                //Comment
                if (this.model.allowComments && !$trgt.hasClass("e-pager") && this.getSheetElement(sheetIdx).find(".e-commentcell").length)
                    this.XLComment._commentMouseDownHandler(e);
                if ((trgt.tagName === "SPAN" || trgt.tagName === "A") && (!ej.isNullOrUndefined($trgt.parent("td")[0]))) {
                    cell = $trgt.parent("td")[0];
                    obj = this._getCellIdx(cell);
                }
                else if (trgt.tagName === "TD" && this._hasClass(trgt, "e-rowcell")) {
                    cell = trgt;
                    obj = this._getCellIdx(cell);
                    if (this.model.showRibbon)
                        this.XLRibbon.updateRibbonIcons();
                }
                else
                    obj = this.getActiveCell();
                if (trgt.tagName === "A") {
                    sheet._activeCell = obj;
                    if (this.model.allowSelection) {
                        this.XLSelection.selectRange(obj, obj);
                        this.XLDragFill.positionAutoFillElement();
                    }
                    if (e.which !== 3)
                        this._hlClick(this.XLEdit.getPropertyValue(obj.rowIndex, obj.colIndex, "hyperlink", sheetIdx));
                }
                else if ((e.button !== 2 || e.which !== 3) || this.getSheetElement(sheetIdx).find(".e-selected, .e-colselected .e-headercelldiv, .e-rowselected").index(trgt) === -1) { // for context menu behavior                          
                    if (this.model.allowSelection && !imgNavigate) {
                        if (ej.isNullOrUndefined(this.XLDragDrop) || !this.XLDragDrop._allowDragAndDrop) {
                            if (!(this.XLResize && this.XLResize._resizeStart) && !$trgt.hasClass("e-comment-txtarea") && !($trgt.hasClass(pvt) || $($trgt).parents("." + pvt).length))
                                this.XLSelection._selectionMouseDownHandler(e);
                        }
                    }
                }
                this._filterClose(e.target);
                this._undoInputobj = {};
                if (trgt.tagName === "TD" && $(trgt).parents("div")[0].className === "e-content")
                    this.displayActivationPanel(this.XLEdit.getPropertyValue(obj.rowIndex, obj.colIndex, "range"));
                if ((trgt.tagName === "TD") && trgt.className.indexOf("e-rowheader") < 0) {
                    if (!ej.isNullOrUndefined(this._ddlCell)) {
                        this.element.find("#" + this._id + "ddl").ejDropDownList("hidePopup");
                        this.element.find("#" + this._id + "ddlspan").remove();
                        this._ddlCell = null;
                    }
                }
                if (trgt.tagName === "TD" && this._hasClass(trgt, "e-rowcell")) {
                    trgtCell = this._getCellIdx(trgt);
                    if (!ej.isNullOrUndefined(this.XLEdit.getPropertyValue(trgtCell.rowIndex, trgtCell.colIndex, "rule", sheetIdx)))
                        this._setddlCell(e);
                }
                 //Click the Sparkline
                 if(this.model.showRibbon && this.model.allowSparkline && trgt.id.indexOf("sparkline") > -1)
                    this.XLSparkline._sparklineDesignTabUpdate(this.sparkDiv.id);
                //Table Rename
                if (this._isTableRename) {
                    this.XLFormat._renameTable(this._tableClassName);
                    this._isTableRename = false;
                }
                //Sheet Rename
                if (this._isSheetRename)
                    this._updateSheetNames(null, false);
                this.element.find("#" + this._id + "ddl").ejDropDownList("hidePopup");
                if (this._hasClass(trgt, "e-rowcell"))
                    tname = this.XLEdit.getPropertyValue(obj.rowIndex, obj.colIndex, "tableName", sheetIdx);
                if (tname) {
                    tid = this._getTableID(tname);
                    if (this.isNumber(tid))
                        this.XLRibbon._designTabUpdate(tid, obj);
                }
                else if (this.model.showRibbon && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("design") || robj.isVisible(this._getLocStr("Design"))))
                    this.XLRibbon._toggleDesignTab(obj);
                if (this.model.allowEditing) {
                    cell = sheet._activeCell;
                    if (this.XLEdit._isEdit && e.target.id !== this._id + "_inputbox") {
                        elem = ($(e.target).hasClass("e-ss-input") || !this.XLEdit._isFBarFocused) ? this.element.find("#" + this._id + "_Edit") : this._getInputBox();
                        if (elem) {
                            if (e.target.id !== elem[0].id)
                                elem.focus().setInputPos(elem[0].selectionStart, elem[0].selectionEnd);
                            if (elem.hasClass("e-ss-input"))
                                this.XLEdit._isFBarFocused = false;
                        }
                    }
                    if (!(this.model.allowComments && this.XLComment._isCommentEdit) && !this._isSheetRename && e.target.id === this._id + "_inputbox") {
                        if (e.target.readOnly)
                            this.setSheetFocus();
                        else {
                            if (!this.XLEdit._isEdit)
                                this.XLEdit.editCell(cell.rowIndex, cell.colIndex, true);
                            this._getInputBox().focus();
                            this.XLEdit._isFBarFocused = true;
                        }
                    }
                }
            }
        },

        // Dropdownlist list validation
        _renderDDownList: function () {
            this.element.append(ej.buildTag("input.e-" + this._id + "-ddl", "", "", { id: this._id + "ddl", style: "display:none" }));
            $("#" + this._id + "ddl").ejDropDownList({
                fields: { id: "Types", text: "text", value: "text" },
                beforePopupShown: $.proxy(this._drppopupshow, this),
                cssClass: "e-" + this._id + "-ddl e-ss-ddlwrap",
                width: 0.1,
                height: 0.1,
                change: $.proxy(this._changeddl, this)
            });
            $(document.body).append($('#' + this._id + 'ddl_popup_wrapper'));
        },

        _setddlCell: function (e) {
            var i, elepos, len, range, value = [], value2 = [], listdatsrc = [], check, customvalue, cell, trgt, sheetIdx = this.getActiveSheetIndex(), pos, spanElem, calcNamedRanges = this.getCalcEngine().getNamedRanges(), isNamedRange;
            if (!ej.isNullOrUndefined(e) && e.type === "mousedown") {
                cell = this._getCellIdx(e.target);
                trgt = e.currentTarget;
            }
            else {
                cell = this.getActiveCell();
                trgt = $("#" + this._id + "GroupPanel").find("div.e-content")[0];
            }
            customvalue = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "rule", sheetIdx);
            if (!customvalue)
                return;
            check = customvalue.customVal.split("_");
            if (customvalue && check[1] === "list") {
                this._ddlCell = cell;
                var dataSrc = check[0], i, len, values = [];
                if (dataSrc.startsWith("=") && dataSrc.indexOf(",") < 0) {
                    var value = $.trim(dataSrc.replace("=", "")), splitStr;
                    isNamedRange = calcNamedRanges.getItem(value.toUpperCase());
                    if (isNamedRange)
                        value = isNamedRange;
                    if (value.indexOf("!") > -1) {
                        splitStr = value.split("!");
                        sheetIdx = isNamedRange ? this._getSheetIdxFromSheetValue(splitStr[0]) : this._getSheetIndexByName(splitStr[0]);
                        value = splitStr[1];
                    }
                    value.indexOf("$") > -1 && (value = value.split("$").join(""));
                    value.indexOf(":") < 0 && (value = value + ":" + value);
                    range = this.getRangeIndices(value);
                    var cells = this._getMultiRangeCells(range);
                    var contValue = this.getRangeData({ range: [cells[0].rowIndex, cells[0].colIndex, cells[cells.length - 1].rowIndex, cells[cells.length - 1].colIndex], property: ["value", "value2"], sheetIdx: sheetIdx });
                    for (i = 0, len = contValue.length; i < len; i++) {
                        if (!ej.isNullOrUndefined(contValue[i].value) && !ej.isNullOrUndefined(contValue[i].value2)) {
                            values.push(contValue[i].value);
                            value2.push(contValue[i].value2);
                        }
                        else {
                            values.push("");
                            value2.push("");
                        }
                    }
                    if (!values.length) {
                        values.push(dataSrc);
                        value2.push(dataSrc);
                    }
                }
                else if (dataSrc.indexOf(",") > -1)
                    value2 = values = dataSrc.split(",");
                else {
                    values = [];
                    values.push(dataSrc);
                    value2.push(dataSrc);
                }
                for (i = 0, len = values.length; i < len; i++)
                    listdatsrc[i] = { id: i + 1, text: value2[i], value: values[i] };
                cell = this.getCell(cell.rowIndex, cell.colIndex);
				if(cell) {
                elepos = { "top": cell[0].offsetTop, "left": cell[0].offsetLeft };
                trgt.insertAdjacentHTML("beforeEnd", "<span id='" + this._id + "ddlspan' class='e-icon e-ssddl e-spanddl e-ddlspan' role='button'></span>");
                spanElem = $("#" + this._id + "ddlspan");
                pos = cell.height() - (spanElem.height() + 3);
                spanElem.css({ top: elepos.top + pos, left: elepos.left + cell.width() + 3 });
                $("#" + this._id + "ddl").ejDropDownList("option", "dataSource", listdatsrc);
				}
            }
        },

        _drppopupshow: function () {
            if (this._ddlCell) {
                var cell = this.getCell(this._ddlCell.rowIndex, this._ddlCell.colIndex);
                $("#" + this._id + "ddl_popup").css({ "width": this.getActiveCellElem().width() + 20, "font-size": "11", top: cell.position().top, left: cell.position().left });
            }
        },

        _ddlPosition: function () {
            if (this._ddlCell) {
                var spanElem, cell = this.getCell(this._ddlCell.rowIndex, this._ddlCell.colIndex), elepos = { "top": cell[0].offsetTop, "left": cell[0].offsetLeft };
                spanElem = $("#" + this._id + "ddlspan");
                spanElem.css({ top: elepos.top + cell.height() - (spanElem.height() + 3), left: elepos.left + cell.width() + 3 });
            }
        },

        _changeddl: function (args) {
            if (this._ddlCell && this.model.allowEditing) {
                var actCell = this.getActiveCell(), selVal = args.model.dataSource[args.itemId].value, pValue = this.XLEdit.getPropertyValue(actCell.rowIndex, actCell.colIndex);
                this.XLEdit._updateCellValue(actCell, selVal);
                this.getActiveCellElem().hasClass("e-hlcell") && this.XLValidate.highlightInvalidData();
                this._trigrDdlActnCmplt(selVal, pValue, args.itemId);
                if (this.model.allowFormulaBar)
                    this.updateFormulaBar();
            }
        },

        _trigrDdlActnCmplt: function (selVal, pValue, ddlSIdx) {
            if (this.model.actionComplete === null)
                return;
            var refrSheetIdx, refrRange, range, actCell = this.getActiveCell(), sheetIdx = this.getActiveSheetIndex(), valRule, args, dtSrcRef, addr, rangeData;
            valRule = this.XLEdit.getPropertyValue(actCell.rowIndex, actCell.colIndex, "rule", sheetIdx);
            args = { reqType: "edit", sheetIndex: sheetIdx, currValue: selVal, prevValue: pValue, rowIndex: actCell.rowIndex, colIndex: actCell.colIndex, hasValidation: true, rule: valRule, isRefreshVal: false, isDropDownAction: true };
            if (valRule.type == "list" && selVal !== "") {
                dtSrcRef = valRule.customVal.split("_")[0];
                if (dtSrcRef[0] == "=" && dtSrcRef.indexOf(",") < 0) {
                    args.isRefrsVal = true;
                    dtSrcRef = dtSrcRef.replace("=", "");
                    addr = dtSrcRef.split("!");
                    args.refrValSheetIdx = refrSheetIdx = addr.length == 1 ? sheetIdx : this._getSheetIndexByName(addr[0]);
                    refrRange = addr.length == 1 ? addr[0] : addr[1];
                    refrRange.indexOf("$") > -1 && (refrRange = refrRange.replace(/\$/g, ""));
                    range = this.getRangeIndices(refrRange);
                    if (this.isUndefined(ddlSIdx)) {
                        rangeData = this.getRangeData({ range: range });
                        for (idx in rangeData)
                            if (rangeData[idx].value == selVal)
                                ddlSIdx = parseInt(idx);
                    }
                    if (range[0] === range[2])
                        args.refrValCellAddr = this.getAlphaRange(range[0], range[1] + ddlSIdx);
                    else
                        args.refrValCellAddr = this.getAlphaRange(range[0] + ddlSIdx, range[1]);
                }
            }
            this._trigActionComplete(args);
        },

        _ddlopen: function (e) {
            var sheetIdx = this.getActiveSheetIndex(), actCell = this.getActiveCell(sheetIdx), rowHt = this.getSheet(sheetIdx).rowsHeightCollection[actCell.rowIndex], position;
            if (this.XLEdit._isEdit && this.XLEdit.getPropertyValue(actCell.rowIndex, actCell.colIndex, "rule").customVal.split("_")[2] === "true")
                return false;
            this.XLEdit.saveCell();
            var actionObj = $("#" + this._id + "ddl").data("ejDropDownList"), cell = this.getCell(this._ddlCell.rowIndex, this._ddlCell.colIndex);
            e.stopPropagation();
            if (!ej.isNullOrUndefined(actionObj)) {
                if (actionObj._isPopupShown()) {
                    actionObj._hideResult();
                }
                else {
                    actionObj._showResult();
                    $("#" + this._id + "ddl_popup").css({ "width": this.getActiveCellElem().width() + 20, "font-size": "11", top: 20, left: 100 });
                    var position = this._getXYPos(cell, $("#" + this._id + "ddl_popup"), rowHt, 0);
                    $("#" + this._id + "ddl_popup_list_wrapper").css({ top: position.yPos + rowHt, left: position.xPos });
                }
            }
        },

        _mouseMoveHandler: function (e) {
            e.target = this._changeTargetWithOffset(e);
            var trgt = $(e.target), xy, clientDiff;
            this._isTouchEvt = this._isTouchEvent(e);
            if (this._isTouchEvt) {
                e.preventDefault();
                xy = this._setXY(e, navigator.userAgent.indexOf("WebKit") > -1);
                if (this.model.allowDragAndDrop)
                    this.XLDragDrop._dragtouch(xy[0], xy[1]);
            }
            if (this.model.allowResizing && (this.XLResize._resizeType === "Col" || trgt.hasClass("e-headercelldiv") || trgt.hasClass("e-headercell") || trgt.hasClass("e-reSizeColbg")) && !this.XLEdit._isEdit && !(this.XLCMenu && this.XLCMenu._isMenuOpened))
                this.XLResize._cMouseMove(e);
            else if (this.model.allowResizing && (this.XLResize._resizeType === "Row" || trgt.hasClass("e-rowheader") || trgt.hasClass("e-reSizeRowbg")) && !this.XLEdit._isEdit && !(this.XLCMenu && this.XLCMenu._isMenuOpened))
                this.XLResize._rMouseMove(e);
            else if (this.model.allowResizing && (this.XLResize._resizeType === "AP" || trgt.hasClass("e-spreadsheetactpanel") || trgt.parents(".e-spreadsheetactpanel").length > 0))
                this.XLResize._apMouseMove(e);
            else if ((this.model.pictureSettings.allowPictures || this.model.allowCharts) && (trgt.hasClass("e-ss-object") || trgt.parents(".e-ss-object").length || this.XLShape._shapeROStart || this.XLShape._shapeRSStart || trgt.hasClass("e-ss-imgvisual")))
                this.XLShape._imgMouseMove(e);
            if (this.model.allowSelection && this.model.allowDragAndDrop && ej.spreadsheetFeatures.dragAndDrop && trgt.parents(".e-spreadsheetmainpanel").length && trgt.hasClass("e-rowcell") && !this.XLEdit._isEdit && this._getJSSheetHeader(this.getActiveSheetIndex())[0].querySelector('.e-spreadsheetcolumnheader').className.indexOf('e-sheetselected') === -1)
                this.XLDragDrop._dMouseMove(e);
            if (this.model.allowComments && !this.XLComment._isCommentEdit && (this.getSheetElement(this.getActiveSheetIndex()).find(".e-commentcell").length > 0))
                this.XLComment._commentMouseMove(e);
            if (!ej.isNullOrUndefined(e.target.parentNode))
                ((e.target.id.indexOf('_svg') < 0) && this._isString(e.target.parentNode.className) && e.target.parentNode.className.indexOf('e-content') < 0 && !$(e.target).is('td.e-rowcell')) && this.XLShape._shapeMouseUp(e);
            if (this._isTouchEvt && !this._isSelected(e.target) && !this._isTouchMoveSel && this._touchArgs && !this._isUniqueTarget(this._touchArgs, e) && trgt.parents(".e-table").length && trgt.parents(".e-spreadsheetcontentcontainer").length && !this.XLDragDrop._allowDragAndDrop) {
                clientDiff = this._getClientDiff(this._startXY, xy);
                this._scrollContent(clientDiff);
                this._startXY = xy;
                this._touchArgs = e;
                this._isTouchScroll = true;
            }
        },

        _mouseLeaveHandler: function (e) {
            if (this._hasClass(e.target, "e-viewhdrlbl") || this._hasClass(e.target, "e-vheading"))
                this.element.find(".e-vheading .e-chk-act, .e-vheading .e-chk-inact").removeClass("e-chkhover");
            else if (this._hasClass(e.target, "e-viewlinlbl") || this._hasClass(e.target, "e-vgridlines"))
                this.element.find(".e-vgridlines .e-chk-act,.e-vgridlines .e-chk-inact").removeClass("e-chkhover");
            else if (this.model.allowResizing)
                $(".e-ss-colresize, .e-ss-rowresize").removeClass("e-ss-colresize e-ss-rowresize");
        },

        _mouseUpHandler: function (e) {
            var trgt = $(e.target), sheetIdx = this.getActiveSheetIndex(), vScroll = this.XLScroll._vScroller(sheetIdx), hScroll = this.XLScroll._hScroller(sheetIdx);
            if (this.model.allowResizing) {
                if (this.XLResize._resizeType === "Col")
                    this.XLResize._cMouseUp(e);
                else if (this.XLResize._resizeType === "Row")
                    this.XLResize._rMouseUp(e);
                else if (this.XLResize._resizeType === "AP")
                    this.XLResize._apMouseUp(e);
            }
			if(this.model.showRibbon && !this._phoneMode) {
				if (this.element.find('.e-ribbonpin').is(':visible') && $(e.target).parents('.e-ribbon').length <= 0)
					$("#" + this._id + "_Ribbon").ejRibbon("collapse");
			}
            if (this.model.allowDragAndDrop && this.XLDragDrop._allowDragAndDrop)
                this.XLDragDrop._dMouseUp(e);
            if (this.model.allowComments && this.XLComment._isCommentEdit)
                this.getActiveCellElem().find("textarea").focus();
            if (this._isSheetRename)
                $("#" + this._id + "_Sheet_RenamePanel").focus();
            if (this.model.pictureSettings.allowPictures)
                this.XLShape._shapeMouseUp(e);
            if (this.model.enablePivotTable)
                this.XLPivot._pivotMouseUp(e);
            if (this.XLEdit._isEdit && trgt[0].id !== this.XLEdit._editElem[0].id && trgt[0].id !== this._id + "_inputbox" )
                this.XLEdit._editElem.setCursorPosition((this._browserDetails.version === "8.0") ? document.selection.anchorOffset : window.getSelection().anchorOffset);
            if (this._hasClass(trgt[0], "e-vhandle") || this._hasClass(trgt[0], "e-vhandlespace") || this._hasClass(trgt[0], "e-vup") || this._hasClass(trgt[0], "e-vdown")) {
                if (this._trigger("scrollStop", { scrollData: vScroll._scrollData, position: vScroll.model.value, reqType: "vertical" }));
                return;
            }
            if (this._hasClass(trgt[0], "e-hhandle") || this._hasClass(trgt[0], "e-hhandlespace") || this._hasClass(trgt[0], "e-hdown") || this._hasClass(trgt[0], "e-hup")) {
                if (this._trigger("scrollStop", { scrollData: vScroll._scrollData, position: hScroll.model.value, reqType: "horizontal" }));
                return;
            }
        },

        _scrollContent: function (clientPos, isActPos) {
            var diff, scroll, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx);
            if (clientPos.x) {
                diff = (isActPos) ? clientPos.x : sheet._scrollLeft + clientPos.x;
                scroll = this.XLScroll._hScroller(sheetIdx);
                if (diff < 0)
                    diff = 0;
                else {
                    if (this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal) {
                        if (clientPos.x > 0 && scroll.model.maximum < diff + scroll._scrollData.handle)
                            diff = scroll.model.maximum;
                    }
                    else
                        scroll._scrollData.step = clientPos.x < 0 ? -1 : 1;
                }
                if (sheet._scrollLeft != diff)
                    scroll.scroll(diff);
            }
            if (clientPos.y) {
                diff = (isActPos) ? clientPos.y : sheet._scrollTop + clientPos.y;
                scroll = this.XLScroll._vScroller(sheetIdx);
                if (diff < 0)
                    diff = 0;
                else {
                    if (this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal) {
                        if (clientPos.y > 0 && scroll.model.maximum < diff)
                            diff = scroll.model.maximum;
                    }
                    else
                        scroll._scrollData.step = clientPos.y < 0 ? -1 : 1;
                }
                if (diff || (sheet._scrollTop != diff))
                    scroll.scroll(diff);
            }
        },

        _keyDownHandler: function (e) {
            var tid, cname, text, tname, trange, actElemId, editText, isNavigate = true, imgNavigate = false, sheetIdx = this.getActiveSheetIndex(), aComplete = this.element.find("#" + this._id + "_AutoComplete").data("ejAutocomplete"),
                robj = $('#' + this._id + '_Ribbon').data('ejRibbon'), activeCell = this.getSheet(sheetIdx)._activeCell;
            if (this._trigger("keyDown", { event: e, isEdit: this.model.allowEditing && this.XLEdit._isEdit, isCommentEdit: this.model.allowComments && this.XLComment._isCommentEdit, isSheetRename: this._isSheetRename, sheetIndex: this._getSheetIndex() }))
                return;
            if (this._getContent(sheetIdx).find(".e-ss-activeimg").length) {
                if ($(e.target).hasClass("e-numerictextbox") && e.keyCode === 13)
                    e.preventDefault();
                imgNavigate = true;
                actElemId = document.activeElement.id;
                actElemId.indexOf(this._id + "_Ribbon_Format_Size_PictureHeight") < 0 && actElemId.indexOf(this._id + "_Ribbon_Format_Size_PictureWidth") < 0 && this.XLShape._imgKeyDown(e);
            }
            if(navigator.platform.toLowerCase().indexOf('mac') > -1 && e.metaKey){
                if(e.keyCode == 67)
                    this.XLClipboard.copy();
                else if(e.keyCode == 86)
                    this.XLClipboard.paste();
                else if(e.keyCode == 88)
                    this.XLClipboard.cut();
                return;
            }
            if (aComplete.showSuggestionBox && aComplete.suggestionList) {
                if (e.keyCode === 38) {
                    aComplete._removeListHover();
                    if (aComplete._activeItem > 1)
                        aComplete._activeItem = aComplete._activeItem - 1;
                    else
                        aComplete._activeItem = aComplete._listSize;
                    aComplete._addListHover();
                    aComplete._targetFocus();
                    return;
                }
                else if (e.keyCode === 40) {
                    aComplete._removeListHover();
                    if (aComplete._activeItem < aComplete._listSize)
                        aComplete._activeItem = aComplete._activeItem + 1;
                    else
                        aComplete._activeItem = 1;
                    aComplete._addListHover();
                    return;
                }
            }
            if (e.target.id.indexOf("_Edit") > -1)
                this.model.allowKeyboardNavigation && (this.XLCellNav._canKeyBoardNavigate = true);
            if (this.XLEdit._editElem)
                editText = this.XLEdit._editElem.text();
            if (e.target.id.indexOf("_Edit") > -1 && e.keyCode === 9 && editText.indexOf("=") === 0 && editText.indexOf(")") != editText.length - 1) {
                e.preventDefault();
                if (!aComplete.suggestionList.is(":visible") && this.model.allowKeyboardNavigation) {
                    if (this._isFormulaSuggestion && (e.keyCode === 39 || e.keyCode === 37 || (e.keyCode === 13 && !e.altKey)))
                        this.XLEdit.saveCell();
                    this.XLCellNav._selectionKeyDownHandler(e);
                    activeCell = this.getSheet(sheetIdx)._activeCell;
                    return;
                }
                text = aComplete.getActiveText();
                if (!this.XLEdit._isNamedRange(text))
                    text += "(";
                this.XLEdit._editElem.text(text);
                if (this.model.allowFormulaBar)
                    this._getInputBox().val(text);
                if (e.target.id.indexOf("_Edit") > -1)
                    this.XLEdit._editElem.focusEnd();
                this.XLCellNav._canKeyBoardNavigate = false;
                return;
            }
            if (this.XLEdit.getPropertyValue(activeCell.rowIndex, activeCell.colIndex, 'wrap') && this.XLEdit.getPropertyValue(activeCell.rowIndex, activeCell.colIndex, 'merge') && e.keyCode === 46) {
                this.getCell(activeCell.rowIndex, activeCell.colIndex, sheetIdx).find('#' + this._id + '_Merge')[0].textContent = "";
            }
            if (e.target.id.indexOf("_Custom") < 0 && e.target.id.indexOf("_Ribbon") < 0) {
                e.stopImmediatePropagation();
                if (this.model.allowFiltering && this.XLFilter._isSearchEdit && e.keyCode !== 27)
                    return true;
                if ($(e.target).parents(".e-formulabar").length && this.XLEdit._isEdit && this.model.allowKeyboardNavigation)
                    this.XLCellNav._isNavigate = e.keyCode === 13;
                !this._isSheetRename && !this.XLEdit._isEdit && !(this.XLComment && this.XLComment._isCommentEdit) && this.model.allowClipboard && this.XLClipboard._copyPasteHandler(e);
                if (!imgNavigate && !this._isSheetRename)
                    !(this.XLComment && this.XLComment._isCommentEdit) ? this.model.allowEditing && (document.activeElement.id.indexOf('_inputbox') === -1 || e.keyCode === 27) && this.XLEdit._editingHandler(e) : this.model.allowKeyboardNavigation && (this.XLCellNav._isNavigate = false);
                if (this._isFormulaSuggestion && (e.keyCode === 39 || e.keyCode === 37 || (e.keyCode === 13 && !e.altKey)))
                    this.XLEdit.saveCell();
                else if (!this.XLEdit._isFormulaEdit && (e.keyCode === 9 || (e.keyCode === 13 && !e.altKey) || e.keyCode === 37 || e.keyCode === 38 || e.keyCode === 39 || e.keyCode === 40))
                    isNavigate = this.XLEdit._isEdit && this.model.allowKeyboardNavigation && this.XLCellNav._isNavigate ? this.XLEdit.saveCell() : true;
                if ($(e.target).hasClass("e-field-validation-error") || (e.target.id == this._id + '_Ribbon_Home_Font_FontFamily_wrapper' || e.target.id == this._id + '_Ribbon_Home_Number_NumberFormat_wrapper' || e.target.id == this._id + '_Ribbon_Home_Font_FontSize_wrapper'))
                    return true;
                if (this.model.allowDataValidation && this.XLValidate._isErrorVisible && (e.keyCode === 37 || e.keyCode === 39 || e.keyCode === 38 || e.keyCode === 40)) {
                    this.XLValidate._isErrorVisible = false;
                    return true
                }
                if ((!isNavigate && !this.XLEdit._isFormulaEdit) || (e.keyCode === 13 && e.altKey))
                    return false;
                if (this.model.allowKeyboardNavigation && !imgNavigate && !this._isSheetRename) {
                    if (!(this.model.allowComments && this.XLComment._isCommentEdit))
                        if ((!$(e.target).parents(".e-formulabar").length || e.keyCode === 9 || (e.keyCode === 13 && !e.altKey))) {
						if(this.XLEdit._isFormulaEdit){
						    var clsSheet = this.XLEdit._editElem.closest(".e-sheet"), editSheetIdx = clsSheet.length && this._getSheetIdxFromSheetValue(clsSheet[0].id.replace(this._id + "_",""));
                            if (sheetIdx != editSheetIdx && (e.keyCode === 9 || (e.keyCode === 13))) {
                                this.XLSelection._clearBorder(this._formulaBorder.join(" ").replace(/,/g, " ") + " " + this._ctrlFormulaBorder.join(" ").replace(/,/g, " "));
                                this.gotoPage(editSheetIdx);
                            }
							}
                            this.XLCellNav._selectionKeyDownHandler(e);
                        }
                    activeCell = this.getSheet(sheetIdx)._activeCell;
                    this._keyboardShortCuts(e);
                }
                if (this.model.allowUndoRedo)
                    if (this.model.allowComments && !this.XLComment._isCommentEdit)
                        this._undoRedoOperation(e);
                    else if (!this.model.allowComments)
                        this._undoRedoOperation(e);
                if (this.XLEdit._isFormulaEdit && e.keyCode === 9 && !this.XLCellNav._canKeyBoardNavigate) // enabling tab key while selecting formula
                    this.XLCellNav._canKeyBoardNavigate = true;
            }
            if (e.target.id === this._id + "_Ribbon_Analyze_PivotTable_PivotTableName") {
                this._isPvtNameEdit = true;
                return true;
            }
            else if (this._isPvtNameEdit) {
                this._isPvtNameEdit = false;
                this.XLPivot._changePvtName();
            }
            if ((e.target.tagName === "DIV") && !this.XLEdit._isEdit) {
                if (!ej.isNullOrUndefined(this._ddlCell)) {
                    this.element.find("#" + this._id + "ddl").ejDropDownList("hidePopup");
                    this.element.find("#" + this._id + "ddlspan").remove();
                    this._ddlCell = null;
                }
            }
            tname = this.XLEdit.getPropertyValue(activeCell.rowIndex, activeCell.colIndex, "tableName", sheetIdx);
            if (e.target.id === this._id + "_Ribbon_Design_Properties_TableName") {
                this._isTableRename = true;
                this._tableClassName = this.XLEdit.getPropertyValue(activeCell.rowIndex, activeCell.colIndex, "tableName") || "";
                if (this._isTableRename && (e.keyCode === 13 || e.keyCode === 9 || e.keyCode === 27)) {
                    if (e.keyCode === 13)
                        e.preventDefault();
                    this.XLFormat._renameTable(this._tableClassName);
                }
                else
                    return;
            }
            if (tname && this._getContent(sheetIdx).find('.e-ss-activeimg').length === 0) {
                tid = this._getTableID(tname);
                this.isNumber(tid) && this.XLRibbon._designTabUpdate(tid, activeCell);
            }
            else if (this.model.showRibbon && (robj.model.selectedItemIndex === this.XLRibbon._getTabIndex("design") || robj.isVisible(this._getLocStr("Design"))))
                this.XLRibbon._toggleDesignTab(activeCell);
            if (!this.XLEdit._isEdit && !ej.isNullOrUndefined(this.XLEdit.getPropertyValue(activeCell.rowIndex, activeCell.colIndex, 'rule', sheetIdx)))
                this._setddlCell(e);

            if (this._isSheetRename && (e.keyCode === 13 || e.keyCode === 9 || e.keyCode === 27)) {
                e.preventDefault();
                this._updateSheetNames(null, e.keyCode === 27) && this.setSheetFocus();
            }
            if (aComplete.suggestionList.is(":visible") && (this.XLEdit._editElem.text() === "" || e.keyCode === 13))
                aComplete._hideResult();
            this.model.showRibbon && this.XLRibbon._updateRibbonIcons();
        },

        _keyUpHandler: function (e) {
            var formulatext = this.element.find("#" + this._id + "_Edit").text();
            if (this.model.allowEditing && this.XLEdit._isEdit) {
                if (formulatext.indexOf("=") > -1 && formulatext.length > 0 && formulatext.indexOf(")") == -1) {
                    if (!this.XLEdit._isFEdit)
                        this.XLCellNav._isNavigate = true;
                    if (e.keyCode !== 40 && e.keyCode !== 38 && formulatext.length > 1)
                        this.XLEdit._captureEditing(e);
                }
            }
            this._trigger("keyUp", { event: e, isEdit: this.model.allowEditing && this.XLEdit._isEdit, isCommentEdit: this.model.allowComments && this.XLComment._isCommentEdit, isSheetRename: this._isSheetRename, sheetIndex: this._getSheetIndex() });
        },

        _dblClickHandler: function (e) {
            var sheetCont, trgt, cellIdx, sheetIdx, sheet, mergeWrap;
            this.XLEdit._isFEdit = false;
            if (e.target.tagName === "A")
                return;
            if (this._hasClass(e.target, "e-numericitem")) {
                if (this.XLEdit && this.XLEdit._isEdit) {
                    if (this.getActiveCellElem().find(".e-error").length)
                        return;
                }
                if (!this._isSheetRename)
                    this._renameSheet();
            }
            else {
                if (e.target.id.indexOf("chart") > -1 || this._hasClass(e.target, "e-comment-txtarea") || this._hasClass(e.target, "e-filterspan") || $(e.target).parents(".e-ss-pivot").length)
                    return;
                sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx);
                e.target = this._changeTargetWithOffset(e);
                if (!this.model.allowEditing || !this.model.allowSelection)
                    return;
                if (this.XLSelection._isOutsideBordering || this.XLSelection._isGridBordering) {
                    sheetCont = this._getContent(sheetIdx).find("div:first-child");
                    sheetCont.addClass("e-ss-cursor");
                    sheetCont.removeClass("e-ss-drwbrdrcursor e-ss-drwbrdrgridcursor");
                    this.XLSelection.selectRange(sheet._startCell, sheet._endCell);
                    if (this.model.allowAutoFill)
                        this.XLDragFill.positionAutoFillElement();
                    this.XLSelection._isOutsideBordering = this.XLSelection._isGridBordering = false;
                    return;
                }
                if (!this.XLEdit._isEdit && ($(e.target).hasClass("e-rowcell") || $(e.target).parents("td").hasClass("e-rowcell")) && (!this._hasClass($(e.target), "e-readonly") && !$(e.target).hasClass("e-cellreadonly"))) {
                    var clkCellObj = this._clkCellObj;
                    if (this._isTouchEvt)
                        e.preventDefault();
                    if ($('.e-cdata').length)
                        $('.e-cutright, .e-cutbottom').removeClass('e-cutright e-cutbottom');
                    trgt = $(e.target);
                    if (trgt.closest("#" + this._id + "EditForm").length)
                        return;
                    if (e.target.id.length < 1)
                        cellIdx = this._getCellIdx(e.target);
                    else
                        cellIdx = this._getCellIdx($(e.target).parents('td')[0]);
                    if (clkCellObj.rowIndex == cellIdx.rowIndex && clkCellObj.colIndex == cellIdx.colIndex)
                        this.XLEdit.editCell(cellIdx.rowIndex, cellIdx.colIndex, true);
                }
                if (this.model.allowResizing && ($(e.target).hasClass("e-headercell") || $(e.target).hasClass("e-headercelldiv")) && ($(e.target).css("cursor") === "col-resize" || this._isTouchEvt)) {
                    if ($(e.target).hasClass("e-headercelldiv"))
                        e.target = e.target.parentNode;
                    this.XLResize._resizeToFitWidth(e);
                }
                if (this.model.allowResizing && ($(e.target).hasClass("e-ss-rowresize") || (this._isTouchEvt && $(e.target).hasClass("e-rowheader"))))
                    this.XLResize._resizeToFitHeight(e);
            }
        },

        _setAndSelectActiveCell: function (rowIndex, colIndex, scrollOpt) {
            this.setActiveCell(rowIndex, colIndex);
            this._selectActiveCell(rowIndex, colIndex, '', scrollOpt);
        },

        _selectActiveCell: function (rowIndex, colIndex, range, scrollOpt) {
            var sheetIdx = this.getActiveSheetIndex(), obj = range ? { rowIndex: range.rowIndex, colIndex: range.colIndex } : { rowIndex: rowIndex, colIndex: colIndex }, sheet = this.getSheet(sheetIdx);
            if (this.model.allowSelection && this.model.allowKeyboardNavigation && this.model.scrollSettings.allowScrolling) {
                if (this.XLEdit.getPropertyValue(rowIndex, colIndex, "mergeIdx")) {
                    sheet._activeCell = sheet._endCell = sheet._startCell = obj;
                    this.XLSelection._processBoundary();
                    sheet._activeCell = sheet._startCell;
                    this.XLSelection.selectRange(sheet._startCell, sheet._endCell);
                }
                else
                    this.XLSelection.selectRange(this._getAlphaRange(sheetIdx, rowIndex, colIndex, obj.rowIndex, obj.colIndex));
                if (this.model.allowAutoFill)
                    this.XLDragFill.positionAutoFillElement();
                switch (scrollOpt) {
                    case "Home":
				        this._scrollContent({ x: [range ? (range.colIndex * sheet.columnWidth) : 0] - sheet._scrollLeft }); break;
				    case "End":
				        if (sheet._isFreezed) 
				            this.XLCellNav._navToCell(rowIndex, colIndex);
				        else
				            if ((rowIndex < sheet._topRow.idx || rowIndex > sheet._bottomRow.idx) || colIndex < sheet._leftCol.idx || colIndex > sheet._rightCol.idx)
				                this.XLScroll.scrollToCell(this._getAlphaRange(sheetIdx, rowIndex, colIndex, obj.rowIndex, obj.colIndex));
				        break;
				    case "Ctrl + Home":
				    case "Ctrl + Shift + Home":
				        this.XLScroll.scrollToCell(this._getAlphaRange(sheetIdx, rowIndex, colIndex, obj.rowIndex, obj.colIndex)); break;
				}
                this.XLScroll._getFirstColumn(sheetIdx);
            }
        },

        _pageUpDown: function (isUp) {
            if (this._isAutoWHMode)
                return;
            var top, endCell, actTop, bottomRow, topRow, fdiff = 0, rowdiff, activeCell = this.getActiveCell(), sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling;
            actTop = sheet._rowHeightCollection[activeCell.rowIndex];
            if ((sheet.rowCount - 1 === sheet._bottomRow.idx && isUp === 1) || ((this._isFrozen(sheet.frozenRows) ? (activeCell.rowIndex > sheet.frozenRows && sheet._ftopRowIdx === sheet.frozenRows) : sheet._topRow.idx === 0) && isUp === -1))
                return;
            bottomRow = sheet._bottomRow.value + sheet.rowsHeightCollection[sheet._bottomRow.idx];
            if (this._isFrozen(sheet.frozenRows)) {
                if(activeCell.rowIndex < sheet.frozenRows && isUp === 1)
                    actTop = sheet._rowHeightCollection[sheet.frozenRows];
                fdiff = (isUp === 1) ? (this._getRowOffsetTop(sheet, sheet.frozenRows)) : this._getIdxWithOffset(sheet._ftopRowIdx, null, false, ["freeze"]).yOffset;
            }
            topRow = isUp * (bottomRow - (fdiff ? fdiff : sheet._topRow.value));
            top = (actTop + topRow) > 0 ? (actTop + topRow) : 0;
            if (fdiff) {
                if ((isUp === 1)) {
                    rowdiff = (activeCell.rowIndex > sheet._ftopRowIdx) ? this._getIdxWithOffset(activeCell.rowIndex).yOffset - sheet._frozenHeight : 0;
                    if (activeCell.rowIndex < sheet.frozenRows)
                        this._scrollContent({ 'y': isUp * ((bottomRow - sheet.rowsHeightCollection[sheet._bottomRow.idx]) - fdiff) + 1 });
                    else
                        this._scrollContent({ 'y': (this._getIdxWithOffset(sheet._bottomRow.idx, null, false, ["freeze"]).yOffset - sheet._frozenHeight) }, true);
                    top = this._getIdxWithOffset(sheet._ftopRowIdx).yOffset + rowdiff;
                }
                else {
                    rowdiff = (activeCell.rowIndex > sheet._ftopRowIdx) ? this._getIdxWithOffset(activeCell.rowIndex).yOffset - sheet._frozenHeight : 0;
                    if (activeCell.rowIndex > sheet.frozenRows && isVirtualScroll)
                        this._scrollContent({ 'y': (fdiff - (bottomRow - sheet.rowsHeightCollection[sheet._bottomRow.idx]) + 1) }, true);
                    else 
                        this._scrollContent({ 'y': ((top + sheet.rowsHeightCollection[sheet._bottomRow.idx]) - sheet._frozenHeight + 1) }, true);
                    top = this._getIdxWithOffset(sheet._ftopRowIdx).yOffset + rowdiff;
                }
            }
            else
            {
                if (isUp === 1 && this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal && sheet._bottomRow.value + this.model.rowHeight + sheet._vPortHgt >= sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1])
                    top = sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1];
                else
                    this._scrollContent({ 'y': isUp * (bottomRow - sheet._scrollTop) });
            }
            endCell = this._getIdxWithOffset(top, sheet._colWidthCollection[activeCell.colIndex], true);
            this._setAndSelectActiveCell(endCell.rowIdx, endCell.colIdx);
        },

        _keyboardShortCuts: function (e) {
            if (this.model.allowEditing && this.XLEdit._isEdit || (this.model.allowComments && this.XLComment._isCommentEdit && e.keyCode !== 27)) //!Esc key
                return false;
            var activeCell, startCell, endCell, xlFormat = this.XLFormat, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), selCells = sheet._selectedCells, protect = false;
            if (this.model.allowLockCell && sheet.isSheetProtected)
                protect = true;
            if (!e.ctrlKey && !e.shiftKey) {
                switch (e.keyCode) {
                    case 33:  // PAGE UP
                        e.preventDefault();
                        this._pageUpDown(-1);
                        break;
                    case 34:  // PAGE DOWN
                        e.preventDefault();
                        this._pageUpDown(1);
                        break;
                    case 36: // HOME
                        e.preventDefault();
                        this._setAndSelectActiveCell(this.getActiveCell(sheetIdx).rowIndex, this._isFrozen(sheet.frozenColumns) ? sheet._frozenColumns - 1 : 0,"Home");
                        break;
                }
            }
            if (e.ctrlKey && !e.shiftKey) {
                if (!this.element.find("#" + this._id + "_Ribbon .e-ribbonbackstagepage").is(":visible")) {
                    switch (e.keyCode) {
                        case 65:  // Ctrl + A
                            e.preventDefault();
                            if (this.model.allowSelection) {
                                activeCell = this.getActiveCellElem();
                                this.selectAll();
                                !ej.isNullOrUndefined(this.XLCellNav) && this.XLCellNav._updateActiveCell($(activeCell[0]).closest('tr').index(), activeCell[0].cellIndex, { keyCode: e.keyCode });
                                if (this.model.allowAutoFill)
                                    this.XLDragFill.positionAutoFillElement();
                            }
                            break;
                        case 66:  // Ctrl + B
                            e.preventDefault();
                            if (!protect)
                                this._toggleFontPrpty("bold");
                            break;
                        case 68: // Ctrl + D
                        case 82: // Ctrl + R
                            e.preventDefault();
                            if (this.model.allowAutoFill)
                                this.XLDragFill._fillRange(e.keyCode === 68);
                            break;
                        case 73: // Ctrl + I
                            e.preventDefault();
                            if (!protect)
                                this._toggleFontPrpty("italic");
                            break;
                        case 75: // Ctrl + K  
                            e.preventDefault();
                            if (this.model.allowHyperlink && !protect)
                                this._showDialog(this._id + "_Ribbon_Insert_Links_Hyperlink");
                            break;
                        case 85: // Ctrl + U
                            e.preventDefault();
                            if (!protect)
                                this._toggleFontPrpty("underline");
                            break;
                        case 32: // Ctrl + space
                            e.preventDefault();
                            if (!this.model.allowSelection)
                                return;
                            var sColIdx = selCells[0].colIndex, eColIdx = selCells[selCells.length - 1].colIndex;
                            startCell = { rowIndex: 0, colIndex: sColIdx }, endCell = { rowIndex: sheet.rowCount - 1, colIndex: eColIdx };
                            this.model.allowSelection && this.XLSelection.selectRange(startCell, endCell);
                            sheet._startCell = startCell;
                            sheet._endCell = endCell;
                            sheet._isColSelected = true;
                            !ej.isNullOrUndefined(this.XLCellNav) && this.XLCellNav._updateActiveCell(selCells[0].rowIndex, sColIdx);
                            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
                            break;
                        case 35:  // Ctrl + End
                            e.preventDefault();
                            endCell = this._getUsedRangeFromSheet(sheetIdx).endCell;
                            this._setAndSelectActiveCell(endCell.rowIndex, endCell.colIndex, "End");
                            break;
                        case 36:  // Ctrl + Home
                            e.preventDefault();
                            this._setAndSelectActiveCell(this._isFrozen(sheet.frozenRows) ? sheet._frozenRows - 1 : 0, this._isFrozen(sheet.frozenColumns) ? sheet._frozenColumns - 1 : 0, "Ctrl + Home");
                            break;
                        case 49: // Ctrl + 1
                            e.preventDefault();
                            this._showDialog(this._id + "_FormatCells");
                            break;
                        case 53: // Ctrl + 5
                            e.preventDefault();
                            if (!protect)
                                this._toggleFontPrpty("line-through");
                            break;
                        case 56: // Ctrl + 8 
                            if (!e.shiftKey && !protect) {
                                e.preventDefault();
                                this._hideColumn(sheet._startCell.colIndex, sheet._endCell.colIndex);
                            }
                            break;
                        case 57: // Ctrl + 9 
                            if (!e.shiftKey) {
                                e.preventDefault();
                                if (!protect)
                                    this._hideRow(sheet._startCell.rowIndex, sheet._endCell.rowIndex, "isRHide");
                            }
                            break;
                        case 220: // Ctrl + \ 
                            if (!e.shiftKey) {
                                e.preventDefault();
                                if (this.model.allowSearching)
                                    this.XLSearch._applyGotoRowDiff();
                            }
                            break;
                        case 90:
                            e.preventDefault();
                            break;
                        case 89:
                            e.preventDefault();
                            break;
                        case 114://ctrl + f3
                            e.preventDefault();
                            if (this.model.showRibbon && !protect)
                                this.XLRibbon._openNameManagerDlg();
                            break;
                        case 70: //Ctrl + F
                            e.preventDefault();
                            this._showDialog(this._id + "_Ribbon_Others_Editing_FindSelect");
                            $("#" + this._id + "_FRDialog").ejDialog("open");
                            this.XLRibbon._refreshFRDlg();
                            $("#" + this._id + "_FRDialog_FPDlgTab").ejTab("option", "selectedItemIndex", 0);
                            break;
                        case 71: //Ctrl + G
                            e.preventDefault();
                            this._showDialog(this._id + "_Ribbon_Others_Editing_FindSelect");
                            $("#" + this._id + "_GoDialog").ejDialog("open");
                            $("#" + this._id + "_GoToDlgTab").ejTab("option", "selectedItemIndex", 0);
                            break;
                        case 72: //Ctrl + H
                            e.preventDefault();
                            this._showDialog(this._id + "_Ribbon_Others_Editing_FindSelect");
                            $("#" + this._id + "_FRDialog").ejDialog("open");
                            this.XLRibbon._refreshFRDlg();
                            $("#" + this._id + "_FRDialog_FPDlgTab").ejTab("option", "selectedItemIndex", 1);
                            break;
                    }
                }
                switch (e.keyCode) {
                    case 80: // Ctrl + P
                        e.preventDefault();
                        this.XLPrint.printSheet();
                        break;
                    case 79: //Ctrl + O
                        e.preventDefault();
                        if (this.model.allowImport) {
                            if (this.model.importSettings.importMapper.length < 1) {
                                this._showAlertDlg("Alert", "ImportExportUrl", "", 266);
                                return;
                            }
                            else if (this.isDirty && this._browserDetails.name !== "msie")
                                this._showAlertDlg("", "ImportAlert", "Open", 470, 135);
                            else
                                $("#" + this._id + "_file .e-uploadinput").click();
                        }
                        break;
                    case 83: //Ctrl + S
                        e.preventDefault();
                        if(this.model.exportSettings.allowExporting){
						  this._showDialog("exportxl");
				          $("#" + this._id + "_ExportFileNameDialog").ejDialog("open");
				          this.XLExport._exportType = "Excel";
						}
                        break;
                }
            }
            if (e.ctrlKey && e.shiftKey) //Ctrl + Shift
            {
                if (!this.element.find("#" + this._id + "_Ribbon .e-ribbonbackstagepage").is(":visible")) {
                    if (this._browserDetails.name === "mozilla" && e.keyCode === 173)   // keycode for ( _ ) is 173 in firefox
                        e.keyCode = 189;
                    switch (e.keyCode) {
                        case 192:  // Ctrl + Shift + ~
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "general" });
                            break;
                        case 52:  // Ctrl + Shift + $
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "currency" });
                            break;
                        case 53:  // Ctrl + Shift + %
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "percentage" });
                            break;
                        case 54:  // Ctrl + Shift + ^
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "scientific" });
                            break;
                        case 51:  // Ctrl + Shift + #
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "shortdate" });
                            break;
                        case 50: // Ctrl + Shift + @
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "time" });
                            break;
                        case 49:  // Ctrl + Shift + ! 
                            e.preventDefault();
                            if (!protect)
                                xlFormat.format({ "type": "number" });
                            break;
                        case 55: // Ctrl + Shift + &    
                            e.preventDefault();
                            if (this.model.allowCellFormatting && this.model.formatSettings.allowCellBorder && !protect)
                                this.XLFormat.applyBorder({ top: '1px solid #000000', right: '1px solid #000000', bottom: '1px solid #000000', left: '1px solid #000000' });
                            break;
                        case 189: // Ctrl + Shift + _
                            e.preventDefault();
                            if (this.model.allowCellFormatting && this.model.formatSettings.allowCellBorder && !protect)
                                this.XLFormat.applyBorder('noborder');
                            break;
                        case 73: // Ctrl + Shift + I   
                            e.preventDefault();
                            if (this.model.allowInsert && !protect)
                                this._showDialog(this._id + "_Ribbon_Others_Cells_InsertCellOptions");
                            break;
                        case 68: // Ctrl + Shift + D 
                            e.preventDefault();
                            if (this.model.allowDelete && !protect)
                                this._showDialog(this._id + "_Ribbon_Others_Cells_DeleteCellOptions");
                            break;
                        case 113: // Ctrl + Shift + F2
                            e.preventDefault();
                            var rObj = $('#' + this._id + '_Ribbon').data('ejRibbon');
                            if (this.model.showRibbon) {
                                if (rObj._isCollapsed) {
                                    rObj.expand();
                                    rObj._removeRibbonPin();
                                    this._isKeyCtrlShftF2 = true;
                                }
                                else rObj.collapse();
                            }
                            break;
                        case 56: // Ctrl + Shift + 8  
                            e.preventDefault();
                            if (!protect && this.model.allowSelection)
                                this._showColumn(selCells[0].colIndex, selCells[selCells.length - 1].colIndex);
                            break;
                        case 57: // Ctrl + Shift + 9   
                            e.preventDefault();
                            if (!protect && this.model.allowSelection)
                                this._showRow(selCells[0].rowIndex, selCells[selCells.length - 1].rowIndex, "isRHide");
                            break;
                        case 79: // Ctrl + Shift + O
                            e.preventDefault();
                            this.XLSearch._applyGotoComments();
                            break;
                        case 220: // Ctrl + Shift + | 
                            e.preventDefault();
                            this.XLSearch._applyGotoColDiff();
                            break;
                        case 36: //Ctrl + Shift + Home
                            e.preventDefault();
                            endCell = this.getActiveCell(sheetIdx);
                            this._selectActiveCell(0, 0, endCell, 'Ctrl + Shift + Home');
                            break;
                    }
                }
            }
            else if (e.shiftKey) {
                if (e.keyCode === 32) {  // Shift + space           
                    e.preventDefault();
                    if (this.model.allowSelection) {
                        var sRowIdx = selCells[0].rowIndex, eRowIdx = selCells[selCells.length - 1].rowIndex;
                        startCell = { rowIndex: sRowIdx, colIndex: 0 }, endCell = { rowIndex: eRowIdx, colIndex: sheet.colCount - 1 };
                        this.XLSelection.selectRange(startCell, endCell);
                        sheet._startCell = startCell;
                        sheet._endCell = endCell;
                        sheet._isRowSelected = true;
                        !ej.isNullOrUndefined(this.XLCellNav) && this.XLCellNav._updateActiveCell(sRowIdx, selCells[0].colIndex);
                        this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
                    }
                }
                else if (e.keyCode === 113) {  // Shift + F2
                    this._dupDetails = true;
                    e.preventDefault();
                    activeCell = this.getActiveCellElem();
                    if (this.model.allowComments && !protect){
                        this._isRibbonClick = true;
                        activeCell.hasClass("e-commentcell") ? this.XLComment.editComment() : this.XLComment.setComment();
						this._isRibbonClick = false;
					}
                    this._dupDetails = false;
                }
                else if (e.keyCode === 122) {  // Shift + F11    
                    e.preventDefault();
                    this.addNewSheet();
                }
            }
            else if (e.keyCode === 27) { // Esc
                if (this.model.allowComments && this.XLComment._isCommentEdit) {
                    this.XLComment._updateCurCmntVal();
                    this.XLComment._updateCmntRibIcons();
                }
                if (this.model.allowContextMenu)
                    if (this.XLCMenu._isMenuOpened || $("#" + this._id + "_contextMenuColumnHeader").is(":visible") || $("#" + this._id + "_contextMenuRowHeader").is(":visible"))
                        this.XLCMenu.hideCMenu();
                if (this.model.allowFiltering)
                    if (this._excelFilter && this._excelFilter._openedFltr && $(this._excelFilter._openedFltr).is(":visible")) {
                        var mObj = this._excelFilter._menuWrap.data("ejMenu");
                        if (mObj.element.find(".e-mhover li:visible").length) {
                            if (!mObj._isContextMenuOpen)
                                mObj._closeMenu();
                            return;
                        }
                        this.XLFilter._isSearchEdit = false;
                        this._excelFilter.closeXFDialog();
                    }
                this.setSheetFocus();
            }
            else if (e.altKey) {
                if (e.keyCode === 112 && this.model.showRibbon && this.model.allowCharts && !protect)//alt +f1-Create chart
                {
                    e.preventDefault();
                    this.XLChart.createChart(null, { type: "column", enable3D: false, marker: { visible: false } });
                }
                else if (e.keyCode === 84 && this.model.showRibbon && !this.XLRibbon._isDirtySelect && !protect && this.model.allowFormatAsTable)//alt+T-create a table
                {
                    this._showDialog(this._id + "_Ribbon_Insert_Tables_Table");
                    e.preventDefault();
                    this.XLRibbon._openFATDlg();
                }
            }
        },

        _triggerTBtnClick: function (id) {
            var btnObj = $('#' + id).data("ejToggleButton");
            btnObj.buttontag.click();
        },

        _toggleFontPrpty: function (type) {
            var actCell = this.getActiveCell(), xlFormat = this.XLFormat, style = { "style": {} }, formatCode, fontPrpty, format, id;
            formatCode = this.XLEdit.getPropertyValue(actCell.rowIndex, actCell.colIndex, "format");
            format = !this.isUndefined(formatCode) && this.XLFormat.getFormatFromHashCode(formatCode);
            if (type === "bold")
                fontPrpty = "font-weight";
            else if (type === "italic")
                fontPrpty = "font-style";
            else
                fontPrpty = "text-decoration";
            id = type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();
            if (id === "Line-through")
                id = "StrikeThrough";
            if (format[fontPrpty] === type) {
                this.model.showRibbon && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).length && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).ejToggleButton("option", "toggleState", false);
                style.style[fontPrpty] = "none";
            }
            else if (fontPrpty === "text-decoration" && (format[fontPrpty] === "underline" || format[fontPrpty] === "line-through")) {
                this.model.showRibbon && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).length && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).ejToggleButton("option", "toggleState", true);
                style.style[fontPrpty] = (format[fontPrpty] === "underline") ? type + " " + format[fontPrpty] : format[fontPrpty] + " " + type;
            }
            else if (fontPrpty === "text-decoration" && (format[fontPrpty] === "line-through underline" || format[fontPrpty] === "underline line-through")) {
                this.model.showRibbon && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).length && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).ejToggleButton("option", "toggleState", false);
                format[fontPrpty] = format[fontPrpty].split(" ").join("");
                style.style[fontPrpty] = format[fontPrpty].replace(type, "");
            }
            else {
                this.model.showRibbon && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).length && this.element.find("#" + this._id + "_Ribbon_Home_Font_" + id).ejToggleButton("option", "toggleState", true);
                style.style[fontPrpty] = type;
            }
            xlFormat.format(style);
        },

        _getLocStr: function (prop) {
            return this.localizedLabels[prop];
        },

        _checkIndicesInContainer: function (sheetIdx, rowIdx, colIdx, property) {
            var sheets = this._dataContainer.sheets;
            if (sheetIdx in sheets && rowIdx in sheets[sheetIdx] && colIdx in sheets[sheetIdx][rowIdx]) {
                if (property) {
                    if (property in sheets[sheetIdx][rowIdx][colIdx])
                        return true;
                    else
                        return false;
                }
                else
                    return true;
            }
            return false;
        },

        //Text Wrapping
        _textFormatting: function (operation) {
            switch (operation) {
                case 'wrapText':
                    var wrapToggle = $("#" + this._id + "_Ribbon_Home_Alignment_WrapText").data("ejToggleButton");
                    if (wrapToggle)
                        this.setWrapText(wrapToggle.model.toggleState ? "wrap" : "unwrap", null);
                    break;
            }
        },

        wrapText: function (range) {
            if (!this.model.allowWrap || this.model.isReadOnly)
                return;
            this.setWrapText("wrap", range);
        },

        unWrapText: function (range) {
            if (!this.model.allowWrap || this.model.isReadOnly)
                return;
            this.setWrapText("unwrap", range);
        },

        setWrapText: function (operation, range) {
            if (!this.model.allowWrap || this.model.isReadOnly)
                return;
            var selCell, rge, cell, sheetIdx = this.getActiveSheetIndex(), mergeWrap, wRowIdx, wColIdx, sheet = this.getSheet(sheetIdx), cellheight = 0, cellHt, rowHt = this.model.rowHeight, filterIcon, rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowhdrrows = rowColl[0], aRange, j,
                rowHtColl = sheet.rowsHeightCollection, colWtColl = sheet.columnsWidthCollection, rowHt = 0, colWt = 0, wrapHtColl = sheet._wrapHtCollection, isWrap = false, rowIdx, isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, clrWrap = sheet._clrWrapColl, selLastCell, frmtCellHt;
            rge = this._getRangeArgs(range, "object");
            selCell = this._getSelectedCells(sheetIdx, rge).selCells;
            if (selCell.length === 0)
                return;
            else if (selCell.length > 1)
                aRange = this._getProperAlphaRange(sheetIdx, selCell[0].rowIndex, selCell[0].colIndex, selCell[selCell.length - 1].rowIndex, selCell[selCell.length - 1].colIndex)
            else
                aRange = this._getAlphaRange(sheetIdx, selCell[0].rowIndex, selCell[0].colIndex, selCell[selCell.length - 1].rowIndex, selCell[selCell.length - 1].colIndex);
			this._updateWrapCol(operation, selCell,sheet, sheetIdx);
            for (var i = 0, len = selCell.length; i < len; i++) {
                rowIdx = isVirtualScroll ? this._getRowIdx(selCell[i].rowIndex) : selCell[i].rowIndex;
                selLastCell = selCell[selCell.length - 1]; // Last cell of selected range. 
                isWrap = this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, "wrap");
                if (!this._isPaste && ((operation === "unwrap" && !isWrap) || (operation === "wrap" && isWrap))){
					cellheight = this._getWrapCellHeight(sheetIdx, selCell[i].rowIndex, selCell[i].colIndex, cellHt);
				  if (cellheight.rowHt > 0) {
                    if (selCell[i].colIndex === rge[3] || this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, "merge")) {
                        this.setHeightToRows([{ rowIndex: selCell[i].rowIndex, height: cellheight.rowHt }]);
                        rowHt = 0;
                    if(operation === 'wrap' && !isWrap)
						if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCell[i].rowIndex, 0, "wrapRow")))
							this.XLEdit._updateDataContainer({ rowIndex: selCell[i].rowIndex, colIndex: 0 }, { dataObj: { wrapRow: true } });
                    }
                }
                     continue;
				}
                if (operation === "unwrap" && isWrap) {
                    (!this._isUndoRedo) && clrWrap.push({ rowIdx: selCell[i].rowIndex, colIdx: selCell[i].colIndex });
                    if (this._isRowViewable(sheetIdx, selCell[i].rowIndex)) {
                        cell = this.getCell(selCell[i].rowIndex, selCell[i].colIndex);
                        wRowIdx = selCell[i].rowIndex; wColIdx = selCell[i].colIndex;
                        if (cell)
                            this._removeClass(cell[0], "e-sswraptext");
                        this._removeClass(rowhdrrows[wRowIdx], "e-sswraprow");
                        if (this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, "altTxt"))
                            this.addClass(cell[0], "e-alt-unwrap");
                        if (wRowIdx in sheet._wrapColl)
                            if (wColIdx in sheet._wrapColl[wRowIdx]) {
                                delete sheet._wrapColl[wRowIdx][wColIdx];
                                cellHt = ej.max(this._getObjectValues(sheet._wrapColl[wRowIdx]));
								frmtCellHt = this._getFormattedHeight(sheetIdx, wRowIdx);
								if(!cellHt || cellHt < frmtCellHt)
								    cellHt = frmtCellHt;
                                !this.getObjectLength(sheet._wrapColl[wRowIdx]) && delete sheet._wrapColl[wRowIdx];
                            }
                        if (cell.find(".e-filterspan").length > 0) {
                            filterIcon = cell.find(".e-filterspan");
                            this.model.allowFiltering && this.XLFilter._postionFilterIcon(cell, filterIcon);
                        }
                    }
                    this.XLEdit._clearDataContainer({ cellIdx: selCell[i], property: ["wrap"] });
                    this.XLEdit._clearDataContainer({ cellIdx: { rowIndex: selCell[i].rowIndex, colIndex: 0 }, property: ["wrapRow"] });
                    this.XLEdit._clearDataContainer({ cellIdx: { rowIndex: 0, colIndex: selCell[i].colIndex }, property: ["wrapCol", "wrapWidth"] });
                    cellheight = this._getWrapCellHeight(sheetIdx, selCell[i].rowIndex, selCell[i].colIndex, cellHt);
                    this._textClip(selCell[i].rowIndex, selCell[i].colIndex, 'add');
                }
                else if (operation === "wrap" && !isWrap) {
                    if (this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, 'isFilterHeader'))
                        continue;
                    this._textClip(selCell[i].rowIndex, selCell[i].colIndex, 'delete');
                    this._wrapCollection(selCell[i].rowIndex, selCell[i].colIndex, rowHtColl[selCell[i].rowIndex], sheetIdx);
                    this.XLEdit._updateDataContainer({ rowIndex: selCell[i].rowIndex, colIndex: selCell[i].colIndex }, { dataObj: { wrap: true } });
                    if (this._isRowViewable(sheetIdx, selCell[i].rowIndex)) {
                        cell = this.getCell(selCell[i].rowIndex, selCell[i].colIndex);
                        if ((cell.css("visibility") == "visible" || this._isPaste) && (this.model.allowResizing && !this.XLResize._preventRowResize(selCell[i].rowIndex))) {
                            this.addClass(cell[0], "e-sswraptext");
                            if (this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, "altTxt"))
                                this._removeClass(cell[0], "e-alt-unwrap");
                            if (cell.find(".e-filterspan").length > 0) {
                                filterIcon = cell.find(".e-filterspan");
                                this.model.allowFiltering && this.XLFilter._postionFilterIcon(cell, filterIcon);
                            }
                        }
                    }
					if(this.XLEdit.getPropertyValue( selCell[i].rowIndex, selCell[i].colIndex, "mergeIdx"))
						cellheight = this._getWrapCellHeight(sheetIdx, selCell[i].rowIndex, selCell[i].colIndex, sheet.rowsHeightCollection[selCell[i].rowIndex]);
					else
                        cellheight = this._getWrapCellHeight(sheetIdx, selCell[i].rowIndex, selCell[i].colIndex);
                    (cellheight.rowHt < rowHt) && (cellheight.rowHt = rowHt);
                    rowHt = cellheight.rowHt;
                    this._wrapCollection(selCell[i].rowIndex, selCell[i].colIndex, cellheight.cellHt, sheetIdx);
                    this.XLEdit._updateDataContainer({ rowIndex: selCell[i].rowIndex, colIndex: selCell[i].colIndex }, { dataObj: { wrap: true } });
                    wrapHtColl[selCell[i].rowIndex] = (i > 0 && (selCell[i].rowIndex === selCell[i - 1].rowIndex)) ? wrapHtColl[selCell[i - 1].rowIndex] : wrapHtColl[selCell[i].rowIndex] = rowHtColl[selCell[i].rowIndex];
                    if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCell[i].rowIndex, 0, "wrapCol")))
                        this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: selCell[i].colIndex }, { dataObj: { wrapCol: true, wrapWidth: this.getSheet(sheetIdx).columnsWidthCollection[selCell[i].colIndex] } });
                }
                if (cellheight.rowHt > 0) {
                    if (selCell[i].colIndex === rge[3] || this.XLEdit.getPropertyValue(selCell[i].rowIndex, selCell[i].colIndex, "merge")) {
                        this.setHeightToRows([{ rowIndex: selCell[i].rowIndex, height: cellheight.rowHt }]);
                        rowHt = 0;
                    if(operation === 'wrap' && !isWrap)
						if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCell[i].rowIndex, 0, "wrapRow")))
							this.XLEdit._updateDataContainer({ rowIndex: selCell[i].rowIndex, colIndex: 0 }, { dataObj: { wrapRow: true } });
                    }
                }
                (selCell[i].colIndex === rge[3]) && (rowHt = 0);
                cellheight = 0;
        }
		    if (this.model.allowFreezing && sheet.frozenRows)
                {
                    this.XLFreeze._refreshFRowResize(sheet.frozenRows -1);
                    !this.isImport && sheet._isLoaded && this.XLFreeze._refreshSelection();
                }
            if (this.model.allowComments)
                this.XLComment._updateCmntArrowPos(); //Comments position update
            if (this.model.scrollSettings.allowScrolling)
                this.XLScroll._getRowHeights(sheetIdx, selCell[0].rowIndex + 1);
            if (!sheet._isImported || sheet._isLoaded) {
                var details = { sheetIndex: sheetIdx, selectedCell: selCell, reqType: "textwrap", operation: operation, range: aRange };
                if (this.model.scrollSettings.allowScrolling)
                    this.XLScroll._refreshScroller(sheetIdx, "refresh", "all");
                this.model.allowSelection && this.XLSelection._refreshBorder();
                if (!this._isUndoRedo && !this._dupDetails) {
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
            }
        },

        _getWrapCellHeight: function (sheetIdx, rowIdx, colIdx, cellHeight) {
            var j, merge, rowHt = 0, colWt = 0, cellHt, sheet = this.getSheet(sheetIdx), rowHtColl = sheet.rowsHeightCollection, colWtColl = sheet.columnsWidthCollection, heightVal;
            merge = this.XLEdit.getPropertyValue(rowIdx, colIdx, "merge");
            rowHt = rowHtColl[rowIdx];
            colWt = colWtColl[colIdx];
            if (merge) {
                for (j = rowIdx + 1; j < rowIdx + merge.mSpan.rowSpan; j++)
                    rowHt = rowHt + rowHtColl[j];
                for (j = colIdx + 1; j < colIdx + merge.mSpan.colSpan; j++)
                    colWt = colWt + colWtColl[j];
            }
            if (merge) {
				rowHt = this._getRowHeight(rowIdx, sheetIdx);
				cellHt = cellHeight ? cellHeight : rowHt;
			}
            else {
				if(!sheet._wrapValColl[rowIdx] || !sheet._wrapValColl[rowIdx][colIdx])
					heightVal = this.model.rowHeight;
                else
                	heightVal = this._detailsFromGlobalSpan(rowIdx, colIdx, "height", this.XLEdit.getPropertyValue(rowIdx, colIdx, "value2"), colWt);
                cellHt = cellHeight ? cellHeight : heightVal;
                cellHt = cellHt < this.model.rowHeight ? this.model.rowHeight : cellHt;
				rowHt = cellHt;
			}
            return { cellHt: cellHt, rowHt: rowHt };
        },
        
		_wrapTextLenCln: function (cellIndex, sheet, operation, sheetIdx) {
            var i, j, cellLen = cellIndex.length - 1, data = this.getRangeData({ range: [cellIndex[0].rowIndex, cellIndex[0].colIndex, cellIndex[cellLen].rowIndex, cellIndex[cellLen].colIndex], property: ['value2', "formats"] }), rowCnt = cellIndex[cellLen].rowIndex - cellIndex[0].rowIndex, colCnt = cellIndex[cellLen].colIndex - cellIndex[0].colIndex, maxLen, cells = 0, cavsElem, cavsTxt, width, colsWidthCln = sheet.columnsWidthCollection, isIE8Bwsr, spanElem, tempWidth;
            isIE8Bwsr = (this._browserDetails.name === "msie" && this._browserDetails.version === "8.0");
            if (isIE8Bwsr) {
                spanElem = $('#' + this._id + '_emptySpan');
                for (i = 0; i <= rowCnt; i++) {
                    maxLen = 0;
                    tempWidth = sheet._wrapValColl[cellIndex[cells].rowIndex] ? this._getObjectValues(sheet._wrapValColl[cellIndex[cells].rowIndex])[0] : colsWidthCln[cellIndex[cells].colIndex];
                    for (j = 0; j <= colCnt; j++) {
                        if (data[cells].value2) {
                            if (!this.getObjectLength(data[cells].formats))
                                spanElem.css({ 'font-size': "11pt", 'font-family': "Calibri" });
                            else if (data[cells].formats["font-family"] && data[cells].formats["font-size"])
                                spanElem.css({ 'font-size': data[cells].formats["font-size"], 'font-family': data[cells].formats["font-family"] });
                            else if (data[cells].formats["font-family"])
                                spanElem.css({ 'font-size': "11pt", 'font-family': data[cells].formats["font-family"] });
                            else if (data[cells].formats["font-size"])
                                spanElem.css({ 'font-size': data[cells].formats["font-size"], 'font-family': "Calibri" });
                            width = spanElem.text(data[cells].value2).width();
							if(operation != "wrap" &&  sheet._wrapColl[cellIndex[cells].rowIndex] && sheet._wrapColl[cellIndex[cells].rowIndex][cellIndex[cells].colIndex] <= this.model.rowHeight && colsWidthCln[cellIndex[cells].colIndex] < width)
							    this._wrapCollection(cellIndex[cells].rowIndex, cellIndex[cells].colIndex, this._detailsFromGlobalSpan(cellIndex[cells].rowIndex, cellIndex[cells].colIndex, "height", data[cells].value2, colsWidthCln[cellIndex[cells].colIndex]), sheetIdx);
                            if(tempWidth<width){
							    tempWidth =  width;
									sheet._wrapValColl[cellIndex[cells].rowIndex] = {};
								    sheet._wrapValColl[cellIndex[cells].rowIndex][cellIndex[cells].colIndex] = width;
							}
                        }
                        cells++;
                    }

                }
            }
            else {
                cavsElem = document.createElement("canvas");
                cavsElem.setAttribute("id", "Wrapcanvas");
                cavsTxt = cavsElem.getContext("2d");
                for (i = 0; i <= rowCnt; i++) {
                    maxLen = 0;
                    tempWidth = sheet._wrapValColl[cellIndex[cells].rowIndex] ? this._getObjectValues(sheet._wrapValColl[cellIndex[cells].rowIndex])[0] : colsWidthCln[cellIndex[cells].colIndex];
                    for (j = 0; j <= colCnt; j++) {
                        if (data[cells].value2) {
                            if (!this.getObjectLength(data[cells].formats))
                                cavsTxt.font = "11pt Calibri"
                            else if (data[cells].formats["font-family"] && data[cells].formats["font-size"])
                                cavsTxt.font = data[cells].formats["font-size"] + " " + data[cells].formats["font-family"];
                            else if (data[cells].formats["font-family"])
                                cavsTxt.font = "11pt " + data[cells].formats["font-family"];
                            else if (data[cells].formats["font-size"])
                                cavsTxt.font = data[cells].formats["font-size"] + " Calibri";
                            width = cavsTxt.measureText(data[cells].value2).width;
							if(operation != "wrap" && sheet._wrapColl[cellIndex[cells].rowIndex] && sheet._wrapColl[cellIndex[cells].rowIndex][cellIndex[cells].colIndex] <= this.model.rowHeight && colsWidthCln[cellIndex[cells].colIndex] < width)
							    this._wrapCollection(cellIndex[cells].rowIndex, cellIndex[cells].colIndex, this._detailsFromGlobalSpan(cellIndex[cells].rowIndex, cellIndex[cells].colIndex, "height", data[cells].value2, colsWidthCln[cellIndex[cells].colIndex]), sheetIdx);
                            if(tempWidth<width){
							    tempWidth =  width;
									sheet._wrapValColl[cellIndex[cells].rowIndex] = {};
								    sheet._wrapValColl[cellIndex[cells].rowIndex][cellIndex[cells].colIndex] = width;
							}
                        }
                        cells++;
                    }

                }
            }
        },
        _updateWrapCol: function(operation, selCell, sheet, sheetIdx) {
			if(operation === "wrap")
			    this._wrapTextLenCln(selCell, sheet, operation, sheetIdx);
			else {
				var tempWrapCol = sheet._wrapColl,selCellLen = selCell.length, i,j;
				for(i=selCell[0].rowIndex;i<=selCell[selCellLen-1].rowIndex;i++){
					if(operation === "unwrap"){
					  sheet._wrapValColl[i] && delete sheet._wrapValColl[i];
					  tempWrapCol = $.extend(true, {},sheet._wrapColl)
				      for(j =selCell[0].colIndex;j<=selCell[selCellLen-1].colIndex;j++)
					   tempWrapCol[i] && tempWrapCol[i][j] && delete tempWrapCol[i][j];
					}
					if(tempWrapCol[i]){
						var wrapColKeys = this.getObjectKeys(tempWrapCol[i]), wrapKeysLen = wrapColKeys.length;
					    for(j =0;j<wrapKeysLen;j++){
					       this._wrapTextLenCln([{rowIndex:i, colIndex:wrapColKeys[j]}], sheet, operation, sheetIdx);
						}
					}
				}
			}
			
		},
        _wrapCollection: function (rowIdx, colIdx, cheight, sIdx) {
            var sheet = this.getSheet(sIdx ? sIdx : this.getActiveSheetIndex());
            !sheet._wrapColl[rowIdx] && (sheet._wrapColl[rowIdx] = {});
            if (this.getObjectLength(sheet._wrapColl[rowIdx]) > -1)
                sheet._wrapColl[rowIdx][colIdx] = cheight;
            if (sheet.rowsHeightCollection[rowIdx] < cheight && !this._isInMrgeRnge(rowIdx, colIdx, !sheet._isLoaded)) {
                sheet.rowsHeightCollection[rowIdx] = cheight;
                if (this.model.scrollSettings.allowScrolling)
                    this.XLScroll._getRowHeights(sIdx, rowIdx, true);
                this._getRowHdrTBody(sIdx).find('tr[data-idx="' + rowIdx + '"]').height(cheight);
            }
        },
         
        _isInMrgeRnge: function (rIdx, cIdx, isOnImport) {
            if (!isOnImport)
                return this.XLEdit.getPropertyValue(rIdx, cIdx, "merge");
            var i, range, sheetIdx = this._getSheetIndex(), mergedCells = this._impData ? this._impData.model.sheets[sheetIdx].mergedCells : [];
            !mergedCells && (mergedCells = []);
            for (i = 0; i < mergedCells.length; i++) {
                range = this.getRangeIndices(mergedCells[i]["range"]);
                if (range[0] <= rIdx && range[2] >= rIdx) {
                    if (range[1] <= cIdx && range[3] >= cIdx) {
                        return true;
                    }
                }
            }
            return false;
        },

        _setWrapHeight: function (sheetIdx, rowIdx, detachedRows, rowHdrs, emptyTable, status) {
            var rHt, newRow, tr = detachedRows[rowIdx], sheet = this.getSheet(sheetIdx), rowHtColl = sheet.rowsHeightCollection;
            if (rowHtColl[rowIdx] > 0)
                rHt = rowHtColl[rowIdx];
            else {
                if (sheet.hideRowsCollection.indexOf(rowIdx) === -1 || status === "visible") {
                    newRow = $(detachedRows[rowIdx].outerHTML).attr("id", "ss");
                    emptyTable[0].insertBefore(newRow[0], emptyTable[0].childNodes[0]);
                    rHt = emptyTable[0].rows[0].getBoundingClientRect().height;
                    emptyTable[0].rows[0].parentNode.removeChild(emptyTable[0].rows[0]);
                }
            }
            rHt = rHt < 20 ? 20 : rHt;
            if (parseInt(tr.style.height) < rHt) {
                tr.style.height = rHt + "px";
                $(rowHdrs[rowIdx])[0].style.height = rHt + "px";
                sheet.rowsHeightCollection[rowIdx] = rHt;
            }
        },

        _setRowHdrHeight: function (sheetIdx, rowIdx) {
            var dupRowIdx = this._getRowIdx(rowIdx), isIntrnlReq, ht;
            var sheet = this.getSheet(sheetIdx), rows = this.getRows(sheetIdx), height = sheet.rowsHeightCollection[rowIdx];
            if (this._isRowViewable(sheetIdx, rowIdx)) {
				ht = parseInt(rows[0][dupRowIdx].style.height);
				if (ht != height) {
				    rows[0][dupRowIdx].style.height = height + "px";
				    if (this.model.allowSelection) {
				        isIntrnlReq = this._intrnlReq;
				        this._intrnlReq = true;
				        this.XLSelection.refreshSelection();
				        if (sheet._isFreezed)
				            this.XLFreeze._refreshSelection();
				        this._intrnlReq = isIntrnlReq;
				    }
				    if ((!sheet._isImported || sheet._isLoaded) && this.model.allowAutoFill)
				        this.XLDragFill.positionAutoFillElement();
				}
			}
        },

        _refreshRangeTRHght: function (sheetIdx, range) {
            var i, sIdx = range[0] < 1 ? range[0] : range[0] - 1, sheet = this.getSheet(sheetIdx); // - 1 for border refresh
            for (i = sIdx; i <= range[2]; i++)
                this._setRowHdrHeight(sheetIdx, i);
            this.XLScroll._getRowHeights(sheetIdx, sIdx);
            if (!sheet._isImported || sheet._isLoaded)
                this.model.allowSelection && this.XLSelection._refreshBorder();
        },

        //Alert Dialog
        _renderAlertdlg: function () {
            var alertokBtn, alertbtndiv, confirmbtndiv, okCanButton, parent, str, cntrDiv = "<div class='e-dlg-btnctnr' id=", dlgId = this._id + "_alertdlg",
                opts = { text: this._getLocStr("Ok"), showRoundedCorner: true, width: 60, click: ej.proxy(this._alertOkClick, this), enabled: true , cssClass: "e-ss-okbtn"};
            if (document.getElementById(this._id + '_alertdlg'))
                return;
            okCanButton = "<input id=" + this._id + "_dialog_Ok ></input><input id=" + this._id + "_dialog_Can style= 'margin-left: 10'; ></input>";
            alertokBtn = "<input id=" + this._id + "_dialog_alertOk > </input>";
            confirmbtndiv = cntrDiv + dlgId + "_condiv >" + okCanButton + "</div>";
            alertbtndiv = cntrDiv + dlgId + "_alertdiv >" + alertokBtn + "</div>";
            str = "<div class='e-alertdlgcontent' id=" + dlgId + "_dlgcontent > </div>";
            str = str + "<div class='e-dlg-btnfields' id=" + dlgId + "_dlgbtncontent >" + confirmbtndiv + alertbtndiv + "</div>";
            parent = $("<div id=" + dlgId + " class='e-alertdlg' style= 'display : none;'>" + str + "</div>");
            this.element[0].appendChild(parent[0]);
            $("#" + this._id + "_dialog_alertOk").ejButton(opts);
            $("#" + this._id + "_dialog_Ok").ejButton(opts);
            $("#" + this._id + "_dialog_Can").ejButton({ text: this._getLocStr("Cancel"), showRoundedCorner: true, width: 60, click: ej.proxy(this._alertCanClick, this) });
        },

        alert: function (statusText) {
            var alertDlg = $("#" + this._id + "_alertdlg");
            this._renderAlertDlgContent(alertDlg, "Alert", statusText);
            alertDlg.ejDialog("open");
        },

        _renderAlertDlgContent: function ($dlg, type, content, targetName, dlgWidth, className) {
            var contentdiv = $dlg.find("#" + this._id + "_alertdlg_dlgcontent");
            var confirmdiv = $dlg.find("#" + this._id + "_alertdlg_condiv");
            var alertdiv = $dlg.find("#" + this._id + "_alertdlg_alertdiv");
            if (this._tabMode || this._phoneMode) {
                if (dlgWidth > (this._responsiveWidth / 1.2))
                    dlgWidth = (this._responsiveWidth / 1.2);
            }
            else
                dlgWidth = dlgWidth || 400;
            className = className || "";
            if (type === "Alert") {
                confirmdiv.hide();
                alertdiv.show();
            }
            else {
                confirmdiv.show();
                alertdiv.hide();
            }
            contentdiv.text("");
            contentdiv.html(content);
            $dlg.ejDialog({ showOnInit: false, enableModal: true, enableResize: false, enableAnimation: false, allowKeyboardNavigation: false, title: this._getLocStr("Title"), width: dlgWidth, height: "auto", minHeight: 0, cssClass: "e-ss-dialog e-" + this._id + "-dlg" + className, open: ej.proxy(this._alertDlgOpen) });
            this._alertDialog = { element: $dlg, action: targetName };
        },

        _alertDlgOpen: function () {
            this.element.find("input:visible:first").focus();
        },

        _alertOkClick: function ($dlg) {
            var shtModel, i = 1, sheetIdx = this.getActiveSheetIndex(), prtctWrkBk, isUndoRedo = this._isUndoRedo;
            this._alertDialog.element.ejDialog("close");
            switch (this._alertDialog.action) {
                case "findPrevComment":
                    this.gotoPage(this.model.sheetCount, false);
                    shtModel = this.model.sheets[this.model.sheetCount];
                    this.XLComment._updateCurrentCell(shtModel.rowCount - 1, shtModel.colCount - 1);
                    this.XLComment.findPrevComment();
                    this._alertDialog.action = null;
                    break;
                case "findNextComment":
                    this.gotoPage(1, false);
                    this.XLComment._updateCurrentCell(0, 0);
                    this.XLComment.findNextComment();
                    this._alertDialog.action = null;
                    break;
                case "sheetRenameActn":
                    $("#" + this._id + "_Sheet_RenamePanel").select().focus();
                    break;
                case "sheetDeleteActn":
                    this._removeSheet(sheetIdx);
                    this._alertDialog.action = null;
                    break;
                case "New":
                    this.blankWorkbook();
                    break;
                case "Open":
                    $("#" + this._id + "_file .e-uploadinput").click();
                    break;
                case "MergeCells":
                    this._mergeCells(sheetIdx, this.model.sheets[sheetIdx]._selectedCells, {}, []);
                    this._alertDialog.action = null;
                    break;
                case "MergeAcrossCells":
                    this._mergeAcrossCells(sheetIdx, this.model.sheets[sheetIdx]._selectedCells);
                    this._alertDialog.action = null;
                    break;
                case "MergeInsertDelete":
                    this._refreshMergeCells();
                    this._alertDialog.action = null;
                    break;
                case "InvalidChartTitleActn":
                    $('#' + this._id + '_chartnamedlg').find("input:first").focus();
                    break;
                case "ConvertToRange":
                    this.XLFormat._convertToRange({});
                    break;
                case "TotalRow":
                    this._isUndoRedo = this._dupDetails = true;
                    this.insertEntireRow(this._insRows.startRow, this._insRows.endRow);
                    this.XLFormat._calculateTotalRow(sheetIdx, null, true, false, true);
                    this._isUndoRedo = isUndoRedo;
                    break;
                case "Drop":
                    var sheet = this.getSheet(sheetIdx);
                    this.XLDragDrop.moveRangeTo([sheet._startCell.rowIndex, sheet._startCell.colIndex, sheet._endCell.rowIndex, sheet._endCell.colIndex], [this._dStartCell.rowIndex, this._dStartCell.colIndex, this._dEndCell.rowIndex, this._dEndCell.colIndex]);
                    sheet._startCell = this._dStartCell;
                    sheet._endCell = this._dEndCell;
                    this._trigger("drop", { sheetIndex: sheetIdx, target: this.XLDragDrop._target, currentCell: this.XLDragDrop._dragAndDropCell, dragAndDropRange: { startCell: sheet._startCell, endCell: sheet._endCell } });
                    break;
                case "FormulaAlert":
                    this.XLEdit._editElem.focus();
                    break;
                case "NMUniqueNameAlert":
                case "NMNameAlert":
                     document.getElementById(this._id + "_nmgridname") && document.getElementById(this._id + "_nmgridname").focus();
                    break;
                case "NMRangeAlert":
                    document.getElementById(this._id + "_nmgridrefersto") && document.getElementById(this._id + "_nmgridrefersto").focus();
                    break;
                case "OpenValDlg":
                    $("#" + this._id + "_ValDialog").ejDialog("open");
                    break;
                case "cellStyleAlert":
                    this._showDialog(this._id + "_CustomCellDialog");
                    break;
                default:
                    this.setSheetFocus();
                    break;
            }
        },
        blankWorkbook: function () {
            var i = 1, prtctWrkBk;
            this._isNew = true;
            this._destroy();
            this._dataContainer.sheets[i] = {};
            this.clearUndoRedo();
            this._updateCellType();
            this.model.sheetCount = i;
            this.model.activeSheetIndex = i;
            this._sheetSettings(i);
            this._newSIndex++;
            this._initCSSTag();
            this.gotoPage(i, false);
            if (this.model.allowLockCell)
                this.protectSheet(false);
            prtctWrkBk = $("#" + this._id + "_Ribbon_Review_Changes_ProtectWorkbook").data("ejToggleButton");
            if (prtctWrkBk) {
                prtctWrkBk.option("toggleState", false);
                this.model.exportSettings.password = null;
                $("#" + this._id + "_AddSheet").removeClass("e-disable");
            }
            this.XLRibbon._toggleFormatTab();
            this.XLRibbon._toggleChartDesignTab();
            this.XLRibbon._toggleAnalyzeTab();
            this._refreshSpreadSheetPager();
            this.hideWaitingPopUp();
            this._isNew = false;
        },
        _alertCanClick: function () {
            var dlg = this._alertDialog;
            if (dlg.action == "findNextComment" || dlg.action == "findPrevComment")
                $(this.getActiveCellElem()).find('.e-comment-txtarea').css('display', 'inline-table');
            if (dlg.action == "TotalRow" && $("#" + this._id + "_Ribbon_Design_TableStyleOptions_TotalRow").length) {
                this.XLRibbon._isSetModel = true;
                $("#" + this._id + "_Ribbon_Design_TableStyleOptions_TotalRow").data("ejCheckBox").option("checked", false);
                this.XLRibbon._isSetModel = false;
            }
            dlg.element && dlg.element.ejDialog("close");
            switch (dlg.action) {
                case "Drop":
                    var sheet = this.getSheet(this.getActiveSheetIndex());
                    this.performSelection(sheet._startCell, sheet._endCell);
                    break;
            }
            this.hideWaitingPopUp();
        },

        _showAlertDlg: function (type, prop, targetName, dlgWidth, className) {
            var alertDlg = $("#" + this._id + "_alertdlg"), alert = "Alert", text, args = { reqType: "alert", action: targetName };
            if (prop instanceof Array) {
                if (prop[0] === "SheetRenameEmptyAlert")
                    text = "<ul><li>" + this._getLocStr(prop[0]) + "</li><li>" + this._getLocStr(prop[1]) + "</li><li>" + this._getLocStr(prop[2]) + "\\ \/ ? * [" + this._getLocStr("OR") + "  ] </li><li>" + this._getLocStr(prop[3]) + "</li></ul>";
                else if (prop[0] === "ClipboardAccessError")
                    text = this._getLocStr(prop[0]) + "<br /><br />" + this._getLocStr(prop[1]) + "  = Ctrl + X <br />" + this._getLocStr(prop[2]) + "  = Ctrl + C <br />" + this._getLocStr(prop[3]) + "  = Ctrl + V";
            }
        	else {
				text = (prop.indexOf("T-") === 0) ? prop.slice(2) : this._getLocStr(prop);
				if(!text)
				   text = prop;
			}
            if (this._trigActionBegin(args)) {
                this._alertDialog.action = targetName;
                this._alertCanClick();
                return;
            }
            if (type === alert)
                this._renderAlertDlgContent(alertDlg, alert, text, targetName, dlgWidth, className);
            else
                this._renderAlertDlgContent(alertDlg, "", text, targetName, dlgWidth, className);
            alertDlg.ejDialog("open");
        },

        _isSheetsDirty: function () {
            var i = 1, sheets = this._dataContainer.sheets, len = this.getObjectLength(sheets) + 1;
            if (this.model.nameManager.length || this.getObjectLength(sheets) > 1)
                return true;
            while (i < len) {
                if (this.getObjectLength(sheets[i]))
                    return true;
                i++;
            }
            return false;
        },

        getCell: function (rowindex, columnindex, sheetIdx) {
            var index = 0, sheetIdx = this._getSheetIndex(sheetIdx), sheet = this.getSheet(sheetIdx);
            if (this.model.scrollSettings.allowVirtualScrolling) {
                index = 1;
                rowindex = this._getRowIdx(rowindex, sheetIdx);
                if (rowindex === -1)
                    return null;
            }
            if ((this.isImport || sheet._isImported || this._isPrint) && this._detachTable)
                return $(this._detachTable[0].tBodies[index].rows[rowindex].cells[columnindex]);
            else {
                if (this._getContTBody(sheetIdx))
                    return $(this._getContTBody(sheetIdx)[0].rows[rowindex].cells[columnindex]);
                else
                    return null;
            }
        },

        getRange: function (range, sheetIdx, skipHiddenRow) {
            range = this._getRangeArgs(range, "object", sheetIdx);
            var startRIndex = range[0], startCIndex = range[1], endRIndex = range[2], endCIndex = range[3], i, rowIdx, rows,
                rowCells, temp, len, tempCells, cells = [], sheetIdx = this._getSheetIndex(sheetIdx), sheet = this.getSheet(sheetIdx);
            if ((this.isImport || sheet._isImported) && this._detachTable)
                rows = $(this._detachTable[0].tBodies[1].rows);
            else
                rows = $(this._getContTBody(sheetIdx)[0].rows);
            if (startRIndex > endRIndex) {
                temp = startRIndex;
                startRIndex = endRIndex;
                endRIndex = temp;
            }
            if (startCIndex > endCIndex) {
                temp = startCIndex;
                startCIndex = endCIndex;
                endCIndex = temp;
            }
            if (this.model.scrollSettings.allowVirtualScrolling) {
                for (i = startRIndex; i <= endRIndex; i++) {
                    rowIdx = this._getRowIdx(i);
                    if (rowIdx > -1) {
                        rowCells = $(rows[rowIdx].cells);
                        tempCells = (endCIndex === startCIndex) ? [rowCells[endCIndex]] : this._browserDetails.version === "8.0" ? rowCells.slice(startCIndex, endCIndex + 1).toArray() : rowCells.slice(startCIndex, endCIndex + 1);
                        ej.merge(cells, tempCells);
                    }
                }
            }
            else {
                rows = (endRIndex !== startRIndex) ? rows.slice(startRIndex, endRIndex + 1) : rows.eq(endRIndex);
                len = rows.length;
                for (i = 0; i < len; i++) {
                    if (!skipHiddenRow || !this._isHiddenRow(i, sheetIdx)) {
                        rowCells = $(rows[i].cells);
                        tempCells = (endCIndex === startCIndex) ? [rowCells[endCIndex]] : this._browserDetails.version === "8.0" ? rowCells.slice(startCIndex, endCIndex + 1).toArray() : rowCells.slice(startCIndex, endCIndex + 1);
                        ej.merge(cells, tempCells);
                    }
                }
            }
            return $(cells);
        },

        getRangeIndices: function (range) {
            range = range.indexOf(":") === -1 ? range + ":" + range : range;
            var rangeIndex = range.split(":"), rangeData, cells = [];
            rangeData = rangeIndex[0].split(/[A-Z]/i);
            cells.push(parseInt(rangeData[rangeData.length - 1]) - 1);
            cells.push(this._generateColCount(rangeIndex[0].split(/[0-9]/)[0].toUpperCase()) - 1);
            rangeData = rangeIndex[1].split(/[A-Z]/i);
            cells.push(parseInt(rangeData[rangeData.length - 1]) - 1);
            cells.push(this._generateColCount(rangeIndex[1].split(/[0-9]/)[0].toUpperCase()) - 1);
            this.swapRange(cells);
            return cells;
        },

        swapRange: function (cells) {
            if (cells[0] > cells[2])
                ej.dataUtil.swap(cells, 0, 2);
            if (cells[1] > cells[3])
                ej.dataUtil.swap(cells, 1, 3);
            return cells;
        },

        updateRange: function (sheetIdx, rangeSettings) {
            if (this.model.isReadOnly)
                return;
            var i, r, len, obj, cont, rangeData, startCell, rangeCells, contTable, range = [], data = [], dataSource = rangeSettings.dataSource,
                rowCount = dataSource.length, colCount = this.getObjectLength(dataSource[0]);
            startCell = rangeSettings.startCell;
            if (rangeSettings.range)
                range = rangeSettings.range;
            else {
                rangeData = startCell.split(/[A-Z]/i);
                range.push(parseInt(rangeData[rangeData.length - 1]) - 1);
                range.push(this._generateColCount(startCell.split(/[0-9]/)[0].toUpperCase()) - 1);
                range.push(range[0] + rowCount - (rangeSettings.showHeader ? 0 : 1));
                range.push(range[1] + colCount - 1);
            }
            rangeCells = this._getSelectedRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] });
            cont = this._getContent(sheetIdx);
            contTable = this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content >table");
            if (!this.model.allowAutoCellType || !this.model.allowCellType)
                contTable.detach();
            if (rangeSettings.showHeader) {
                for (obj in dataSource[0])
                    data.push(obj);
            }
            for (r = 0; r < rowCount; r++) {
                if (dataSource[r] != undefined)
                    for (obj in dataSource[0])
                        data.push(dataSource[r][obj]);
            }
            this._dupDetails = true;
            for (i = 0, len = rangeCells.length; i < len; i++) {
                this.XLEdit._updateCell(rangeCells[i], data[i], sheetIdx);
                if (rangeSettings.showHeader && i < colCount) {
                    range = rangeSettings.startCell + ":" + (this._generateHeaderText(rangeCells[rangeCells.length - 1].colIndex + 1) + (rangeCells[0].rowIndex + 1));
                    if (rangeSettings.headerStyles)
                        this.XLFormat.format({ style: rangeSettings.headerStyles }, range);
                }
            }
            this._dupDetails = false;
            if (!this.model.allowAutoCellType || !this.model.allowCellType)
                cont.find(".e-content").append(contTable);
            if (!this._isUndoRedo) {
				var details = { sheetIndex: sheetIdx, reqType: "update-range", rangeSettings: rangeSettings };
                this._completeAction(details);
                this._trigActionComplete(details);
            }
        },

        editRange: function (rangeName, fn) {
            var i, j, len, cell, cont, data, contTable, $cell, sheetIdx = this.getActiveSheetIndex(),
                rangeInfo = this.getSheet(sheetIdx).rangeSettings[rangeName], range = this.getRangeIndices(rangeInfo.range),
                rangeCells = this.getRange(range);
            this._trigger("editRangeBegin", { range: rangeInfo, sheetIndex: sheetIdx });
            if (rangeInfo.cssClass)
                rangeCells.addClass(rangeInfo.cssClass);
            if (rangeInfo.readOnly)
                rangeCells.addClass("e-readonly");
            cont = this._getContent(sheetIdx);
            contTable = this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content >table");
            contTable.detach();
            for (i = 0, len = rangeCells.length; i < len; i++) {
                cell = rangeCells[i], $cell = $(cell);
                if ($.trim(rangeName).length)
                    this.XLEdit._updateDataContainer({ rowIndex: cell.parentNode.rowIndex, colIndex: cell.cellIndex }, { dataObj: { range: rangeName } });
                data = fn(cell, cell.cellIndex, i);
                if (typeof data === 'string')
                    this.XLEdit._updateCell({ rowIndex: cell.parentNode.rowIndex, colIndex: cell.cellIndex }, data);
                else if (typeof data === 'object') {
                    if (data.Value.indexOf("=") !== 0)
                        this.XLEdit._updateCell({ rowIndex: cell.parentNode.rowIndex, colIndex: cell.cellIndex }, data.Value);
                    else
                        this.XLEdit._updateCellValue({ rowIndex: cell.parentNode.rowIndex, colIndex: cell.cellIndex }, data.Value);
                    $cell.data("value2", data.Value2);
                    $cell.data("type", data.NumberFormat);
                    if (data.StyleIndex > 1)
                        $cell.addClass(this._styleColl[data.StyleIndex]);
                }
            }
            cont.find(".e-content").append(contTable);
            for (j = range[0]; j < range[2] + 1 ; j++)
                this._setRowHdrHeight(sheetIdx, j);
            this._trigger("editRangeComplete", { range: rangeInfo, sheetIndex: sheetIdx });
            this.XLScroll._getRowHeights(sheetIdx, range[0]);
        },

        removeRange: function (rangeName) {
            this.clearRange(rangeName);
            delete this.getSheet(this.getActiveSheetIndex()).rangeSettings[rangeName];
        },

        clearRange: function (rangeName) {
            if (this.model.isReadOnly)
                return;
            var range, rangeCells, rangeInfo = this.getSheet(this.getActiveSheetIndex()).rangeSettings[rangeName];
            range = this.getRangeIndices(rangeInfo.range);
            rangeCells = this.getRange(range);
            if (rangeInfo.cssClass)
                rangeCells.removeClass(rangeInfo.cssClass);
            if (rangeInfo.readOnly)
                rangeCells.removeClass("e-readonly");
            this.clearRangeData(null, ["range", "value", "type", "value2"], rangeCells);
            rangeCells.empty();
        },

        getObjectLength: function (obj) {
            var i, cnt = 0;
            obj = Object.prototype.toString.call(obj) === Object.prototype.toString() ? obj : {};
            if (Object.keys)
                return Object.keys(obj).length;
            for (i in obj) {
                if (obj.hasOwnProperty(i))
                    cnt++;
            }
            return cnt;
        },

        getObjectKeys: function (obj) {
            var i, keys = [];
            obj = Object.prototype.toString.call(obj) === Object.prototype.toString() ? obj : {};
            if (!Object.keys) {
                for (i in obj) {
                    if (obj.hasOwnProperty(i))
                        keys.push(i);
                }
                return keys;
            }
            if (Object.keys)
                return Object.keys(obj);
        },

        toArrayLowerCase: function (args) {
            for (var i = 0; i < args.length; i++)
                args[i] = args[i].toString().toLowerCase();
            return args;
        },

        _isValueAlreadyExist: function (arrObj, key, value) {
            var i = 0, len = arrObj.length;
            while (i < len) {
                if (arrObj[i][key] === value)
                    return true;
                i++;
            }
            return false;
        },

        addClass: function (elem, classname) {
            if (!elem || elem.localName === "svg" || elem.localName === "path" || elem.localName === "rect")
                return;
            if (elem instanceof jQuery || elem instanceof Array)
                elem = elem[0];
            var classes = elem.className;
            if (classes.indexOf(classname) === -1)
                elem.className = classes + " " + classname;
        },

        _removeClass: function (elem, className) {
            if (!elem)
                return;
            if (elem instanceof jQuery || elem instanceof Array)
                elem = elem[0];
            elem.className = className ? elem.className.replace(new RegExp(className, "g"), '').replace(/ +/g, ' ') : "";
        },

        _hasClass: function (elem, className) {
            if (!elem)
                return false;
            if (elem instanceof jQuery || elem instanceof Array)
                elem = elem[0];
            if (!elem || this._isAnimatedString(elem.className))
                return false;
            return elem.className.indexOf(className) > -1;
        },

        isUndefined: function (val) {
            return val === undefined;
        },

        _isString: function (obj) {
            return typeof obj === "string";
        },

        _isEmptyString: function (val) {
            return !val.toString().length;
        },

        _isObject: function (obj) {
            if (typeof obj !== "object")
                return false;
            return Object.prototype.toString.call(obj) === "[object Object]";
        },
        _getObjectValues: function (obj) {
            var i, values = [];
            obj = Object.prototype.toString.call(obj) === Object.prototype.toString() ? obj : {};
            for (i in obj)
                obj.hasOwnProperty(i) && values.push(obj[i]);
            return values;
        },

        _isAnimatedString: function (className) {
            return Object.prototype.toString.call(className) === "[object SVGAnimatedString]";
        },

        _isBool: function (val) {
            val = val + '';
            val = val.toUpperCase();
            return (val === "TRUE" || val === "FALSE");
        },

        isRange: function (range) {            
            return range && (range[0] !== range[2] || range[1] !== range[3]);
        },

        _isMultiRange: function (range) {
            return !this._isString(range) && !this.isNumber(range[0]);
        },

        inRange: function (range, rowIdx, colIdx) {
            return range && (rowIdx >= range[0] && rowIdx <= range[2] && colIdx >= range[1] && colIdx <= range[3]);
        },

        _inRow: function (range, rowIdx) {
            return range && (rowIdx >= range[0] && rowIdx <= range[2]);
        },

        _inColumn: function (range, colIdx) {
            return range && (colIdx >= range[1] && colIdx <= range[3]);
        },

        _isUniqueRange: function (oldRange, newRange) {
            return oldRange.toString() === newRange.toString();
        },

        _isUniqueTarget: function (sevt, eevt) {
            var epos = this._getOriginalEvt(eevt), etrgt = document.elementFromPoint(epos.clientX, epos.clientY);
            return sevt.target === etrgt;
        },

        _getClientDiff: function (sXY, eXY) {
            return {
                x: sXY[0] - eXY[0],
                y: sXY[1] - eXY[1]
            };
        },

        hasSpan: function (cellIdx) {
            return this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex, "merge") ? true : false;
        },

        _isFrozen: function (idx) {
            return idx > 0;
        },

        _isSelected: function (trgt) {
            if (this._hasClass(trgt, "e-selected") || this._hasClass(trgt, "e-rowselected") || this._hasClass(trgt, "e-colselected") || $(trgt).parents(".e-colselected").length)
                return true;
            return false;
        },

        _getMergedIdx: function (rowIdx, colIdx) {
            var range, minr, maxr, minc, maxc, i, sheet, rcount, ccount, sheetIdx = this.getActiveSheetIndex(), merge = this.XLEdit.getPropertyValue(rowIdx, colIdx, "merge", sheetIdx);
            rcount = ccount = 0;
            if (merge) {
                if (merge.mRange) {
                    range = this.getRangeIndices(merge.mRange);
                    sheet = this.getSheet(sheetIdx);
                    if (sheet.hideRowsCollection.length) {
                        minr = range[0], maxr = range[2];
                        if (maxr - minr > 1) {
                            i = minr + 1;
                            while (i < maxr) {
                                if (this.XLEdit.getPropertyValue(i, 0, ["isRHide"], sheetIdx))
                                    rcount++;
                                i++;
                            }
                        }
                    }
                    if (this.getObjectLength(sheet.hideColsCollection)) {
                        minc = range[1], maxc = range[3];
                        if (maxc - minc > 1) {
                            i = minc + 1;
                            while (i < maxc) {
                                if (this.XLEdit.getPropertyValue(0, i, ["isCHide"], sheetIdx))
                                    ccount++;
                                i++;
                            }
                        }
                    }
                }
                if (merge.mSpan) {
                    return { rowIndex: rowIdx + merge.mSpan.rowSpan + rcount - 1, colIndex: colIdx + merge.mSpan.colSpan + ccount - 1 };
                }
            }
            return { rowIndex: rowIdx, colIndex: colIdx };
        },

        _getMergeParent: function (rowIdx, colIdx) {
            var mIndex = this.XLEdit.getPropertyValue(rowIdx, colIdx, "mergeIdx");
            if (mIndex)
                return { rowIndex: mIndex.rowIndex, colIndex: mIndex.colIndex };
            return { rowIndex: rowIdx, colIndex: colIdx };
        },

        _getCellInfo: function (cellIdx, sheetIdx) {
            var sheet = this.getSheet(this._getSheetIndex(sheetIdx)), top, left, merge, width = 0, height = 0, mSpan;
            top = (cellIdx.rowIndex >= sheet._frozenRows) ? sheet._rowHeightCollection[cellIdx.rowIndex] - (sheet._rowHeightCollection[sheet._ftopRowIdx] - sheet._rowHeightCollection[sheet._frozenRows - 1]) : sheet._rowHeightCollection[cellIdx.rowIndex];
            left = (cellIdx.colIndex >= sheet._frozenColumns) ? sheet._colWidthCollection[cellIdx.colIndex] - (sheet._colWidthCollection[sheet._fleftColIdx] - sheet._colWidthCollection[sheet._frozenColumns - 1]) : sheet._colWidthCollection[cellIdx.colIndex];
            merge = this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex, "merge");
            if (merge) {
                mSpan = merge.mSpan;
                for (var i = 0; i < mSpan.rowSpan; i++)
                    height += sheet.hideRowsCollection.indexOf(cellIdx.rowIndex + i) === -1 ? sheet.rowsHeightCollection[cellIdx.rowIndex + i] : 0;
                for (var i = 0; i < mSpan.colSpan; i++)
                    width += sheet.columnsWidthCollection[cellIdx.colIndex + i];
            }
            else {
                height = sheet.hideRowsCollection.indexOf(cellIdx.rowIndex) === -1 ? sheet.rowsHeightCollection[cellIdx.rowIndex] : 0,
                width = sheet.columnsWidthCollection[cellIdx.colIndex];
            }
            return {
                top: top - 1,
                left: left - 1,
                height: height,
                width: width
            };
        },

        _getRowIdx: function (rowIdx, sheetIdx, isArrIdx, isRowIdx) {
            var idx, sheet = this.getSheet(sheetIdx);
            if (isArrIdx) {
                idx = sheet._rowIdxColl[rowIdx];
                rowIdx = this.isUndefined(idx) ? sheet._rowIdxColl[sheet._rowIdxColl.length - 1] : idx;
            }
            else if (isRowIdx) {
                idx = sheet._rowIdxColl.indexOf(rowIdx);
                rowIdx = idx === -1 ? rowIdx : idx;
            }
            else if (this.model.scrollSettings.allowScrolling && this.model.scrollSettings.allowVirtualScrolling)
                rowIdx = sheet._virtualRowIdx.indexOf(rowIdx);
            return rowIdx;
        },

        _getMinRowIdx: function (sheet) {
            for (var i = 0; i < sheet.rowCount; i++) {
                if (sheet.hideRowsCollection.indexOf(i) === -1 && sheet._hiddenFreezeRows.indexOf(i) === -1)
                    return i;
            }
            return 0;
        },

        _arrayAsString: function (arr) {
            return arr.join(" ").replace(/,/g, " ");
        },

        _rangeHasData: function (range) {
            var cells, i, cellIdx;
            range = this.swapRange(range);
            cells = this._getSelectedRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] });
            i = cells.length;
            while (i--) {
                cellIdx = cells[i];
                if (this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex))
                    return true;
            }
            return false;
        },

        _isTableRange: function (rowIdx, colIdx, sheetIdx) {
            sheetIdx = this._getSheetIndex(sheetIdx);
            var i, tmngr = this.getSheet(sheetIdx).tableManager;
            for (i in tmngr) {
                if (this.inRange(tmngr[i].range, rowIdx, colIdx))
                    return true;
            }
            return false;
        },

        _hasCellStyle: function (rowIdx, colIdx, sheetIdx) {
            var style, props = ["borders", "formats"], i = props.length;
            while (i--) {
                style = this.XLEdit.getPropertyValue(rowIdx, colIdx, props[i], sheetIdx);
                if (style)
                    return true;
            }
            return false;
        },

        _isHiddenRow: function (rowIdx, sheetIdx) {
            return (this.XLEdit.getPropertyValue(rowIdx, 0, "isFilterHide", sheetIdx) || this.XLEdit.getPropertyValue(rowIdx, 0, "isRHide", sheetIdx)) || false;
        },

        _refreshViewVar: function (top, left, sheetIdx) {
            sheetIdx = this._getSheetIndex(sheetIdx);
            var rowIdx, sheet = this.getSheet(sheetIdx);
            if (!ej.isNullOrUndefined(top)) {
                sheet._topRow.idx = this.XLShape._getCellIndexFromOffset(top, null, sheetIdx).rowIndex;
                sheet._topRow.value = this._getRowOffsetTop(sheet, sheet._topRow.idx);
                sheet._bottomRow.idx = sheet._rowIdxColl[sheet._topRow.idx + (sheet._virtualBlockRowCnt - this._bufferCnt - 1)]; // -1 as virtualblockrowcnt is 1 index based.
                sheet._bottomRow.value = this._getRowOffsetTop(sheet, sheet._bottomRow.idx);
                sheet.topLeftCell = this.getAlphaRange(sheet._topRow.idx, sheet._leftCol.idx);
            }
            if (!ej.isNullOrUndefined(left)) {
                sheet._leftCol.idx = this.XLShape._getCellIndexFromOffset(null, left, sheetIdx).colIndex;
                sheet._leftCol.value = this._getColOffsetLeft(sheet, sheet._leftCol.idx);
                sheet._rightCol.idx = this.XLShape._getCellIndexFromOffset(null, left + sheet._vPortWth, sheetIdx).colIndex || sheet.colCount - 1;
                sheet._rightCol.value = this._getColOffsetLeft(sheet, sheet._rightCol.idx);
                sheet.topLeftCell = this.getAlphaRange(sheet._topRow.idx, sheet._leftCol.idx);
            }
        },

        _getFormatString: function (type, decimalplace) {
            var formatstr = ej.Spreadsheet.CellFormat[type];
            if (this.isNumber(decimalplace) && !ej.isNullOrUndefined(formatstr))
                formatstr = "{0:" + formatstr.substr(3, 1) + decimalplace + "}";
            return formatstr || "";
        },

        _refreshVrtlBlocks: function (sheetIdx) {
            var rowIdx, i, idx, cnt = 3, arr = ["_virtualTopTBodyOffset", "_virtualContTBodyOffset", "_virtualBottomTBodyOffset"],
                sheetIdx = this._getSheetIndex(sheetIdx), sheet = this.getSheet(sheetIdx);
            i = idx = 0;
            while (i < cnt) {
                if ((!i && !sheet._isVirtualTopReached) || i === 1 || (i === 2 && !sheet._isVirtualEndReached)) {
                    rowIdx = sheet._virtualRowIdx[idx];
                    sheet[arr[i]].top = this._getRowOffsetTop(sheet, rowIdx);
                    idx += sheet._virtualBlockRowCnt;
                    rowIdx = sheet._virtualRowIdx[idx - 1];
                    sheet[arr[i]].bottom = this._getRowOffsetBottom(rowIdx, sheetIdx);
                }
                i++;
            }
            sheet._virtualTBodyHgt = sheet._rowHeightCollection[sheet._rowHeightCollection.length - 1] + sheet.rowsHeightCollection[sheet.rowsHeightCollection.length - 1];
        },

        getRangeDataAsObject: function (startcell, endcell, skipHiddenRow) {
            var i, columnName, celldata, temp, formatTemp, ctype = ej.Spreadsheet.CellType, container = this._dataContainer, sheetIdx = this.getActiveSheetIndex(),
                sheetdata = container.sheets[this.getActiveSheetIndex()], minrindex, maxrindex, mincindex, maxcindex, rangeData = [], formattedRangeData = [], data = [];
            startcell.rowIndex > endcell.rowIndex ? (minrindex = endcell.rowIndex, maxrindex = startcell.rowIndex) : (minrindex = startcell.rowIndex, maxrindex = endcell.rowIndex);
            startcell.colIndex > endcell.colIndex ? (mincindex = endcell.colIndex, maxcindex = startcell.colIndex) : (mincindex = startcell.colIndex, maxcindex = endcell.colIndex);
            while (minrindex <= maxrindex) {
                if (!skipHiddenRow || !this._isHiddenRow(minrindex)) {
                    temp = {}, formatTemp = {};
                    for (i = mincindex; i <= maxcindex; i++) {
                        columnName = this._generateHeaderText(i + 1);
                        if (minrindex in sheetdata && i in sheetdata[minrindex]) {
                            celldata = sheetdata[minrindex][i];
                            temp[columnName] = container.sharedData[celldata.value];
                            formatTemp[columnName] = [ctype.General, ctype.Text].indexOf(container.cellType[celldata.type]) === -1 ? celldata.value2 : container.sharedData[celldata.value2];
                        }
                    }
                    rangeData.push(temp);
                    formattedRangeData.push(formatTemp);
                }
                minrindex++;
            }
            data.push(rangeData);
            data.push(formattedRangeData);
            return data;
        },

        getRangeDataAsJSON: function (startcell, endcell, skipHiddenRow, sheetIdx) {
            var i, columnName, celldata, formatTemp, ctype = ej.Spreadsheet.CellType, container = this._dataContainer, sheetdata = container.sheets[sheetIdx ? sheetIdx : this.getActiveSheetIndex()], minrindex, maxrindex, mincindex, maxcindex;
            var formattedRangeData = [], isHeader = true, columns = [], value;
            if (startcell.rowIndex > endcell.rowIndex) {
                minrindex = endcell.rowIndex;
                maxrindex = startcell.rowIndex;
            }
            else {
                minrindex = startcell.rowIndex;
                maxrindex = endcell.rowIndex;
            }
            if (startcell.colIndex > endcell.colIndex) {
                mincindex = endcell.colIndex;
                maxcindex = startcell.colIndex;
            }
            else {
                mincindex = startcell.colIndex;
                maxcindex = endcell.colIndex;
            }
            while (minrindex <= maxrindex) {
                if (!skipHiddenRow || !this._isHiddenRow(minrindex)) {
                    formatTemp = {};
                    for (i = mincindex; i <= maxcindex; i++) {
                        if (!isHeader) {
                            columnName = columns[i];
                            if (minrindex in sheetdata && i in sheetdata[minrindex]) {
                                celldata = sheetdata[minrindex][i];
                                if (!this.isUndefined(celldata.type) && ([ctype.General, ctype.Text].indexOf(container.cellType[celldata.type]) === -1))
                                    value = celldata.value2;
                                else
                                    value = container.sharedData[celldata.value2];
                                if (!ej.isNullOrUndefined(value))
                                    formatTemp[columnName] = this.isNumber(value) ? parseInt(value) : value;
								else
								formatTemp[columnName] = "";
                            }
							else
							formatTemp[columnName] = "";
                        }
                        else if (minrindex in sheetdata && i in sheetdata[minrindex]) {
                            celldata = sheetdata[minrindex][i];
                            if (!this.isUndefined(celldata.type) && ([ctype.General, ctype.Text].indexOf(container.cellType[celldata.type]) === -1))
                                columns[i] = celldata.value2;
                            else
                                columns[i] = container.sharedData[celldata.value2];
                        }
                    }
                    if (!isHeader && this.getObjectLength(formatTemp)) {
                        formattedRangeData.push(formatTemp);
                    }
                }
                minrindex++;
                if (isHeader)
                    isHeader = false;
            }
            return formattedRangeData;
        },

        _getColorFromFormat: function (format) {
            var color = [], hashCode, fgcolor, bgcolor;
            if (!ej.isNullOrUndefined(format)) {
                hashCode = format.replace("e-format", "").toLowerCase();
                (hashCode.startsWith("6n")) ? fgcolor = "#" + hashCode.substr(2, 6) : fgcolor = "#" + hashCode.substr(6, 6);
                bgcolor = "#" + hashCode.substr(0, 6);
                color.push(bgcolor);
                color.push(fgcolor);
            }
            return color;
        },

        getRangeData: function (options) {
            options = options || {};
            options.sheetIdx = this._getSheetIndex(options.sheetIdx);
            options.range = this._toIntrnlRange(options.range, options.sheetIdx);
            options.property = options.property || ["value", "value2", "type", "formatStr", "decimalPlaces", "thousandSeparator", "range", "format", "border", "comment", "hyperlink", "picture", "cFormatRule", "rule", "chart", "isLocked", "wrap", "formats", "cellType", "altTxt"];
            var i = 0, len, minc, minr, maxr, maxc, isHiddenRow, skipVirtualHiddenRow, rowIdx = [], arr = [], sheet = this.getSheet(options.sheetIdx);
            if (options.rowIdxs) {
                len = options.rowIdxs.length;
                while (i < len) {
                    this._pushRowData(options, options.rowIdxs[i], 0, sheet.colCount - 1, arr, rowIdx);
                    i++;
                }
            }
            else {
                skipVirtualHiddenRow = false;
                if (this.model.scrollSettings.allowVirtualScrolling && options.skipHiddenRow && !ej.isNullOrUndefined(options.virtualRowIdx)) {
                    skipVirtualHiddenRow = true;
                    minr = options.virtualRowIdx;
                    maxr = minr + (options.virtualRowCount - 1);
                    maxc = sheet.colCount - 1;
                }
                else {
                    minr = options.range[0];
                    maxr = options.range[2];
                    maxc = options.range[3];
                }
                while (minr <= maxr) {
                    isHiddenRow = this._isHiddenRow(minr, options.sheetIdx);
                    if (skipVirtualHiddenRow && isHiddenRow)
                        maxr++;
                    else if (!options.skipHiddenRow || !isHiddenRow) {
                        minc = skipVirtualHiddenRow ? 0 : options.range[1];
                        this._pushRowData(options, minr, minc, maxc, arr, rowIdx, true);
                    }
                    minr++;
                }
            }
            return options.withRowIdx ? { rowIdx: rowIdx, data: arr } : arr;
        },

        _pushRowData: function (options, minr, minc, maxc, arr, rowIdx, isDataSrcEnsured) {
            var val, obj, prop, cellData, sharedData, value = "value", intrnlUpdate = this._intrnlUpdate, container = this._dataContainer, sheetdata = container.sheets[options.sheetIdx];
            if (!isDataSrcEnsured)
                this.XLEdit._refreshContainer(minr, options.sheetIdx);
            if (sheetdata[minr]) {
                if (options.valueOnly) {
                    while (minc <= maxc) {
                        val = "";
                        cellData = sheetdata[minr][minc];
                        if (cellData && value in cellData) {
                            sharedData = container.sharedData;
                            val = sharedData[cellData[value]];
                            if (options.skipDateTime && this._isDateTime(val))
                                val = this.XLEdit.getPropertyValue(minr, minc, "value2", options.sheetIdx);
                            else if (options.skipFormula && this.isFormula(val)) {
                               val = this.XLEdit.getPropertyValue(minr, minc, "calcValue", options.sheetIdx);
                               if (this.isUndefined(val)) {
                                   val = this.XLEdit.getPropertyValue(minr, minc, "value2", options.sheetIdx);
                                   val = this.XLEdit._parseValue(val).value;
                               }
                            }
                        }
                        if (!options.skipEmptyCell || (!this.isUndefined(val) && val.toString().length))
                            arr.push(val);
                        minc++;
                    }
                }
                else {
                    this._intrnlUpdate = true;
                    while (minc <= maxc) {
                        cellData = sheetdata[minr][minc];
                        if (cellData) {
                            obj = {};
                            for (prop in cellData) {
                                if (options.property.indexOf(prop) > -1)
                                    obj[prop] = this.XLEdit.getPropertyValue(minr, minc, prop, options.sheetIdx);
                            }
                            if (!options.skipEmptyCell || this.getObjectLength(obj))
                                arr.push(obj);
                        }
                        else if (!options.skipEmptyCell)
                            arr.push({});
                        minc++;
                    }
                    this._intrnlUpdate = intrnlUpdate;
                }
            }
            else if (!options.skipEmptyCell) {
                while (minc <= maxc) {
                    options.valueOnly ? arr.push("") : arr.push({});
                    minc++;
                }
            }
            rowIdx.push(minr);
        },

        _processBindings: function (args) {
            this.model.query = new ej.Query();
            if (this._trigger("actionBegin", args))
                return true;
            this._ensureDataSource(args);
            if (args.action === "sorting") {
                this.XLSort._sortComplete(args);
                if (!this._isUndoRedo) {
                    this._completeAction(args);
                    this._trigActionComplete(args);
                }
            }
            else {
                this._completeAction(args);
                this._trigActionComplete(args);
            }
        },

        _ensureDataSource: function (args) {
            var dataSource, dataSrc, prop, predicate, predicates, obj, result, tblrange, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx);
            if (args.action === "filtering" || args.action === "clearfiltering" || args.requestType === "filterbycell") {
                dataSource = (sheet.filterSettings.filteredRange == null) ? this._dataSource(sheetIdx) : sheet.filterSettings.filteredRange;
                tblrange = sheet.filterSettings.tableRange;
                for (var i = 0, len = tblrange.length; i < len; i++) {
                    if (tblrange[i].tableID === args.tableID) {
                        tblrange[i].filteredRange = dataSource;
                        break;
                    }
                }
                this._dataManager = ej.DataManager(dataSource);
                if (!(dataSource instanceof ej.DataManager))
                    this.model.currentViewData = dataSource;
                this.model.query.requiresCount();
                if (args.filteredcolumns.length) {
                    predicates = this._excelFilter._predicates[sheetIdx];
                    dataSrc = dataSource[0];
                    for (prop in predicates) {
                        (dataSrc.hasOwnProperty(prop)) && (obj = predicates[prop]);
                        obj = predicates[prop];
                        predicate = predicate != undefined ? predicate["and"](obj) : obj;
                    }
                    if (!ej.isNullOrUndefined(predicate))
                        this.model.query.where(predicate);
                    if (!(dataSource instanceof ej.DataManager)) {
                        result = this._dataManager.executeLocal(this.model.query);
                        this._filteredRecordsCount = result.count;
                        this.model.currentViewData = result.result;
                    }
                }
            }
            else if (args.requestType === "sorting") {
                this._dataManager = ej.DataManager(args.rangeData);
                if (!(args.rangeData instanceof ej.DataManager))
                    this.model.currentViewData = args.rangeData;
                this.model.query.sortBy(args.columnName, args.sortDirection);
                if (!(args.rangeData instanceof ej.DataManager)) {
                    result = this._dataManager.executeLocal(this.model.query);
                    this.model.currentViewData = result;
                }
            }
            this._dataManager = null;
        },

        _toArrayData: function (args) {
            var prop, obj, i = 0, temp = [], len = args.length;
            while (i < len) {
                obj = args[i];
                if (this.getObjectLength(obj)) {
                    for (prop in obj)
                        temp.push(obj[prop]);
                }
                else
                    temp.push("");
                i++;
            }
            return temp;
        },

        _updateRangeStyle: function (range, data, status) {
            var cells = this._getSelectedRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] });
            for (var i = 0; i < cells.length; i++) {
                if (this.model.allowCellFormatting && this.XLFormat._hasFormat(data[i].format)) {
                    this.XLFormat._updateFormatClass(cells[i], data[i].format);
                    this.XLEdit._updateDataContainer(cells[i], { dataObj: { formats: data[i].formats }, sheetIdx: this.getActiveSheetIndex(), status: status });
                }
            }
        },

        updateRangeData: function (range, data) {
            if (this.model.isReadOnly)
                return;
            range = this._getRangeArgs(range, "object");
            if (range.length) {
                range.startCell = { rowIndex: range[0], colIndex: range[1] };
                range.endCell = { rowIndex: range[2], colIndex: range[3] };
            }
            var cells = this._getSelectedRange(range.startCell, range.endCell), dataArray = this._toArrayData(data);
            if (dataArray.length === cells.length) {
                for (var i = 0; i < cells.length; i++) {
                    if (!ej.isNullOrUndefined(dataArray[i]))
                        this.XLEdit._updateCellValue(this.getCell(cells[i].rowIndex, cells[i].colIndex), dataArray[i]);
                }
            }
        },

        updateData: function (datas, range, status) {
            if (this.model.isReadOnly)
                return;
            var i, j, k, l, val, cell, isWrap, data, hlData, m = 0, clrFrmt = "clear-format", formatObj = {}, props = this._cellProp,
                sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx);
            range = this._getRangeArgs(range, "object");
            i = range[0], j = range[2], l = range[3];
            while (i <= j) {
                k = range[1];
                while (k <= l) {
                    data = datas[m];
                    cell = this.getCell(i, k, sheetIdx);
					if("wrap" in data) {
						isWrap = true;
						delete data["wrap"];
					}					    
                    this.XLEdit._updateDataContainer({ rowIndex: i, colIndex: k }, { dataObj: data });
					isWrap && this.setWrapText("wrap", range);
					isWrap = false;
                    if (cell) {
                        if (props[13] in data) {
                            hlData = data.hyperlink;
                            if (hlData) {
                                if (status === clrFrmt)
                                    cell.find("a").css({ "color": this._hlColor, "text-decoration": "underline" }).addClass("e-hyperlinks");
                                else
                                    hlData.webAddr ? (cell.html(ej.buildTag("a", data.value2, "", { href: hlData.webAddr, target: "_blank", "class": "e-hyperlinks" }))) : (cell.html(ej.buildTag("a", data.value2, "", {"class": "e-hyperlinks" })));
                            }
                        }
						if (props[6] in data) {
                            if (data.rule.isApply)
								this.addClass(cell[0], 'e-hlcell');
							else
								this._removeClass(cell[0], 'e-hlcell');
                        }
                        if (status === clrFrmt) {
                            if (data.formatStr)
                                formatObj.formatStr = data.formatStr;
                            if (data.type)
                                formatObj.type = data.type;
                            if (!ej.isNullOrUndefined(data.decimalPlaces))
                                formatObj.decimalPlaces = data.decimalPlaces;
                            if (!ej.isNullOrUndefined(data.thousandSeparator))
                                formatObj.thousandSeparator = data.thousandSeparator;
                            this.XLFormat.format(formatObj, [i, k, i, k]);
                        }
                        if (props[21] in data)
                            this.XLComment._updateCmntFrmCntnr(i, k);
                        if (props[0] in data) {
                            val = data.value;
                            this.XLEdit._refreshCalcEngine(i, k, this.isFormula(val), val);
                        }
                    }
                    m++;
                    k++;
                }
                i++;
            }
        },

        updateUniqueData: function (data, range, skipCell, sheetIndex) {
            if (this.model.isReadOnly)
                return;
            range = this._getRangeArgs(range, "object");
            var minc, args = { dataObj: data }, minr = range[0], maxr = range[2], maxc = range[3];
            if (skipCell)
                args.skipCell = skipCell;
            args.sheetIdx = sheetIndex;
            while (minr <= maxr) {
                minc = range[1];
                while (minc <= maxc) {
                    this.XLEdit._updateDataContainer({ rowIndex: minr, colIndex: minc }, args);
                    minc++;
                }
                minr++;
            }
        },

        clearRangeData: function (range, property, cells, skipHiddenRow, status, skipCell) {
            if (this.model.isReadOnly)
                return;
            var minr, minc, maxr, maxc, sheetIdx = this.getActiveSheetIndex();
            range = this._getRangeArgs(range, "object", sheetIdx);
            property = property ? property : ["value", "value2", "type", "formatStr", "decimalPlaces", "thousandSeparator", "hyperlink", "isFilterHighlight"];
            minr = range[0], maxr = range[2], maxc = range[3];
            while (minr <= maxr) {
                if (!skipHiddenRow || !this._isHiddenRow(minr)) {
                    minc = range[1];
                    while (minc <= maxc) {
                        this.XLEdit._clearDataContainer({ cellIdx: { rowIndex: minr, colIndex: minc }, property: property, status: status, skipCell: skipCell });
                        minc++;
                    }
                }
                if (property.indexOf("wrap") > -1)
                    this._setRowHdrHeight(sheetIdx, minr);
                minr++;
            }
        },

        _getArrayRangeCells: function (range) {  // return cells if range specified else selected cells will returned
            return range ? (range = this.swapRange(range), this.getRange(range)) : this._getContent(this.getActiveSheetIndex()).find(".e-selected");
        },

        _getAlphaRangeCells: function (range) { // get range cells by alpha range input
            return range ? (range = this.getRangeIndices(range), this.getRange(range)) : this._getContent(this.getActiveSheetIndex()).find(".e-selected");
        },

        _getMultiRangeCells: function (range) {
            var i, val, cells, arr, len;
            if (!range) {
                range = this._getRangeArgs(range, "object");
                cells = this._getSelectedCells(this.getActiveSheetIndex(), range).selCells;
            }
            else {
                i = 0, cells = [], arr = [];
                if (this._isString(range))
                    arr.push(this.getRangeIndices(range));
                else {
                    if (this.isNumber(range[0]))
                        arr.push(range);
                    else {
                        len = range.length;
                        while (i < len) {
                            val = range[i];
                            arr.push(Array.isArray(val) ? val : this.getRangeIndices(val));
                            i++;
                        }
                    }
                }
                i = 0, len = arr.length;
                while (i < len) {
                    val = arr[i];
                    cells = cells.concat(this._getSelectedRange({ rowIndex: val[0], colIndex: val[1] }, { rowIndex: val[2], colIndex: val[3] }));
                    i++;
                }
            }
            return cells;
        },

        _completeAction: function (args) {
            var len, sheetIndex = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIndex), details, fltrdIdxes, fltrdVal;
            if (args.reqType === "filter" || args.reqType === "filterbycolor") {
                if (args.operation !== "apply-filter" && args.operation !== "remove-filter" && args.operation !== "clearfilter") {
                    fltrdVal = args.model.currentViewData;
                    details = {
                        sheetIndex: sheetIndex,
                        range: sheet._selectedRange,
                        currentViewData: fltrdVal,
                        fieldName: args.currentFilteringColumn,
                        ejpredicate: args.ejpredicate,
                        activeCell: args.activeCell,
                        filteredValue: args.filteredValue,
                        filterCollection: args.filteredcolumns,
                        requestType: args.requestType,
                        reqType: args.reqType,
                        selectedCell: args.selectedCell,
                        action: args.action,
                        operation: "filter",
                        selectedDataSource: sheet.selectedDataSource,
                        tableID: args.tableID,
                        filteredCells: args.filteredCells,
                        fltrdIdxes: [],
                        selRange: args.selRange
                    };
                    for (i = 0, len = fltrdVal.length; i < len; i++)
                        details.fltrdIdxes.push(details.range.startRow + sheet.filterSettings.filteredRange.indexOf(fltrdVal[i]));
                }
                else if (args.operation === "remove-filter" || args.operation === "clearfilter")
                    details = args;
                else
                    details = { sheetIndex: sheetIndex, filteredCells: args.filteredCells, reqType: "filter", operation: "apply-filter", tableID: args.tableID, fRange: this.getSheet(sheetIndex).filterSettings.range };
                details.rowIndex = args.rowIndex;
                details.colIndex = args.colIndex;
            }
            else if (args.requestType === ej.Spreadsheet.Actions.Sorting) {
                var prevIcon, currIcon, fltrspan, rowIndex, filterIcons = [];
                rowIndex = (args.filterIcon.length > 0) ? args.range[0] - 1 : args.range[0];
                for (var i = 0; i < args.filterIcon.length; i++) {
                    fltrspan = this.XLFilter._getFilterHeader(sheetIndex, rowIndex, args.filterIcon[i].colIndex);
                    if (!ej.isNullOrUndefined(fltrspan)) {
                        if (fltrspan.status.indexOf("-asc") > -1)
                            prevIcon = "-asc";
                        else if (fltrspan.status.indexOf("-dsc") > -1)
                            prevIcon = "-dsc";
                        else
                            prevIcon = "";
                    } else
                        prevIcon = "";
                    if (args.filterIcon[i].colIndex === this._generateColCount(args.columnName) - 1)
                        currIcon = args.sortDirection === "ascending" ? "-asc" : "-dsc";
                    else
                        currIcon = "";
                    filterIcons.push({ rowIdx: rowIndex, colIdx: args.filterIcon[i].colIndex, prevIcon: prevIcon, currIcon: currIcon });
                }
                details = { sheetIndex: sheetIndex, filterIcons: filterIcons, isSortByFilter: args.isSortByFilter, colSelected: args.colSelected, range: args.range, columnName: args.columnName, rangeData: args.rangeData, reqType: "sort", direction: args.sortDirection, operation: "unsort" };
            }
            else if (args.requestType === "sortbycolor" || args.requestType === "filterbycolor") {
                details = { sheetIndex: sheetIndex, operation: args.operation, oprType: args.oprType, requestType: args.requestType, action: args.action, bgcolor: args.bgcolor, fgcolor: args.fgcolor, tableID: args.tableID, reqType: args.requestType, sortRange: args.sortRange };
                details.columnName = (args.requestType === "sortbycolor") ? args.sortColumn : args.filterColumn;
                var color;
                if (args.requestType === "filterbycolor") {
                    var fltrdIdxes = [], colIdx = this._generateColCount(details.columnName);
                    for (i = args.range.endRow; i >= args.range.startRow; i--) {
                        color = this.XLEdit.getPropertyValue(i, colIdx - 1, "formats");
                        if (!ej.isNullOrUndefined(color)) {
                            if (args.operation === "filterbgcolor") {
                                if (!ej.isNullOrUndefined(color["background-color"]))
                                    (args.bgcolor.toLowerCase() === color["background-color"].toLowerCase()) && fltrdIdxes.push(i);
                            }
                            else {
                                if (!ej.isNullOrUndefined(color["color"]))
                                    (args.fgcolor.toLowerCase() === color["color"].toLowerCase()) && fltrdIdxes.push(i);
                            }
                        }
                    }
                    details.fltrdIdxes = fltrdIdxes;
                    details.rowIndex = args.range.startRow - 1;
                    details.colIndex = colIdx - 1;
                }
            }
            else
                details = args;
            if (this.model.allowUndoRedo && !this._isPublic && !(details.requestType === "sortbycolor") && !this._dupDetails)
                this.updateUndoRedoCollection(details);
            if (args.requestType === "filtering" || args.requestType === "filterbycolor" || args.requestType === "sortbycolor" || args.requestType === "filterbycell")
                (args.operation !== "apply-filter" && args.operation !== "remove-filter") && this.sendDataRenderingRequest(details, this.getActiveSheetIndex());
            if (this.model.allowAutoFill && args.reqType !== "find-replace" && this.element.find('.e-ss-activeimg').length < 1 && !sheet._isFreezed)
                this.XLDragFill.positionAutoFillElement();
            if (this.model.allowUndoRedo && !this._isPublic && !(this.XLComment && this.XLComment._isCommentEdit))
                this._updateUndoRedoIcons();
            if (args.reqType !== "paging")
                if (args.reqType === "edit" && args.hasValidation)
                    this._trigrDdlActnCmplt(args.cValue, args.pValue);
        },

        updateUndoRedoCollection: function (details) {
            if (!this._isUndoRedo && details.reqType !== 'update-range') {
                this._undoCollection.push(details);
                this._redoCollection = [];
            }
            if (this._undoCollection.length > this.undoRedoStep)
                this._undoCollection.splice(0, 1);
            if (this.model.showRibbon)
                this.XLRibbon._updateRibbonIcons();
            this._updateUndoRedoIcons();
        },

        _trigActionBegin: function (args) {
            return (!this._isSaveAsJSON && !this._isRefresh) && this._trigger("actionBegin", args);
        },

        _trigActionComplete: function (args) {
            return (!this._isSaveAsJSON && !this._isRefresh) && this._trigger("actionComplete", args);
        },

        _updateUndoRedoIcons: function () {
            if (!this.model.showRibbon || !this.model.allowUndoRedo) {
                if (!(this.XLComment && this.XLComment._isCommentEdit))
                    this.setSheetFocus();
                return;
            }
            if ($("#" + this._id + "_Ribbon_Home_Actions_Undo").length && $("#" + this._id + "_Ribbon_Home_Actions_Redo").length && !this.model.isReadOnly) {
                var args, undoBtn = $("#" + this._id + "_Ribbon_Home_Actions_Undo").data("ejButton"), redoBtn = $("#" + this._id + "_Ribbon_Home_Actions_Redo").data("ejButton");
                if (undoBtn)
                    this._undoCollection.length ? undoBtn.enable() : undoBtn.disable();
                if (redoBtn)
                    this._redoCollection.length ? redoBtn.enable() : redoBtn.disable();
                if (!this.XLEdit._isEdit && !(this.XLComment && this.XLComment._isCommentEdit) && !this._isSheetRename && (document.activeElement && document.activeElement.id.indexOf(this._id + "_Ribbon") < 0))
                    this.setSheetFocus();
            }
        },

        _filterMergeCells: function (rowIdx, status) {
            var sheetIdx = this.getActiveSheetIndex(), dataContainer = this._dataContainer.sheets[sheetIdx], dataKeys = this.getObjectKeys(dataContainer[rowIdx]),
                rc, mCell, isMerge = false, mCells;
            for (var i = 0; i < dataKeys.length; i++) {
                mCells = this.XLEdit.getPropertyValue(rowIdx, dataKeys[i], "mergeIdx");
                if (mCells) {
                    rc = mCells;
                    isMerge = true;
                }
            }
            if (isMerge) {
                mCell = this.getCell(rc.rowIndex, rc.colIndex)[0];
                mCell.rowSpan = (status === "incr") ? (mCell.rowSpan + 1) : (mCell.rowSpan - 1);
            }
        },

        _isRowVisible: function (sheetIdx, rowIdx) {
            var container = this._dataContainer.sheets[sheetIdx];
            if (rowIdx in container)
                if (0 in container[rowIdx] && (container[rowIdx][0].isRHide || container[rowIdx][0].isFRHide))
                    return false;
                else
                    return true;
            else
                return true;
        },

        _selectFirstCell: function (sheetIdx, rowIdx, colIdx, isSelect) {
            var sheet = this.getSheet(sheetIdx);
            if ((!sheet._isImported || sheet._isLoaded) && !isSelect) {
                isSelect = !isSelect;
                this.performSelection({ rowIndex: rowIdx, colIndex: colIdx }, { rowIndex: rowIdx, colIndex: colIdx });
            }
            return isSelect;
        },

        _clearAllMergeCells: function (sheetIdx, rowIdx, rowCount, colIdx, colCount, status) {
            var mergeObj, sheet = this.getSheet(sheetIdx), isAlert = false, isCancel = false, dupDetail = this._dupDetails, mRange, mCells = sheet._mergeColl,
                umCells = sheet._unmergeColl, remColl = this._removeMergeColl, rKey, cKey, rKeys, cKeys, container = this._dataContainer.sheets[sheetIdx], chkObj = { isCancel: false, isAlert: true };
            this._dupDetails = true;
            rKeys = this.getObjectKeys(mCells);
            if (rKeys.length < 1)
                isAlert = true;
            for (var i = 0, len = rKeys.length; i < len; i++) {
                cKeys = this.getObjectKeys(mCells[rKeys[i]]);
                for (var j = 0; j < cKeys.length; j++) {
                    mergeObj = $.extend(true, {}, this.XLEdit.getPropertyValue(rKeys[i], cKeys[j], "merge"));
                    mRange = this.getRangeIndices(mergeObj.mRange);
                    chkObj = this._checkFilterMerge(sheetIdx, mRange, rowIdx, rowCount, colIdx, colCount, status, "merge", isAlert, rKeys[i], cKeys[j], mergeObj);
                    if (chkObj.isClear) {
                        if (!(rKeys[i] in umCells))
							sheet._unmergeColl[rKeys[i]] = {};
						sheet._unmergeColl[rKeys[i]][cKeys[j]] = { type: mCells[rKeys[i]][cKeys[j]], merge: mergeObj, isClear: true };
                        this.unmergeCells(mergeObj.mRange, true);
                    }
                    chkObj.isClear = false;
                }
            }
            this._dupDetails = dupDetail;
            return { isCancel: chkObj.isCancel, isAlert: chkObj.isAlert };
        },

        _checkFilterMerge: function (sheetIdx, range, rowIdx, rowCount, colIdx, colCount, status, operation, isAlert, rKey, cKey, mergeObj) {
            var isCancel, sheet = this.getSheet(sheetIdx), rng = this._getSelectedCells(sheetIdx, [rowIdx, colIdx, rowIdx + rowCount - 1, colIdx + colCount - 1]).range, mCells, isClear = false, isRow = false, isCol = false, mCells = sheet._mergeColl;
            if(status.indexOf("shift") > -1 || (operation != "merge" && (status.indexOf("insert") > -1 || status.indexOf("delete") > -1))) {
                (operation === "merge") && (this._removeMergeColl = []);
                if (status.indexOf("Bottom") > -1 || status.indexOf("Up") > -1 || (operation != "merge" && status.indexOf("Row") > -1)) {
                    if (((colIdx >= range[1]) || range[3] >= (colIdx + colCount - 1)) || status.indexOf("Row") > -1) {
                        if ((rowIdx >= range[2]) || (rowIdx <= range[2])) {
                            if (colIdx < range[1] && (colIdx + colCount - 1) < range[1])
                                isAlert = true;
                            else if (colIdx > range[3] && (colIdx + colCount - 1) > range[3])
                                isAlert = true;
                            else if (!this._isTotalRow && (colIdx === range[1] && range[3] === (colIdx + colCount - 1))) {
                                isClear = true;
                                isAlert = true;
                            }
                            if (!isAlert && (rowIdx >= range[2]))
                                isAlert = true;
                        }
                    }
                    else if (colIdx < range[1] && range[3] < (colIdx + colCount - 1)) {
                        isAlert = true;
                        isClear = true;
                    }
                    if (operation === "merge" && !this._isUndoRedo)
                        if (status.indexOf("Up") > -1 && this.XLEdit._rangeHasProperty(rng, "merge")) {
                            this._showAlertDlg("Alert", "MergePreventInsertDelete", "MergePreventInsertDelete", 450);
                            isClear = false;
                            isCancel = true;
                        }
                }
                else if (status.indexOf("Right") > -1 || status.indexOf("Left") > -1 || (operation != "merge" && status.indexOf("Column") > -1)) {
                    if (((rowIdx >= range[0]) || range[2] >= (rowIdx + rowCount - 1)) || status.indexOf("Column") > -1) {
                        if ((colIdx >= range[3]) || (colIdx <= range[3])) {
                            if (rowIdx < range[0] && (rowIdx + rowCount - 1) < range[0])
                                isAlert = true;
                            else if (rowIdx > range[2] && (rowIdx + rowCount - 1) > range[2])
                                isAlert = true;
                            else if (rowIdx === range[0] && range[2] === (rowIdx + rowCount - 1)) {
                                isClear = true;
                                isAlert = true;
                            }
                            if (!isAlert && (colIdx > range[3]))
                                isAlert = true;
                        }
                    }
                    else if (rowIdx < range[0] && range[2] < (rowIdx + rowCount - 1)) {
                        isAlert = true;
                        isClear = true;
                    }
                    if (operation === "merge" && !this._isUndoRedo)
                        if (status.indexOf("Left") > -1 && this.XLEdit._rangeHasProperty(rng, "merge")) {
                            this._showAlertDlg("Alert", "CtrlKeyErrorAlert", "CtrlKeyErrorAction", 450);
                            isClear = false;
                            isCancel = true;
                        }
                }
                if ((operation === "merge") && !isAlert && !isClear)
                    this._removeMergeColl.push({ type: mCells[rKey][cKey], merge: mergeObj });
            }
            else {
                this._isUndoRedo && (isAlert = true);
                if ((rowIdx === -1) || ((rowIdx != -1) && ((range[0] <= rowIdx) && (range[2] > rowIdx))))
                    isClear = true;
                if ((colIdx === -1) || ((colIdx != -1) && ((range[1] <= colIdx) && (range[3] > colIdx))))
                    isClear = true;
            }
            return { isClear: isClear, isAlert: isAlert, isCancel: isCancel };
        },

		_checkTableApplied: function (sheetIdx, rowIdx, rowCount, colIdx, colCount, status) {
		    var chkObj, sheet = this.getSheet(sheetIdx), range, tblManager = sheet.tableManager, tblKeys = this.getObjectKeys(tblManager);
			this._isTableApplied = false;
            for (var i = 0, len = tblKeys.length; i < len; i++) {
				range = tblManager[tblKeys[i]].range;
				chkObj = this._checkFilterMerge(sheetIdx, range, rowIdx, rowCount, colIdx, colCount, status, "filter", false);
				this._isTableApplied = !chkObj.isAlert;
				if(this._isTableApplied)
					return true;
            }   
			return false;
        },
		
        _refreshAllMergeCells: function (sheetIdx, rowIdx, rowCount, colIdx, colCount, status) {
            var mergeObj, mRange, isPMerge, sheet = this.getSheet(sheetIdx), isSingleMerge = false, mCells = sheet._unmergeColl, dupDetail = this._dupDetails, rKey, cKey, rKeys, cKeys, range, container = this._dataContainer.sheets[sheetIdx], stRng, endRng, isClear;
            rKeys = this.getObjectKeys(mCells);
            this._dupDetails = true;
            for (var i = 0, len = rKeys.length; i < len; i++) {
                if (parseInt(rKeys[i]) > rowIdx) {
                    if (status.indexOf("insert") > -1)
                        rKey = parseInt(rKeys[i]) + rowCount;
                    else
                        rKey = parseInt(rKeys[i]) - rowCount;
                }
                else
                    rKey = rKeys[i];
                cKeys = this.getObjectKeys(mCells[rKeys[i]]);
                for (var j = 0; j < cKeys.length; j++) {
                    if (parseInt(cKeys[j]) > colIdx) {
                        if (status.indexOf("insert") > -1)
                            cKey = parseInt(cKeys[j]) + colCount;
                        else
                            cKey = parseInt(cKeys[j]) - colCount;
                    }
                    else
                        cKey = cKeys[j];
                    mergeObj = sheet._unmergeColl[rKeys[i]][cKeys[j]].merge;
                    this.mergeCenter = (sheet._unmergeColl[rKeys[i]][cKeys[j]].type === "center");
					isClear = sheet._unmergeColl[rKeys[i]][cKeys[j]].isClear;
                    range = this.getRangeIndices(mergeObj.mRange);
                    if (rowIdx > -1 || colIdx > -1) {
                        if (!ej.isNullOrUndefined(range)) {
                            if (status.indexOf("Shift") > -1) {
                                this._unMergeRange = mergeObj.mRange;
                                this._showAlertDlg("", "MergeCellsAlert", "MergeCellsInsertAlert", 498);
                            }
                            else {
                                if (rowIdx > -1) {
									if (range[0] === range[2])
                                        isSingleMerge = true;                             
                                    if (!isSingleMerge || isClear) {
										stRng = range[0];
										endRng = range[2];
										if (rowIdx <= range[0])
                                           stRng = (status === "insert") ? range[0] + rowCount : range[0] - rowCount;
                                        if (rowIdx <= range[2])
                                            endRng = (status === "insert") ? range[2] + rowCount : range[2] - rowCount;
										if(stRng <= endRng)
											range[0] = stRng;
										if(endRng >= stRng)
											range[2] = endRng;
									}
                                }
                                if (colIdx > -1) {
									if (range[1] === range[3])
                                        isSingleMerge = true;                           
                                    if (!isSingleMerge || isClear) {
										stRng = range[1];
										endRng = range[3];
                                        if (colIdx <= range[1])
                                            stRng = (status === "insert") ? range[1] + colCount : range[1] - colCount;
                                        if (colIdx <= range[3])
                                            endRng = (status === "insert") ? range[3] + colCount : range[3] - colCount;
										if(stRng <= endRng)
											range[1] = stRng;
										if(endRng >= stRng)
											range[3] = endRng;
									}
                                }
                                if (!isSingleMerge || (isSingleMerge && status === "insert")) {
                                    mRange = this._getAlphaRange(sheetIdx, range[0], range[1], range[2], range[3]);                               
                                    this.mergeCells(mRange, true);
                                    delete sheet._unmergeColl[rKeys[i]][cKeys[j]];
                                    isSingleMerge = false;
									isPMerge = false;
                                }
								else 
									sheet._unmergeColl[rKeys[i]][cKeys[j]]["isClear"] = false;
                            }
                        }
                    }
                }
            }
            this._dupDetails = dupDetail;
        },

        _clearMergeColl: function(mergeColl, rowIdx, colIdx) {
			mergeColl[rowIdx] && delete mergeColl[rowIdx][colIdx];
            if (this.getObjectKeys(mergeColl[rowIdx]).length < 1)
                delete mergeColl[rowIdx];
        },

		_refreshSHMergeCells: function(sheetIdx, idxColl, count, action, operation) {
		    var k, mcellValue, hideColl, isModified, newSpan, isSamePosn, isMerge, stIdx, enIdx, diff, mergeType, sheet = this.getSheet(sheetIdx), stRng, endRng, mCells = $.extend(true, {}, sheet._mergeColl), rKeys, cKeys,
				diffIdx = 0, mergeObj, mRange, isMoved, isMergeCell, isFullMerge = false, isSingleMerge = false, hideCount, kIdx, rowColl = [],
				hideIdx, stRowIdx, stColIdx, endRowIdx, endColIdx, isWithinMerge = false, hideIdx, remRng, oldRange, oldRng, stOldRng, enOldRng;
           rKeys = this.getObjectKeys(mCells);
		   if (sheet._isFreezed)
		        hideColl = (action === "column") ? sheet._fHMergeCols : sheet._fHMergeRows;
		   else
		        hideColl = (action === "column") ? this.getObjectKeys(sheet.hideColsCollection) : sheet.hideRowsCollection;
			if (operation === "hide") {
			    for (var i = 0, ilen = rKeys.length; i < ilen; i++) {
                    cKeys = this.getObjectKeys(mCells[rKeys[i]]);
                    for (var j = 0, jlen = cKeys.length; j < jlen; j++) {
                        isModified = false; isMoved = false; newSpan = 0; isSamePosn = false, isMerge = false;
                        mergeObj = this.XLEdit.getPropertyValue(rKeys[i], cKeys[j], "merge");
                        if (this.getObjectKeys(mergeObj).length < 1)
                            continue;
                        mRange = this.getRangeIndices(mergeObj.mRange);
                        stRng = (action === "column") ? mRange[1] : mRange[0];
                        endRng = (action === "column") ? mRange[3] : mRange[2];
                        for (k = stRng; k <= endRng; k++) {
                            if (idxColl.indexOf(k) > -1){
                                isMerge = true;
                                break;
                            }
                        }
                        if (!isMerge)
                            continue;
                        this._dupDetails = true;
					    stIdx = idxColl[0]; enIdx = idxColl[idxColl.length - 1];
					    diff = (enIdx - stIdx) + 1;
					    this.mergeCenter = (mCells[rKeys[i]][cKeys[j]]["type"] === "center");
						oldRng = mCells[rKeys[i]][cKeys[j]]["oldRange"];
						remRng = oldRng ? oldRng : mergeObj.mRange;
					    this.unmergeCells(mergeObj.mRange);
					    if(enIdx < stRng) {
						    isMoved = true;
						    stRng = stRng + diff;
						    endRng = endRng + diff;
					    }
					    else if (endRng < stIdx)
						    isMoved = false;
					    else {
						    diffIdx = 0; isMergeCell = false; hideIdx = 0;
						    for (var k = 0, klen = idxColl.length; k < klen; k++) {
							    if(idxColl[k] >= stRng && idxColl[k] <= endRng )
								    diffIdx++;
							    if(idxColl[k] === stRng)
								    isMergeCell = true;
								kIdx = (action === "column") ? idxColl[k].toString() : idxColl[k];
								if(hideColl.indexOf(kIdx) > -1)
									hideIdx++;
						    }
						    if(idxColl.indexOf(stRng) > -1)
							    isMergeCell = true;
						    hideCount = 0;
						    for(var l = stRng; l <= endRng; l++) {
							    (action === "column") && (l = l.toString());
							    if(hideColl.indexOf(l) > -1)
								    hideCount++;
								
						    }
						    if((stRng === endRng) || (hideCount === (endRng - stRng)+ 1))
							    isFullMerge = true;
						    if(isMergeCell && !isFullMerge)
							    stRng = (stRng + diffIdx) + (hideCount - hideIdx);
					    }
                        mcellValue = this.XLEdit.getPropertyValue(parseInt(rKeys[i]), parseInt(cKeys[j]), "value2");
					    stRowIdx = (action === "row") ? stRng : mRange[0];
					    endRowIdx = (action === "row") ? endRng : mRange[2];
					    stColIdx = (action === "column") ? stRng : mRange[1];
					    endColIdx = (action === "column") ? endRng : mRange[3];
					    if (!isFullMerge) {
					        if (!(stRowIdx == endRowIdx && stColIdx == endColIdx))
					            this.mergeCells(this._getAlphaRange(sheetIdx, stRowIdx, stColIdx, endRowIdx, endColIdx), true);
					        else {
					            if (rKeys[i] in sheet._delmergeColl)
					                sheet._delmergeColl[rKeys[i]][cKeys[j]] = { type: mCells[rKeys[i]][cKeys[j]]["type"], merge: mergeObj, oldRange: remRng };
					            else {
					                sheet._delmergeColl[rKeys[i]] = {};
					                sheet._delmergeColl[rKeys[i]][cKeys[j]] = { type: mCells[rKeys[i]][cKeys[j]]["type"], merge: mergeObj, oldRange: remRng };
					            }
					        }
                            if (sheet._mergeColl[stRowIdx] && sheet._mergeColl[stRowIdx][stColIdx])
						        sheet._mergeColl[stRowIdx][stColIdx]["oldRange"] = remRng;
					        this._updateMergeColl(sheetIdx, stRowIdx, stColIdx, mCells[rKeys[i]][cKeys[j]]["type"], operation === "hide");
					        if (((enIdx + 1 === stRowIdx && action === "row") || (enIdx + 1 === stColIdx && action === "column")) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(stRowIdx, stColIdx))) {
					            this.XLEdit.updateCellValue({ rowIndex: stRowIdx, colIndex: stColIdx }, mcellValue);
					            if(sheet._wrapColl[parseInt(rKeys[i])] && sheet._wrapColl[parseInt(rKeys[i])][parseInt(cKeys[j])]) {
					                this._wrapCollection(stRowIdx, stColIdx, sheet._wrapColl[parseInt(rKeys[i])][parseInt(cKeys[j])], sheetIdx);
					                if (this._isRowViewable(sheetIdx, stRowIdx))
					                    rowColl.push({ rowIndex: stRowIdx, height: sheet.rowsHeightCollection[parseInt(rKeys[i])] });
					                else
					                    sheet.rowsHeightCollection[stRowIdx] = sheet.rowsHeightCollection[parseInt(rKeys[i])];
					            }
					        }
					    }
                        else {
                            if (rKeys[i] in sheet._delmergeColl)
                                sheet._delmergeColl[rKeys[i]][cKeys[j]] = { type: mCells[rKeys[i]][cKeys[j]]["type"], merge: mergeObj, oldRange : remRng };
                            else {
                                sheet._delmergeColl[rKeys[i]] = {};
                                sheet._delmergeColl[rKeys[i]][cKeys[j]] = { type: mCells[rKeys[i]][cKeys[j]]["type"], merge: mergeObj, oldRange : remRng };
                            }
					    }
					    this.mergeCenter = false;
                    }
			    }
			}
			if (operation === "show") {
			    if (this.getObjectLength(sheet._delmergeColl) > 0)
			        mCells = $.extend(true, mCells, sheet._delmergeColl);
				rKeys = this.getObjectKeys(mCells);
			    for (var i = 0, iLen = rKeys.length; i < iLen; i++) {
			        cKeys = this.getObjectKeys(mCells[rKeys[i]]);
			        for (var j = 0, jLen = cKeys.length; j < jLen; j++) {
				        isMerge = false;
						mergeType =  mCells[rKeys[i]][cKeys[j]].mergeType;
			            mergeObj = mCells[rKeys[i]][cKeys[j]].merge;
			            if (this.getObjectKeys(mergeObj).length < 1)
			                mergeObj = this.XLEdit.getPropertyValue(rKeys[i], cKeys[j], "merge");
			            if (this.getObjectKeys(mergeObj).length > 0) {
			                mRange = this.getRangeIndices(mergeObj.mRange);
							stRng = (action === "column") ? mRange[1] : mRange[0];
			                endRng = (action === "column") ? mRange[3] : mRange[2];						
							oldRng = mCells[rKeys[i]][cKeys[j]]["oldRange"];
							if(oldRng) {
								oldRange = this.getRangeIndices(oldRng);
								stOldRng = (action === "column") ? oldRange[1] : oldRange[0];
								enOldRng = (action === "column") ? oldRange[3] : oldRange[2];
			                }
							else {
								stOldRng = stRng;
								enOldRng = endRng;
							}
		                    stIdx = idxColl[0]; enIdx = idxColl[idxColl.length - 1];
			                for (k = stIdx; k <= enIdx; k++) {
			                    if (k >= stOldRng && k <= enOldRng) {
 			                        isMerge = true;
			                        break;
			                    }
			                }
			                if (!isMerge)
			                    continue;
							if(mergeType === "merge-cells") {
								this._dupDetails = true;
								diff = (enIdx - stIdx) + 1;	                    
								if (enIdx < stRng) {
									this.mergeCenter = mergeObj.isCenterAlign;
									this.unmergeCells(mergeObj.mRange);
									isMoved = true;
									if (diff != count)
										endRng = endRng - diff;
									stRng = stRng - diff;
									stRowIdx = (action === "row") ? stRng : mRange[0];
									endRowIdx = (action === "row") ? endRng : mRange[2];
									stColIdx = (action === "column") ? stRng : mRange[1];
									endColIdx = (action === "column") ? endRng : mRange[3];
									if (!(stRowIdx == endRowIdx && stColIdx == endColIdx))
									    this.mergeCells(this._getAlphaRange(sheetIdx, stRowIdx, stColIdx, endRowIdx, endColIdx), true);
									this._updateMergeColl(sheetIdx, stRowIdx, stColIdx, mCells[rKeys[i]][cKeys[j]]["type"], operation === "hide");
									sheet._mergeColl[stRowIdx][stColIdx]["oldRange"] = oldRng;
								}
							}
			                isWithinMerge = false;
			                for (var k = 0, klen = idxColl.length; k < klen; k++) {
			                    if (((action === "row") && mRange[0] <= idxColl[k]) || ((action === "column") && mRange[1] <= idxColl[k])) {
			                        isWithinMerge = true;
			                        break;
			                    }
			                }
			                if (isWithinMerge) {
								this.mergeCenter = mergeObj.isCenterAlign;
								this.unmergeCells(mergeObj.mRange);
			                    mRange = this.getRangeIndices(mergeObj.mRange);
			                    diff = 0;
			                    for (var l = stRng; l <= endRng; l++) {
									(action === "column") && (l = l.toString());
			                        if (hideColl.indexOf(l) > -1)
			                            diff++;
			                        else
			                            break;
			                    }
			                    stRng = stRng + diff;
			                    if (action === "column")
			                        mRange[1] = stRng;
			                    else
			                        mRange[0] = stRng;
			                    if (!(mRange[0] == mRange[2] && mRange[1] == mRange[3]))
			                        this.mergeCells(this._getAlphaRange(sheetIdx, mRange[0], mRange[1], mRange[2], mRange[3]), true);
			                    this._updateMergeColl(sheetIdx, mRange[0], mRange[1], mCells[rKeys[i]][cKeys[j]]["type"], true);
			                    sheet._mergeColl[mRange[0]][mRange[1]]["oldRange"] = oldRng;
			                    if (!(mRange[0] == mRange[2] && mRange[1] == mRange[3]))
			                        this._clearMergeColl(sheet._delmergeColl, rKeys[i], cKeys[j]);
			                }
			            }
						this.mergeCenter = false;
			        }
			    }
			}
            if(this.model.showRibbon && this._isScrolling)
                this.XLRibbon._updateRibbonIcons();
            this._dupDetails = false;
		},
		
		_getSpanFromMCells: function(rowIdx, colIdx, span) {
            var sheet = this.getSheet(this.getActiveSheetIndex()), hideMColl = sheet._hideMergeColl;
            if (!this.isUndefined(hideMColl[rowIdx]) && !this.isUndefined(hideMColl[rowIdx][colIdx])) {
                if (span === "row")
                    return hideMColl[rowIdx][colIdx]["rowspan"];
                else
                    return hideMColl[rowIdx][colIdx]["colspan"];
            }
            return 0;
        },

        _setSpanToMCells: function (rowIdx, colIdx, span, value) {
            var sheet = this.getSheet(this.getActiveSheetIndex()), hideMColl = sheet._hideMergeColl;
            this.isUndefined(hideMColl[rowIdx]) && (hideMColl[rowIdx] = {});
            this.isUndefined(hideMColl[rowIdx][colIdx]) && (hideMColl[rowIdx][colIdx] = {});
            (span === "row") ? (hideMColl[rowIdx][colIdx]["rowspan"] = value) : (hideMColl[rowIdx][colIdx]["colspan"] = value);
        },

        sendDataRenderingRequest: function (args, sheetIdx) {
            var i, j, k, idx, isSelect = false, rowHtColl, hideRowColl, len, filteredValue, fltrRange, ln, ralign = this._rAlign, sheet = this.getSheet(sheetIdx), isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling,
                range = sheet._selectedRange, fltrdIdxes = [], cellIdx, columns, activeCell, filteredRowsColl = sheet.filteredRowsCollection, stRow, isHidden, tabIdx, tab = sheet.filterSettings.tableRange, hiddenIdx = [],
                filterColumn, predicate, valColl = [], filtered, colHdr = this.getSheetElement(sheetIdx)[0].querySelectorAll('.e-spreadsheetcolumnheader'), colgrp = $(this._getJSSheetHeader(sheetIdx)[0].querySelectorAll('colgroup')[0].outerHTML).attr("id", "ss"),
                rowHdrTd = this.getSheetElement(sheetIdx)[0].querySelectorAll(".e-rowheadercontent td");
            for (i = 0, len = tab.length; i < len; i++) {
                if (tab[i].tableID == args.tableID) {
                    tabIdx = i;
                    break;
                }
            }
            if (isVirtualScroll) {
                rowHtColl = sheet.rowsHeightCollection;
                hideRowColl = sheet.hideRowsCollection;
            }
            this._dupDetails = true;
            if (!(ej.isNullOrUndefined(args)) && (args.reqType == "filter" || (args.action.indexOf("clearfiltering") > -1 && args.reqType == "filterbycolor"))) {
                cellIdx = this._generateColCount(args.fieldName) - 1;
                idx = $.inArray(args.fieldName, sheet._filteredColumns);
                if (args.action.indexOf("clearfiltering") > -1)
                    sheet._filteredColumns.splice(idx, 1);
                else if(idx < 0)
                    sheet._filteredColumns.push(args.fieldName);
                range = args.range;
                hiddenIdx = tab[tabIdx].hiddenIdx;
                filteredValue = args.currentViewData;
                if (args.requestType.indexOf("filtering") > -1 || args.requestType.indexOf("filterbycell") > -1 || args.action.indexOf("clearfiltering") === -1 || ((args.action.indexOf("clearfiltering") > -1 && args.reqType == "filterbycolor"))) {
                    fltrRange = sheet.filterSettings.filteredRange;
                    (filteredValue.length < 1) && fltrdIdxes.push(fltrRange[fltrRange.length - 1].idx + 1);
                    for (i = 0, len = filteredValue.length; i < len; i++) {
                        idx = fltrRange.indexOf(filteredValue[i]);
                        if (idx > -1)
                            fltrdIdxes.push(fltrRange[idx].idx);
                    }
                    tab[tabIdx].fltrdIdxes = fltrdIdxes;
                    stRow = (range.startRow === 0) ? 0 : range.startRow;
                    for (k = stRow; k <= range.endRow; k++) {
                        filtered = false;
                        for (j = 0, ln = fltrdIdxes.length; j < ln; j++)
                            (fltrdIdxes[j] == k) && (filtered = true);
                        if (filtered) {
                            if (!ej.isNullOrUndefined(this._dataContainer.sheets[sheetIdx][k])) {
                                if (!ej.isNullOrUndefined(this._dataContainer.sheets[sheetIdx][k][0])) {
                                    delete this._dataContainer.sheets[sheetIdx][k][0]["isFilterHide"];
                                    delete this._dataContainer.sheets[sheetIdx][k][0]["filterID"];
                                    if (sheet._filterHRowsColl.indexOf(k) > -1)
                                        sheet._filterHRowsColl.splice(sheet._filterHRowsColl.indexOf(k), 1);
                                }
                            }
                            if (!isVirtualScroll) {
                                this._dupDetails = this._isFilter = true;
                                this._showRow(k + 1, k, undefined, undefined, colHdr, colgrp, rowHdrTd);
                                this._dupDetails = this._isFilter = false;
                                if (filteredRowsColl.indexOf(k) > -1)
                                    filteredRowsColl.splice(filteredRowsColl.indexOf(k), 1);
                                if ((!sheet._isImported || sheet._isLoaded) && !isSelect) {
                                    isSelect = !isSelect;
                                    this.performSelection({ rowIndex: k, colIndex: cellIdx }, { rowIndex: k, colIndex: cellIdx });
                                }
                            }
                            else {
                                if (hideRowColl.indexOf(k) > -1) {
                                    this._refreshSHMergeCells(sheetIdx, [k], 1, "row", "show");
                                    hideRowColl.splice(hideRowColl.indexOf(k), 1);
                                }
                                stRow = (k === 0) ? 0 : k - 1;
                                if (this.XLEdit.getPropertyValue(stRow, 0, "hRow")) {
                                    delete this._dataContainer.sheets[sheetIdx][stRow][0]["hRow"];
                                    (filteredRowsColl.indexOf(k) > -1) && filteredRowsColl.splice(filteredRowsColl.indexOf(k), 1);
                                }
                            }
                        }
                        else {
                            if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isRHide")) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isFHide")) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isFilterHide"))) {
                                this.XLEdit._updateDataContainer({ rowIndex: k, colIndex: 0 }, { dataObj: { "isFilterHide": true, "filterID": args.tableID } });
                                (filteredRowsColl.indexOf(k) < 0) && filteredRowsColl.push(k);
                                isHidden = true;
                            }
                            if (!isVirtualScroll) {
                                this._dupDetails = this._isFilter = true;
                                this._hideRow(k, k, "isFilterHide");
                                this._dupDetails = this._isFilter = false;
                                (filteredRowsColl.indexOf(k) === -1) && filteredRowsColl.push(k);
                            }
                            else {
                                if (isHidden) {
                                    hideRowColl.push(k);
                                    isHidden = false;
                                    this._refreshSHMergeCells(sheetIdx, [k], 1, "row", "hide");
                                }
                                stRow = (k === 0) ? 0 : k - 1;
                                this.XLEdit._updateDataContainer({ rowIndex: stRow, colIndex: 0 }, { dataObj: { hRow: true } });
                                (filteredRowsColl.indexOf(k) < 0) && filteredRowsColl.push(k);
                            }
                        }
                    }
                    stRow = (range.startRow === 0) ? 0 : range.startRow - 1;
                    if (isVirtualScroll && (!sheet._isImported || sheet._isLoaded)) {
                        this.refreshContent(sheetIdx);
                        this.performSelection({ rowIndex: stRow, colIndex: cellIdx }, { rowIndex: stRow, colIndex: cellIdx });
                    }
                    if(!isVirtualScroll && this._hideRowColl.length) {
                        this._getRowHdrTBody(sheetIdx).append(this._renderRowHdr(this._hideRowColl, sheetIdx));
                        this._getContTBody(sheetIdx).append($(this._renderData(undefined, sheetIdx, 0, sheet.colCount, false, this._hideRowColl[0], this._hideRowColl.length)));
                        this._hideRowColl = [];
                    }
                    this.XLScroll._getRowHeights(sheetIdx, stRow);
                    columns = sheet.columns;
                    if (args.action === "clearfiltering") {
                        sheet._filteredByColor = -1;
                        this._excelFilter.closeXFDialog();
                    }
                    this.model.allowFiltering && this.XLFilter._updateFilterIcons(stRow, range.startRow, cellIdx, args.action);
                    tab[tabIdx].hiddenIdx = $.extend(true, [], hiddenIdx);
                    hiddenIdx = [];
                }
            }
            else if (!(ej.isNullOrUndefined(args)) && (args.requestType === "sortbycolor" || args.requestType === "filterbycolor")) {
                var startRow = range.startRow, count = [], color, tableFilteredColumn = [], newIdx, cellIdx = this._generateColCount(args.columnName) - 1, rng, rangeData, cells;
                args.prev = {}; args.cur = {};
                if (args.oprType.indexOf("Put") < 0) {
                    if (sheet._filterColl[range.startRow - 1][cellIdx].status.indexOf("e-ssfilter") > -1 && args.requestType === "filterbycolor") {
                        if (this._isRowViewable(sheetIdx, range.startRow - 1)) {
                            activeCell = this.getCell(range.startRow - 1, cellIdx);
                            activeCell.removeClass(ralign);
                            this.XLFilter._changeFilterIcon({ rowIndex: range.startRow - 1, colIndex: cellIdx }, "filter", this.XLEdit.getPropertyValue(range.startRow - 1, cellIdx, "filterState"));
                        }
                    }
                    else if (sheet._filterColl[range.startRow - 1][cellIdx].status.indexOf("-asc")) {
                        args.prev.icon = sheet._filterColl[range.startRow - 1][cellIdx].status;
                        if (this._isRowViewable(sheetIdx, range.startRow - 1)) {
                            activeCell = this.getCell(range.startRow - 1, cellIdx);
                            this.XLFilter._changeSortIcon({ rowIndex: range.startRow - 1, colIndex: cellIdx }, "ascending");
                        }
                        args.cur.icon = sheet._filterColl[range.startRow - 1][cellIdx].status;
                    }
                }
                if (args.requestType === "sortbycolor") {
                    rng = [range.startRow, cellIdx, range.endRow, cellIdx];
                    rangeData = this.getRangeData({ range: rng, skipHiddenRow: true });
                    for (var i = 0, ln = rangeData.length; i < ln; i++) {
                        color = rangeData[i].formats;
                        if (!ej.isNullOrUndefined(color)) {
                            if (args.operation === "sortbgcolor") {
                                if (!ej.isNullOrUndefined(color["background-color"]))
                                    (args.bgcolor === color["background-color"].toLowerCase()) && count.push(i);
                            }
                            else {
                                if (!ej.isNullOrUndefined(color["color"]))
                                    (args.fgcolor === color["color"].toLowerCase()) && count.push(i);
                            }
                        }
                    }
                    var multifilterIdx, remData, totData, j, c, len;
                    if (args.oprType === "PutCellColor" || args.oprType === "PutFontColor")
                        rng = args.sortRange;
                    if (this.isUndefined(args.tableID)) {
                        multifilterIdx = [];
                        for (var col = rng[1]; col <= rng[3]; col++)
                            multifilterIdx.push(col);
                    }
                    else
                        multifilterIdx = tab[tabIdx].multifilterIdx;
                    rng = [range.startRow, multifilterIdx[0], range.endRow, multifilterIdx[multifilterIdx.length - 1]];
                    rangeData = this.getRangeData({ range: rng, skipHiddenRow: true });
                    args.prev.data = $.extend(true, [], rangeData);
                    rng.colIndex = cellIdx;
                    args.range = rng;
                    for (j = 0, len = multifilterIdx.length; j < len; j++) {
                        remData = [], totData = [];
                        rng = [range.startRow, multifilterIdx[j], range.endRow, multifilterIdx[j]];
                        rangeData = this.getRangeData({ range: rng, skipHiddenRow: true });
                        for (c = count.length - 1; c >= 0; c--)
                            remData.push(rangeData.splice(count[c], 1)[0]);
                        totData = remData.reverse().concat(rangeData);
                        if (remData.length > 0) {
                            this._isSort = true;
                            this._dupDetails = true;
                            this.XLComment.deleteComment(rng, null, true, null);
                            this._removeHyperlink(null, null, true, rng);
                            this.clearRangeData(rng, ["value", "value2", "type", "formatStr", "decimalPlaces", "thousandSeparator", "comment", "hyperlink", "format"], null, true);
                            this.XLFormat.removeStyle(rng, { cellStyle: true, tableStyle: true, format: true, skipHiddenRow: true });
                            this._isSort = false;
                            this._dupDetails = false;
                            this.XLEdit.updateCellWithContainer(totData, rng, sheetIdx, true);
                        }
                    }
                    rng = [range.startRow, multifilterIdx[0], range.endRow, multifilterIdx[multifilterIdx.length - 1]];
                    args.cur.data = $.extend(true, [], this.getRangeData({ range: rng, skipHiddenRow: true }));
                    this.updateUndoRedoCollection(args);
                }
                else {
                    var firstVal, isTake, fltrText;
                    tableFilteredColumn = [], hiddenIdx = [];
                    tab[tabIdx].fltrdIdxes = fltrdIdxes = args.fltrdIdxes;
                    stRow = (range.startRow === 0) ? 0 : range.startRow;
                    for (k = stRow ; k <= range.endRow; k++) {
                        filtered = false;
                        for (j = 0, ln = fltrdIdxes.length; j < ln; j++)
                            (fltrdIdxes[j] == k) && (filtered = true);
                        if (filtered) {
                            fltrText = this.XLEdit.getPropertyValue(k, cellIdx, "value2");
                            fltrText = ej.isNullOrUndefined(fltrText) ? "" : fltrText;
                            filterColumn = { field: args.columnName, value: fltrText, predicate: "or", operator: "equal", matchcase: false };
                            predicate = ej.Predicate(args.columnName, "equal", fltrText);
                            if (this.XLEdit.getPropertyValue(k, 0, "filterID") === args.tableID) {
                                delete this._dataContainer.sheets[sheetIdx][k][0]["isFilterHide"];
                                delete this._dataContainer.sheets[sheetIdx][k][0]["filterID"];
                                if (!isVirtualScroll) {
                                    this._dupDetails = this._isFilter = true;
                                    this._showRow(k + 1, k, undefined, undefined, colHdr, colgrp, rowHdrTd);
                                    this._dupDetails = this._isFilter = false;
                                    if (filteredRowsColl.indexOf(k) > -1)
                                        filteredRowsColl.splice(filteredRowsColl.indexOf(k), 1);
                                    if ((!sheet._isImported || sheet._isLoaded) && !isSelect) {
                                        isSelect = !isSelect;
                                        this.performSelection({ rowIndex: k, colIndex: cellIdx }, { rowIndex: k, colIndex: cellIdx });
                                    }
                                }
                                else {
                                    hideRowColl.splice(hideRowColl.indexOf(k), 1);
                                    this._refreshSHMergeCells(sheetIdx, [k], 1, "row", "show");
                                }
                            }
                            tableFilteredColumn.push(filterColumn);
                            valColl.push(filterColumn);
                            firstVal = valColl[0]; isTake = firstVal["from"];
                        }
                        else {
                            if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isRHide")) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isFHide")) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(k, 0, "isFilterHide"))) {
                                this.XLEdit._updateDataContainer({ rowIndex: k, colIndex: 0 }, { dataObj: { "isFilterHide": true, "filterID": args.tableID } });
                                isHidden = true;
                            }
                            if (!isVirtualScroll) {
                                this._dupDetails = this._isFilter = true;
                                this._hideRow(k, k, "isFilterHide");
                                this._dupDetails = this._isFilter = false;
                                (filteredRowsColl.indexOf(k) === -1) && filteredRowsColl.push(k);
                            }
                            else {
                                if (isHidden) {
                                    hideRowColl.push(k);
                                    this._refreshSHMergeCells(sheetIdx, [k], 1, "row", "hide");
                                }
                            }
                            isHidden = false;
                        }
                    }
                    if (isVirtualScroll && (!sheet._isImported || sheet._isLoaded)) {
                        this.refreshContent(sheetIdx);
                        this.performSelection({ rowIndex: fltrdIdxes[0], colIndex: cellIdx }, { rowIndex: fltrdIdxes[0], colIndex: cellIdx });
                    }
                    if(!isVirtualScroll && this._hideRowColl.length) {
                        this._getRowHdrTBody(sheetIdx).append(this._renderRowHdr(this._hideRowColl, sheetIdx));
                        this._getContTBody(sheetIdx).append($(this._renderData(undefined, sheetIdx, 0, sheet.colCount, false, this._hideRowColl[0], this._hideRowColl.length)));
                        this._hideRowColl = [];
                    }
                    this.XLScroll._getRowHeights(sheetIdx, stRow); args.filterCollection = tableFilteredColumn;
                    predicate = firstVal["ejpredicate"] ? firstVal["ejpredicate"] : ej.Predicate(firstVal.field, firstVal.operator, firstVal.value, !firstVal.matchcase);
                    for (j = 1; j < valColl.length; j++)
                        predicate = valColl[j].ejpredicate != undefined ? predicate[valColl[j].predicate](valColl[j].ejpredicate) : predicate[valColl[j].predicate](valColl[j].field, valColl[j].operator, valColl[j].value, !valColl[j].matchcase);
                    if (ej.isNullOrUndefined(tab[tabIdx].predicate[args.columnName]))
                        tab[tabIdx].predicate[args.columnName] = {};
                    tab[tabIdx].filteredColumns = tableFilteredColumn;
                    tab[tabIdx].predicate[args.columnName] = !isTake ? predicate : { from: firstVal["from"], take: firstVal["take"] };
                    tab[tabIdx].hiddenIdx = $.extend(true, [], hiddenIdx);
                    hiddenIdx = [];
                }
            }
            if (!(ej.isNullOrUndefined(args)) && (args.action === "filter" || args.action === "filtering" || args.action === "filterbycolor")) {
                if (args.tableID > -1)
                    sheet.filterSettings.tableRange[tabIdx].filterColumnName.push(args.fieldName);
                this.XLFilter._fltrRowHighlight(range.startRow, range.endRow, "add", args.tableID, args.filterCollection.length);
            }
            else if (args.action === "clearfiltering") {
                if (args.tableID > -1)
                    sheet.filterSettings.tableRange[tabIdx].filterColumnName.pop(args.fieldName);
                this.XLFilter._fltrRowHighlight(range.startRow, range.endRow, "clear", args.tableID, args.filterCollection.length);
            }
            this._dupDetails = false;
            if (this.model.showRibbon && this.model.allowFiltering) {
                var btnObj = $("#" + this._id + "_Ribbon_Data_SortFilter_ClearFilter").data("ejButton"), target = { rowIndex: this.getActiveCell().rowIndex, colIndex: this.getActiveCell().colIndex };
                this.XLRibbon._changeClrFltrStatus(btnObj, "button", target);
            }
            if (this.model.scrollSettings.allowScrolling)
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "vertical", "filter");
        },

        _filterClose: function (target) {
            if (!this.model.allowFiltering)
                return;
            if (!this._hasClass(target, "e-filterspan") && $(target).parents(".e-excelfilter").length < 1 && this._excelFilter._openedFltr && $(this._excelFilter._openedFltr).is(":visible")) {
                this._excelFilter.closeXFDialog();
                this.XLFilter._isSearchEdit = false;
            }
        },

        showPager: function (status) {
            var settings;
            this.model.showPager = status, settings = this.model.scrollSettings;
            this.element.find(".e-spreadsheetfooter").css("display", status ? "block" : "none");
            this._setSheetWidthHeight(this.getActiveSheetIndex(), { width: this._responsiveWidth, height: this._responsiveHeight });
        },

        _refreshClipboard: function (rObjElem, operation) {
            var model = this.model, xlId = this._id;
            if (rObjElem.length) {
                if (!model.allowFormatPainter || !model.allowCellFormatting)
                    rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard")[operation]();
                rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_1")[operation]();
                rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_Cut")[operation]();
                rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_Copy")[operation]();
            }
        },

        _setModel: function (options) {
            var val, option, formulaBar, expProp, picProp, autofillProp, importProp, sheetIdx = this.getActiveSheetIndex(), checkObj, model = this.model, settings = model.scrollSettings, xlId = this._id,
				rObj = $("#" + xlId + "_Ribbon").ejRibbon("instance"), rObjElem = this.model.showRibbon ? rObj.element : [];
            for (option in options) {
                val = options[option];
                switch (option) {
                    case "allowClipboard":
                        if (val) {
                            this._refreshClipboard(rObjElem, "show");
                            if (ej.isNullOrUndefined(this.XLClipboard))
                                this.XLClipboard = new ej.spreadsheetFeatures.clipboard(this);
                            this.XLClipboard._initCopyPaste();
                        }
                        else
                            this._refreshClipboard(rObjElem, "hide");
                        break;
                    case "activeSheetIndex":
                        this.gotoPage(val, false);
                        break;
                    case "pageSettings":
                        !this.isUndefined(options.pageSettings.currentPage) && this.gotoPage(options.pageSettings.currentPage, false);
                        if (!this.isUndefined(options.pageSettings.pageCount)) {
                            this.getPager().ejPager("option", "pageCount", options.pageSettings.pageCount);
                            this._refreshSpreadSheetPager(true);
                        }
                        break;
                    case "allowComments":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLComment))
                                this.XLComment = new ej.spreadsheetFeatures.comments(this);
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_review_Comments").show();
                            this.XLComment._updateCmntRibIcons();
                        }
                        else
                            this.model.showRibbon && rObjElem.find("#" + xlId + "_Ribbon_review_Comments").hide();
                        break;
                    case "allowFormatPainter":
                        if (model.allowCellFormatting) {
                            if (val) {
                                if (!model.allowClipboard)
                                    rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard").show();
                                if (ej.isNullOrUndefined(this.XLFormat))
                                    this.XLFormat = new ej.spreadsheetFeatures.cellFormatting(this);
                                rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_FormatPainter").show();
                            }
                            else if (rObjElem.length) {
                                if (!model.allowClipboard)
                                    rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard").hide();
                                rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_FormatPainter").hide();
                            }
                        }
                        break;
                    case "allowFormulaBar":
                        if (val) {
                            formulaBar = $("#" + this._id + "_formulabar");
                            if (!formulaBar.length) {
                                this._renderFormulaBar(true);
                                this._setSheetWidthHeight(sheetIdx, { width: this._responsiveWidth, height: this._responsiveHeight });
                            }
                            else
                                this.showFormulaBar();
                        }
                        else
                            this.hideFormulaBar();
                        break;
                    case "allowHyperlink":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_insert_Links").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_insert_Links").hide();
                        break;
                    case "enableContextMenu":
                        if (val && ej.isNullOrUndefined(this.XLCMenu)) {
                            this.XLCMenu = new ej.spreadsheetFeatures.contextmenu(this);
                            this.XLCMenu._initContextMenu();
                            this.XLCMenu._initColorDialog();
                            this.XLCMenu._initCMenuFooter();
                        }
                        break;
                    case "allowEditing":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLEdit))
                                this.XLEdit = new ej.spreadsheetFeatures.editing(this);
                            this.model.showRibbon && rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_home_Editing").show();
                            this.XLEdit._processEditing();
                            this.model.enableContextMenu && this.XLCMenu._enableMenuOpt(["RenameSheet"], "contextMenuFooter");
                        }
                        else {
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_home_Editing").hide();
                            this.model.enableContextMenu && this.XLCMenu._disableMenuOpt(["RenameSheet"], "contextMenuFooter");
                        }
                        break;
                    case "allowResizing":
                        if (val && ej.isNullOrUndefined(this.XLResize))
                            this.XLResize = new ej.spreadsheetFeatures.resizing(this);
                        break;
                    case "allowDataValidation":
                        if (val) {
                            rObjElem.find("#" + xlId + "_Ribbon_data_DataTools").show();
                            if (ej.isNullOrUndefined(this.XLValidate)) {
                                this.XLValidate = new ej.spreadsheetFeatures.validation(this);
                                this.XLRibbon._renderValDialog(this.XLRibbon._initValDialog());
                                this.XLValidate._addDVMethod();
                            }
                        }
                        else
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_data_DataTools").hide();
                        break;
                    case "allowConditionalFormats":
                        if (val) {
                            rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_ConditionalFormatting").show();
                            this.XLRibbon._initCFDialog();
                            if (ej.isNullOrUndefined(this.XLCFormat))
                                this.XLCFormat = new ej.spreadsheetFeatures.cFormat(this);
                        }
                        else
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_ConditionalFormatting").hide();
                        break;
                    case "allowSearching":
                        this.model.allowSearching = val;
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLSearch))
                                this.XLSearch = new ej.spreadsheetFeatures.findnreplace(this);
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Editing").show();
                        }
                        else
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Editing").hide();

                        break;
                    case "pictureSettings":
                        for (picProp in val) {
                            switch (picProp) {
                                case "allowPictures":
                                    model.pictureSettings.allowPictures = val[picProp];
                                    if (val[picProp]) {
                                        if (ej.isNullOrUndefined(this.XLShape))
                                            this.XLShape = new ej.spreadsheetFeatures.shape(this);
                                        rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Illustrations").show();
                                    }
                                    else
                                        rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Illustrations").hide();
                                    break;
                            }
                        }
                        break;
                    case "showRibbon":
                        this.model.showRibbon = val;
                        var ribbonDiv = $("#" + xlId + "_Ribbon");
                        if (val) {
                            ribbonDiv.length ? ribbonDiv.show() : this.XLRibbon._renderRibbon(true);
                            rObj = $("#" + xlId + "_Ribbon").ejRibbon("instance");
                            rObjElem = rObj.element;
                            if (rObjElem[0].style.overflow === "hidden")
                                rObjElem[0].style.overflow = "";
							if (!$._data($(".e-" + this._id + ".e-chartcell")[0], 'events')) 
							    this._on($(".e-" + this._id + ".e-chartcell"), "click", this._chartClickHandler);
						    if (!$._data($('#' + this._id + '_cellstyles')[0], 'events')) 
							    this._on($('#' + this._id + '_cellstyles'), "click", this._cellStyleClick);
						    if (!$._data($('#' + this._id + '_formatastable')[0], 'events')) 
							    this._on($('#' + this._id + '_formatastable'), "click", this._formatAsTableClick);
                        }
                        else
                            ribbonDiv.hide();
                        this.refreshSpreadsheet();
                        break;
                    case "exportSettings":
                        if (xlObj.model.ribbonSettings.applicationTab.type === "menu")
                            var menuObj = $('#' + xlId + '_Menu').data("ejMenu");
                        for (expProp in val) {
                            switch (expProp) {
                                case "allowExporting":
                                    model.exportSettings.allowExporting = val[expProp];
                                    if (val[expProp]) {
                                        if (model.exportSettings.excelUrl || model.exportSettings.csvUrl || model.exportSettings.pdfUrl) {
                                            rObjElem.length && rObjElem.find("#saveas_backStageTab").show();
                                            if (menuObj)
                                                menuObj.enableItemByID("Save");
                                        }
                                        if (ej.isNullOrUndefined(this.XLExport))
                                            this.XLExport = new ej.spreadsheetFeatures.exporting(this);
                                    }
                                    else {
                                        rObjElem.length && rObjElem.find("#saveas_backStageTab").hide();
                                        rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_BackStage_saveas").hide();
                                        if (menuObj)
                                            menuObj.disableItemByID("Save");
                                    }
                                    break;
                                case "excelUrl":
                                    model.exportSettings.excelUrl = val[expProp];
                                    if (val[expProp]) {
                                        rObjElem.length && rObjElem.find("#saveas_backStageTab").show();
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(0)').show();
                                        if (menuObj)
                                            menuObj.enableItemByID("ExportXL");
                                    }
                                    else {
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(0)').hide();
                                        if (menuObj)
                                            menuObj.disableItemByID("ExportXL");
                                    }
                                    break;
                                case "csvUrl":
                                    model.exportSettings.csvUrl = val[expProp];
                                    if (val[expProp]) {
                                        rObjElem.length && rObjElem.find("#saveas_backStageTab").show();
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(1)').show();
                                        if (menuObj)
                                            menuObj.enableItemByID("ExportCsv");
                                    }
                                    else {
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(1)').hide();
                                        if (menuObj)
                                            menuObj.disableItemByID("ExportCsv");
                                    }
                                    break;
                                case "pdfUrl":
                                    model.exportSettings.pdfUrl = options[option][expProp];
                                    if (val[expProp]) {
                                        rObjElem.length && rObjElem.find("#saveas_backStageTab").show();
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(2)').show();
                                        if (menuObj)
                                            menuObj.enableItemByID("ExportPdf");
                                    }
                                    else {
                                        rObjElem.find('#' + xlId + '_backstagetabsaveas .e-ssr-bssaveasopt:eq(2)').hide();
                                        if (menuObj)
                                            menuObj.disableItemByID("ExportPdf");
                                    }
                                    break;

                            }
                        }
                        break;
                    case "allowKeyboardNavigation":
                        if (val && ej.isNullOrUndefined(this.XLCellNav))
                            this.XLCellNav = new ej.spreadsheetFeatures.cellNavigation(this);
                        break;
                    case "enablePivotTable":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLPivot))
                                this.XLPivot = new ej.spreadsheetFeatures.pivot(this);
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_PivotTable").show();
                        }
                        else {
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_PivotTable").hide();
                            this.hideActivationPanel();
                            this.XLRibbon._toggleAnalyzeTab();
                            this.getSheetElement(sheetIdx).find(".e-ss-activepivot").removeClass("e-ss-activepivot");
                        }
                        break;
                    case "allowAutoFill":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLDragFill)) {
                                this.XLDragFill = new ej.spreadsheetFeatures.dragFill(this);
                                this._createAutoFillElement();
                            }
                            else
                                this.getAutoFillElem().show();
                            this.XLDragFill.positionAutoFillElement();
                        }
                        else {
                            this.getAutoFillElem().hide();
                            this.XLDragFill.hideAutoFillOptions()
                        }
                        break;
                    case "autoFillSettings":
                        for (autofillProp in val) {
                            switch (autofillProp) {
                                case "fillType":
                                    if (model.allowAutoFill)
                                        model.autoFillSettings.fillType = val[autofillProp];
                                    break;
                                case "showFillOptions":
                                    if (model.allowAutoFill) {
										val.showFillOptions ? this._removeClass(this._getAutoFillOptElem(), "e-hide"):this.XLDragFill.hideAutoFillOptions();
                                        model.autoFillSettings.showFillOptions = val.showFillOptions;
									}
                                    break;
                            }
                        }
                        break;
                    case "allowSelection":
                        if (val && ej.isNullOrUndefined(this.XLSelection)) {
                            this.XLSelection = new ej.spreadsheetFeatures.selection(this);
                            this._initSelection();
                        }
                        break;
                    case "allowDragAndDrop":
                        if (val && ej.isNullOrUndefined(this.XLDragDrop))
                            this.XLDragDrop = new ej.spreadsheetFeatures.dragAndDrop(this);
                        break;
                    case "allowCellFormatting":
                        if (val) {
                            if (model.allowConditionalFormats || model.allowFormatAsTable)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Styles").show();
                            if (rObjElem.length) {
                                rObjElem.find("#" + xlId + "_Ribbon_home_Font").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Number").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_TopAlign").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_MiddleAlign").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_BottomAlign").show();
                                rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Alignment_BottomAlign").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignLeft").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignCenter").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignRight").show();
                                rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Alignment_AlignRight").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_DecreaseIndent").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_IncreaseIndent").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_CellStyles").show();
                                if (model.allowFormatPainter)
                                    rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_FormatPainter").show();
                                if (model.allowClipboard)
                                    rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard").show();
                            }
                            if (ej.isNullOrUndefined(this.XLFormat))
                                this.XLFormat = new ej.spreadsheetFeatures.cellFormatting(this);
                            if (ej.isNullOrUndefined(this.XLCellFrmtDlg))
                                this.XLCellFrmtDlg = new ej.spreadsheetFeatures.formatCellDialog(this);
                            if ($('#' + xlId + "_formatdlg").length === 0)
                                this.XLCellFrmtDlg._renderCellFrmtDlg();
                        }
                        else if (rObjElem.length) {
                            rObjElem.find("#" + xlId + "_Ribbon_home_Font").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Number").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_TopAlign").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_MiddleAlign").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_BottomAlign").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Alignment_BottomAlign").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignLeft").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignCenter").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_AlignRight").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Alignment_AlignRight").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_DecreaseIndent").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_IncreaseIndent").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_CellStyles").hide();
                            rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard_Home_Clipboard_FormatPainter").hide();
                            if (!model.allowClipboard)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Clipboard").hide();
                            if (!model.allowConditionalFormats && !model.allowFormatAsTable)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Styles").hide();
                        }
                        break;
                    case "allowImport":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#open_backStageTab").show();
                            else
                                rObjElem.find("#open_backStageTab").hide();
                        break;
                    case "importSettings":
                        if (xlObj.model.ribbonSettings.applicationTab.type === "menu")
                            var menuObj = $('#' + xlId + '_Menu').data("ejMenu");
                        for (importProp in val) {
                            switch (importProp) {
                                case "importMapper":
                                    if (val[importProp]) {
                                        model.importSettings.importMapper = val[importProp];
                                        rObjElem.length && rObjElem.find("#open_backStageTab").show();
                                        if (menuObj)
                                            menuObj.enableItemByID("Open");
                                    }
                                    else {
                                        rObjElem.length && rObjElem.find("#open_backStageTab").hide();
                                        if (menuObj)
                                            menuObj.disableItemByID("Open");
                                    }
                                    break;
                                case "importUrl":
                                    model.importSettings.importUrl = val[importProp];
                                    break;
                                case "password":
                                    model.importSettings.password = val[importProp];
                                    break;
                            }
                        }
                        break;
                    case "allowSorting":
                        var numberDlg = document.getElementById(xlId + "number_MenuItem"), stringDlg = document.getElementById(xlId + "string_MenuItem"),
                            menuObj = $("#" + xlId + "_Ribbon_SortFilter").data("ejMenu");
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLSort))
                                this.XLSort = new ej.spreadsheetFeatures.sorting(this);
                            if (rObjElem.length) {
                                rObjElem.find("#" + xlId + "_Ribbon_data_SortFilter_1").show();
                                rObjElem.find("#" + xlId + "_Ribbon_data_Sort").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_1").show();
                            }
                            menuObj && menuObj.enableItemByID('Ribbon_SortAtoZ');
                            menuObj && menuObj.enableItemByID('Ribbon_SortZtoA');
                        }
                        else if (rObjElem.length) {
                            rObjElem.find("#" + xlId + "_Ribbon_data_SortFilter_1").hide();
                            if (!this.model.allowFiltering) {
                                rObjElem.find("#" + xlId + "_Ribbon_data_Sort").hide();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_1").hide();
                            }
                            menuObj && menuObj.disableItemByID('Ribbon_SortAtoZ');
                            menuObj && menuObj.disableItemByID('Ribbon_SortZtoA');
                        }
                        if (this.model.allowFiltering) {
                            for (var i = 0; i < 3; i++) {
                                if (!ej.isNullOrUndefined(numberDlg))
                                    numberDlg.childNodes[i].style.display = this.model.allowSorting ? (i === 2 ? "block" : "inline") : "none";
                                if (!ej.isNullOrUndefined(stringDlg))
                                    stringDlg.childNodes[i].style.display = this.model.allowSorting ? (i === 2 ? "block" : "inline") : "none";
                            }
                        }
                        break;
                    case "formatSettings":
                        if (model.allowCellFormatting) {
                            for (var formatSetting in val) {
                                switch (formatSetting) {
                                    case "allowFontFamily":
                                        model.formatSettings.allowFontFamily = val[formatSetting];
                                        if (rObjElem.length)
                                            if (val[formatSetting])
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Font_Home_Font_FontFamily").show();
                                            else
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Font_Home_Font_FontFamily").hide();
                                        break;
                                    case "allowDecimalPlaces":
                                        model.formatSettings.allowDecimalPlaces = val[formatSetting];
                                        if (rObjElem.length)
                                            if (val[formatSetting]) {
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Number_Home_Number_IncreaseDecimal").show();
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Number_Home_Number_DecreaseDecimal").show();
                                                rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Number_CommaStyle").show();
                                            }
                                            else {
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Number_Home_Number_IncreaseDecimal").hide();
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Number_Home_Number_DecreaseDecimal").hide();
                                                rObjElem.find("#" + xlId + "_Ribbon_separator_Home_Number_CommaStyle").hide();
                                            }
                                        break;
                                    case "allowCellBorder":
                                        model.formatSettings.allowCellBorder = val[formatSetting];
                                        if (rObjElem.length)
                                            if (val[formatSetting]) {
                                                rObjElem.find("#" + xlId + "_Ribbon_separator_border").show();
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Font_Home_Font_Border").show();
                                            }
                                            else {
                                                rObjElem.find("#" + xlId + "_Ribbon_separator_border").hide();
                                                rObjElem.find("#" + xlId + "_Ribbon_home_Font_Home_Font_Border").hide();
                                            }
                                        break;
                                }
                            }
                        }
                        break;
                    case "sheets":
                        for (var i = 0, len = val.length; i < len; i++) {
                            for (var oper in val[i]) {
                                if ((this.model.sheetCount < i + 1) && val.length > sheetIdx)
                                    return;
                                switch (oper) {
                                    case "showGridlines":
                                        if (i + 1 === sheetIdx)
                                            this._showGridlines(val[i].showGridlines, sheetIdx);
                                        else
                                            this.getSheet(i + 1).showGridlines = val[i].showGridlines;
                                        break;
                                    case "showHeadings":
                                        if (i + 1 === sheetIdx)
                                            this._showHeadings(val[i].showHeadings, sheetIdx);
                                        else
                                            this.getSheet(i + 1).showHeadings = val[i].showHeadings;
                                        break;
                                }
                            }
                        }
                        break;
                    case "scrollSettings":
                        var settings = {}, isResponsive = model.scrollSettings.isResponsive;
                        if (!ej.isNullOrUndefined(options["scrollSettings"])) {
                            if (!ej.isNullOrUndefined(options["scrollSettings"]["allowScrolling"]))
                                model.scrollSettings.allowScrolling = options["scrollSettings"]["allowScrolling"];
                            if (!ej.isNullOrUndefined(options["scrollSettings"]["allowVirtualScrolling"]))
                                model.scrollSettings.allowVirtualScrolling = options["scrollSettings"]["allowVirtualScrolling"];
                            if (!ej.isNullOrUndefined(options["scrollSettings"]["isResponsive"]))
                                isResponsive = model.scrollSettings.isResponsive = options["scrollSettings"]["isResponsive"];

                            if (!ej.isNullOrUndefined(options["scrollSettings"]["scrollMode"]))
                                if (options["scrollSettings"]["scrollMode"] === "normal")
                                    model.scrollSettings.scrollMode = ej.Spreadsheet.scrollMode.Normal;
                                else
                                    model.scrollSettings.scrollMode = ej.Spreadsheet.scrollMode.Infinite;
                            if (!ej.isNullOrUndefined(options["scrollSettings"]["width"]))
                                model.scrollSettings.width = options["scrollSettings"]["width"];
                            if (!ej.isNullOrUndefined(options["scrollSettings"]["height"]))
                                model.scrollSettings.height = options["scrollSettings"]["height"];
                        }
                        if (!model.scrollSettings.isResponsive) {
                            $.extend(true, settings, this.model.scrollSettings);
                            this.element.height(settings.height).width(settings.width);
                            $("#" + this._id + "_Ribbon").ejRibbon("option", { width: settings.width });
                            this._updateResponsiveSettings();
                            this._setSheetWidthHeight(sheetIdx, { height: this._responsiveHeight, width: this._responsiveWidth });
                        }
                        break;
                    case "allowFiltering":
                        var menuObj = $("#" + xlId + "_Ribbon_SortFilter").data("ejMenu");
                        if (val) {
                            if (rObjElem.length) {
                                rObjElem.find("#" + xlId + "_Ribbon_data_SortFilter_2").show();
                                rObjElem.find("#" + xlId + "_Ribbon_data_Sort").show();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_1").show();
                            }
                            menuObj && menuObj.enableItemByID('Ribbon_Filter');
                            if (ej.isNullOrUndefined(this.XLFilter))
                                this.XLFilter = new ej.spreadsheetFeatures.filter(this);
                            this.XLFilter._renderExcelFilter();
                        }
                        else if (rObjElem.length) {
                            if (!this.model.allowSorting) {
                                rObjElem.find("#" + xlId + "_Ribbon_data_Sort").hide();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_1").hide();
                            }
                            rObjElem.find("#" + xlId + "_Ribbon_data_SortFilter_2").hide();
                            menuObj && menuObj.disableItemByID('Ribbon_Filter');
                        }
                        break;
                    case "allowInsert":
                        if (val) {
                            if (rObjElem.length && !model.allowDelete)
                                rObjElem.find("#" + xlId + "_Ribbon_others_Cells").show();
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Cells_1").show();
                            this.getPager().find(".e-new").removeClass("e-disable");
                            if(model.enableContextMenu){ 
                                this.XLCMenu._enableMenuOpt(["InsertSheet", "MoveorCopy"], "contextMenuFooter");
                                this.XLCMenu._enableMenuOpt(["Insert"], "contextMenuCell");
                                this.XLCMenu._enableMenuOpt(["Insert"], "contextMenuColumnHeader");
                                this.XLCMenu._enableMenuOpt(["Insert"], "contextMenuRowHeader");
                            }

                        }
                        else {
                            if (rObjElem.length && !model.allowDelete)
                                rObjElem.find("#" + xlId + "_Ribbon_others_Cells").hide();
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Cells_1").hide();
                            this.getPager().find(".e-new").addClass("e-disable");
                            if (model.enableContextMenu) {
                                this.XLCMenu._disableMenuOpt(["InsertSheet", "MoveorCopy"], "contextMenuFooter");
                                this.XLCMenu._disableMenuOpt(["Insert"], "contextMenuCell");
                                this.XLCMenu._disableMenuOpt(["Insert"], "contextMenuColumnHeader");
                                this.XLCMenu._disableMenuOpt(["Insert"], "contextMenuRowHeader");
                            }
                        }
                        break;
                    case "allowDelete":
                        if (val) {
                            if (!model.allowInsert && rObjElem.length)
                                rObjElem.find("#" + xlId + "_Ribbon_others_Cells").show();
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Cells_2").show();
                            if (model.enableContextMenu && this._getSheetNames(true).length > 1) {
                                this.XLCMenu._enableMenuOpt(["DeleteSheet"], "contextMenuFooter");
                                this.XLCMenu._enableMenuOpt(["Delete"], "contextMenuCell");
                                this.XLCMenu._enableMenuOpt(["Delete"], "contextMenuColumnHeader");
                                this.XLCMenu._enableMenuOpt(["Delete"], "contextMenuRowHeader");
                            }
                        }
                        else {
                            if (!model.allowInsert && rObjElem.length)
                                rObjElem.find("#" + xlId + "_Ribbon_others_Cells").hide();
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Cells_2").hide();
                            if(model.enableContextMenu){
                                this.XLCMenu._disableMenuOpt(["DeleteSheet"], "contextMenuFooter");
                                this.XLCMenu._disableMenuOpt(["Delete"], "contextMenuCell");
                                this.XLCMenu._disableMenuOpt(["Delete"], "contextMenuColumnHeader");
                                this.XLCMenu._disableMenuOpt(["Delete"], "contextMenuRowHeader");
                            }
                        }
                        break;
                    case "allowFreezing":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLFreeze)) {
                                this.XLFreeze = new ej.spreadsheetFeatures.freezepane(this);
                                this.XLFreeze._initFreeze();
                            }
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_others_Window").show();
                        }
                        else if (rObjElem.length)
                            rObjElem.find("#" + xlId + "_Ribbon_others_Window").hide();
                        break;
                    case "allowMerging":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_Merge").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_Merge").hide();
                        break;
                    case "allowWrap":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_WrapText").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_home_Alignment_Home_Alignment_WrapText").hide();
                        break;
                    case "allowUndoRedo":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Actions").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_home_Actions").hide();
                        break;
                    case "frozenRows":
                        if (model.allowFreezing)
                            this.XLFreeze.freezeRows(val);
                        break;
                    case "frozenColumns":
                        if (model.allowFreezing)
                            this.XLFreeze.freezeColumns(val);
                        break;
                    case "freezePanes":
                        if (model.allowFreezing)
                            this.XLFreeze.freezePanes(val.rowIndex, val.colIndex);
                    case "allowFormatAsTable":
                        if (val) {
                            if (!model.enablePivotTable)
                                rObjElem.find("#" + xlId + "_Ribbon_insert_Tables").show();
                            if (ej.isNullOrUndefined(this.XLFormat))
                                this.XLFormat = new ej.spreadsheetFeatures.cellFormatting(this);
                            if (rObjElem.length) {
                                rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_FormatAsTable").show();
                                rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_Table").show();
                            }
                        }
                        else {
                            if (rObjElem.length) {
                                if (!model.enablePivotTable)
                                    rObjElem.find("#" + xlId + "_Ribbon_insert_Tables").hide();
                                rObjElem.find("#" + xlId + "_Ribbon_home_Styles_Home_Styles_FormatAsTable").hide();
                                rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_Table").hide();
                            }
                        }
                        break;
                    case "enablePivotTable":
                        if (rObjElem.length)
                            if (val) {
                                if (!model.allowFormatAsTable && rObjElem.length)
                                    rObjElem.find("#" + xlId + "_Ribbon_insert_Tables").show();
                                rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_PivotTable").show();
                            }
                            else {
                                if (!model.allowFormatAsTable && rObjElem.length)
                                    rObjElem.find("#" + xlId + "_Ribbon_insert_Tables").hide();
                                rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Tables_Insert_Tables_PivotTable").hide();
                            }
                        break;
                    case "allowAutoSum":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_Home_Editing_AutoSum").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_Home_Editing_AutoSum").hide();
                        break;
                    case "allowCharts":
                        if (val) {
                            if (ej.isNullOrUndefined(this.XLChart) || ej.isNullOrUndefined(this.XLShape)) {
                                this.XLShape = new ej.spreadsheetFeatures.shape(this);
                                this.XLChart = new ej.spreadsheetFeatures.chart(this);
                            }
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Charts").show();
                        }
                        else
                            rObjElem.length && rObjElem.find("#" + xlId + "_Ribbon_insert_Charts").hide();
                        break;
                    case "allowSparkline":
                    if (val) {
                        if (ej.isNullOrUndefined(this.XLSparkline)) 
                             this.XLSparkline = new ej.spreadsheetFeatures.sparkLine(this);
                             var rObj = $('#' + this._id + '_Ribbon').data('ejRibbon');
                             if(this.XLRibbon._contextualTabCollection[4] && this.XLRibbon._tabCollection[1].groups[4]) {
                                 rObj.hideTab("Sparkline Design");
                                 rObjElem.find("#" + xlId + "_Ribbon_insert_SparklineCharts").show();
                             }
                             else if(!this.XLRibbon._contextualTabCollection[4] && !this.XLRibbon._tabCollection[1].groups[4]) {
                             this.XLSparkline._renderSparklineTab();
                             rObj.addTabGroup(2, this.XLSparkline._tabInsert() , 4);
                             this.XLRibbon._tabCollection[1].groups.push(this.XLSparkline._tabInsert());
                             rObj.addContextualTabs(this.XLSparkline._contextualTabInsert(), 11);
                             this.XLRibbon._contextualTabCollection.push(this.XLSparkline._contextualTabInsert());
                             rObj.hideTab("Sparkline Design");
                             }
                }
                else {
                       rObjElem.find("#" + xlId + "_Ribbon_insert_SparklineCharts").hide();
                       rObj.hideTab("Sparkline Design");
                    }
                break;
                    case "printSettings":
                        for (var pageProp in val) {
                            switch (pageProp) {
                                case "allowPrinting":
                                    model.printSettings.allowPrinting = val[pageProp];
                                    if (val[pageProp]) {
                                        this.XLPrint = new ej.spreadsheetFeatures.print(this);
                                        if (rObjElem.length) {
                                            rObjElem.find("#" + xlId + "_Ribbon_pagelayout_Print").show();
                                            rObjElem.find("#print_backStageTab").show();
                                        }
                                    }
                                    else if (rObjElem.length) {
                                        rObjElem.find("#print_backStageTab").hide();
                                        rObjElem.find("#" + xlId + "_Ribbon_pagelayout_Print").hide();
                                    }
                                    break;
                                case "allowPageSize":
                                    model.printSettings.allowPageSize = val[pageProp];
                                    if (rObjElem.length)
                                        if (val[pageProp])
                                            rObjElem.find("#" + xlId + "_Ribbon_pagelayout_PageLayout").show();
                                        else
                                            rObjElem.find("#" + xlId + "_Ribbon_pagelayout_PageLayout").hide();
                                    break;
                            }
                        }
                        break;
                    case "allowLockCell":
                        if (rObjElem.length)
                            if (val) {
                                rObjElem.find("#" + xlId + "_Ribbon_review_Changes_Review_Changes_ProtectSheet").show();
                                rObjElem.find("#" + xlId + "_Ribbon_review_Changes_Review_Changes_LockCell").show();
                            }
                            else {
                                rObjElem.find("#" + xlId + "_Ribbon_review_Changes_Review_Changes_ProtectSheet").hide();
                                rObjElem.find("#" + xlId + "_Ribbon_review_Changes_Review_Changes_LockCell").hide();
                            }
                        break;
                    case "undoRedoStep":
                        this.undoRedoStep = val;
                        break;
                    case "enableTouch":
                        this._wireTouchEvts(val ? "_on" : "_off");
                        break;
                    case "showPager":
                        this.showPager(options[option]);
                        this._refreshSpreadSheetPager();
                        break;
                    case "allowOverflow":
                        this._refreshOverflow();
                        break;
                    case "allowClear":
                        if (rObjElem.length)
                            if (val)
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_Home_Editing_Clear").show();
                            else
                                rObjElem.find("#" + xlId + "_Ribbon_home_Editing_Home_Editing_Clear").hide();
                        break;
                    case "isReadOnly":
                        this._readOnly();
                        break;
                    case "locale":
                        this.model.locale = options[option];
                        this._destroy();
                        this.model.sheets.splice(0, 1);
						this.addClass(this.element[0], this._rootCSS);
                        this._init();
                        break;
                    case "allowCellType":
                        if (val)
                            this.XLCellType = new ej.spreadsheetFeatures.cellType(this);
                        break;
                    case "activationPanelWidth":
					         this.model.apWidth = val;
                             this.getActivationPanel().width(val - 1)
                             break;
                    case "cssClass":
                        this.element.removeClass(this._cssClass).addClass(options[option]);
                        break;
					case "ribbonSettings":
					     this.model.ribbonSettings.applicationTab.type = options.ribbonSettings.applicationTab.type;
					     $("#" + this._id + "_Menu")[0].style.display = (options.ribbonSettings.applicationTab.type === "menu") ? "block" : "none";
					     this.XLRibbon._refreshBSItems(options.ribbonSettings.applicationTab.type);
					     this.XLRibbon._menuCustomize();
						 rObj.setModel({applicationTab:this.XLRibbon._appTabCollection});
						 if (options.ribbonSettings.applicationTab.type === "backstage")
						     this.XLRibbon._isAppTabCreate = false;
					     break;
                }
            }
            if (rObjElem.length && rObj.model) {
                if (!model.allowAutoSum && !model.allowFiltering && !model.allowUndoRedo && !model.allowSorting && !model.allowClipboard && !model.allowFormatPainter && !model.allowCellFormatting && !model.allowMerging && !model.allowWrap && !model.allowConditionalFormats && !model.allowFormatAsTable)
                    rObj.hideTab(this._getLocStr("HOME"));
                else
                    rObj.showTab(this._getLocStr("HOME"));
                if (!model.allowFormatAsTable && !model.allowPictures && !model.allowHyperlink && !model.allowCharts && !model.allowSparkline)
                    rObj.hideTab(this._getLocStr("INSERT"));
                else
                    rObj.showTab(this._getLocStr("INSERT"));
                if (!model.allowDataValidation && !model.allowFiltering && !model.allowSorting)
                    rObj.hideTab(this._getLocStr("DATATAB"));
                else
                    rObj.showTab(this._getLocStr("DATATAB"));
                if (!model.printSettings.allowPrinting)
                    rObj.hideTab(this._getLocStr("PAGELAYOUT"));
                else
                    rObj.showTab(this._getLocStr("PAGELAYOUT"));
                if (!model.allowComments && !model.allowLockCell)
                    rObj.hideTab(this._getLocStr("REVIEW"));
                else
                    rObj.showTab(this._getLocStr("REVIEW"));
                if (!model.allowFreezing && !model.allowInsert && !model.allowDelete && !model.allowSearching)
                    rObj.hideTab(this._getLocStr("OTHERS"));
                else
                    rObj.showTab(this._getLocStr("OTHERS"));
            }
        },

        // Importing
        "import": function (options) {
            if (!this.model.allowImport)
                return;
            var args = {}, otherOptns = {};
            if (!options.dataContainer) {
                if (this.model.allowCellFormatting && this.XLFormat && (this.getObjectLength(this.XLFormat._customFontFamily) > 0))
                    otherOptns["customFontFamily"] = this.XLFormat._customFontFamily;
                if (this._isDefaultLocked)
                    otherOptns["ExcelLikeLockedCells"] = true;
                if (this.getObjectLength(otherOptns))
                    options.dataContainer = JSON.stringify(otherOptns);
            }
            if (options.password && options.password.length)
                args["password"] = options.password;
            if (this.model.beforeImport && this._trigger("beforeImport", args))
                return false;
            if (args.password && args.password.length)
                options.password = args.password;
            var proxy = this,
            opts = {
                type: "POST",
                data: this._import(options),
                async: this.isUndefined(options.async) ? true : options.async,
                url: this.model["importSettings"].importMapper,
                success: function (response) {
                    if (proxy.element)
                        proxy._importSuccess(response);
                },
                error: function (err, type) {
                    proxy._importFailed({ type: type, xhr: { status: err.status, statusText: err.statusText } });
                }
            };
            if (this._browserDetails.name !== "msie" || this._browserDetails.version !== "9.0" || opts.data.append) { // !IE9 with for form only
                opts.processData = false;
                opts.contentType = false;
            }
            $('#' + this._id + "_Ribbon_BackStage").hide();
            proxy.showWaitingPopUp();
            $.ajax(opts);
        },

        _import: function (options) {
            if (window.FormData && this._isObject(options)) {
                var i, prop, formData = new FormData();
                for (prop in options) {
                    if (prop != "async")
                        formData.append(prop, options[prop]);
                }
                return formData;
            }
            else
                return options;
        },

        _importSuccess: function (response) {
            var error = ["UnsupportedFile", "IncorrectPassword", "InvalidUrl", "NeedPassword", "CancellationRequested"], args;
            this._renderAlertdlg();
            if (error.indexOf(response) > -1) {
                switch (response) {
                    case error[0]:
                    case error[1]:
                    case error[2]:
					case error[4]:
                        this._showAlertDlg("Alert", response, "", null, 110);
                        break;
                    case error[3]:
                        this._showDialog(this._id + "_ImportPasswordDialog");
                        this.model.importSettings.password = "";
                        break;
                }
                this.hideWaitingPopUp();
            }
            else {
                args = { data: response, reqType: "importing" };
                if (this._trigActionBegin(args)) {
                    this.hideWaitingPopUp();
                    return;
                }
                response = args.data;
                this.loadFromJSON(JSON.parse(response));
            }
        },

        loadFromJSON: function (response) {
            this.isImport = true;
            var isReadOnly = this.model.isReadOnly;
            if (isReadOnly)
                this.model.isReadOnly = false;
            $("#" + this._id + "_file").ejUploadbox("option", "autoUpload", true);
			if(typeof response.model === "string")
			   response["model"] = JSON.parse(response.model);
			if(typeof response.dataContainer === "string")
			   response["dataContainer"] = JSON.parse(response.dataContainer); 
			if (this.getObjectLength(response.model.sheets[0]))
			    response.model.sheets.unshift({});
            var sheetIdx, sheets, cnts, i = 1, args, nmgr = response.model && response.model.nameManager, j;
            if (nmgr && nmgr.length) {
                for (j in nmgr)
                    nmgr[j].refersto = this._decode(nmgr[j].refersto);
            }
            if (this._isSheetReq) {
                sheetIdx = Number(this.getObjectKeys(response.dataContainer.sheets)[0]);
                this._refreshImpStyles(response.dataContainer.hashCode);
                this._impData.dataContainer = $.extend(true, {}, response.dataContainer);
                this._impData.dataContainer.sheets = this._dataContainer.sheets;
                this._impData.dataContainer.cellType = this._dataContainer.cellType;
                this._impData.dataContainer.sheets[sheetIdx] = response.dataContainer.sheets[sheetIdx];
                this._impData.model.sheets[sheetIdx] = response.sheet;
                this._dataContainer = $.extend(true, {}, this._impData.dataContainer);
                this._dataContainer.sheetCellType = {};
                this._refreshModel(response.sheet, true, sheetIdx);
                this._sheetSettings(sheetIdx);
                if (!this._intrnlReq)
                    this.gotoPage(sheetIdx, false);
                this._isSheetReq = false;
            }
            else {
                if (!this.model.scrollSettings.allowVirtualScrolling)
                    cnts = this._getMaxRowColCnt(response.model.sheets, true);
                if (this.model.scrollSettings.allowVirtualScrolling || (response.dataContainer.sharedData.length < 50001 && cnts.rowCount < 10001 && cnts.colCount < 126)) {
                    this._impData = response;
                    args = { importData: response };
                    if (this._trigger("onImport", args))
                        return;
                    if (this._isInitLoad)
                        this._initBase();
                    else {
                        this._destroy();
                        this._refreshModel(response.model);
                        this._dataContainer = $.extend(true, {}, response.dataContainer);
                        this._dataContainer.sheetCellType = {};
                        this._initCSSTag();
                        while (i <= this.model.sheetCount) {
                            this._sheetSettings(i);
                            this._newSIndex++;
                            i++;
                        }
                        i = 1;
                        while (i <= this.model.sheetCount) {
                            if (!this.model.scrollSettings.allowVirtualScrolling && !this.model.importSettings.allowSheetOnDemand)
                                this._initSheet(i);
                            i++;
                        }
                        this._refreshNameMngr(response.model.nameManager);
                        this.gotoPage(this.getActiveSheetIndex(), false);
                        this._isRibbonDestroyed = false;
                    }
                    this._calcEngine.setCalculatingSuspended(response.model.isManualCalculation || false);
                    this._trigger("loadComplete");
                    this.clearUndoRedo();
                }
                else
                    this._showAlertDlg("Alert", "HugeDataAlert");
            }
            for (var i = 0, keys = this.getObjectKeys(response.dataContainer.customCellStyle) ; i < keys.length; i++)
                this.XLFormat.addNewCustomStyle(keys[i], response.dataContainer.customCellStyle[keys[i]]);
            if (!this._intrnlReq)
                this.isImport = false;
            this._intrnlReq = false;
            this._renderDDownList();
            this.hideWaitingPopUp();
            this.model.showRibbon && this.XLRibbon._updateRibbonIcons();
            this.model.isReadOnly = isReadOnly;
        },

        _importFailed: function (response) {
            var args = { failureType: response.type };
            if (response.xhr) {
                args.status = response.xhr.status;
                args.statusText = response.xhr.statusText;
            }
            else
                args.statusText = response.error;
            this.hideWaitingPopUp();
            this._trigger("openFailure", args);
        },

        _importSheet: function (sheetIdx, async) {
            var opts = {}, isettings = this.model.importSettings;
            this._isSheetReq = true;
            opts = { sheetIndex: sheetIdx, allowSheetOnDemand: isettings.allowSheetOnDemand, password: isettings.password, async: async };
            opts.dataContainer = JSON.stringify({ hashCode: this._dataContainer.hashCode, sharedData: this._dataContainer.sharedData, valData: this._dataContainer.valData, cFormatData: this._dataContainer.cFormatData });
            this["import"](opts);
            this.getSheet(sheetIdx)._isRequested = true;
        },
        _decode: function (value) {
            return $('<div/>').html(value).text();
        },

        _refreshModel: function (options, isSheet, sheetIdx) {
            var len, prop, sheet, i = 1;
            if (options) {
                if (isSheet) {
                    sheet = this.model.sheets[this._getSheetIndex(sheetIdx)];
                    sheet.rowCount = options.rowCount || this.defaults.rowCount;
                    sheet.colCount = options.colCount || this.defaults.colCount;
                }
                else {
                    this.model.sheetCount = options.sheetCount || this.defaults.sheetCount;
                    this.model.activeSheetIndex = options.activeSheetIndex || this.defaults.activeSheetIndex;
                    this.model.rowHeight = options.rowHeight || this.defaults.rowHeight;
                    this.model.columnWidth = options.columnWidth || this.defaults.columnWidth;
                    if(!this._isRefresh) {
						this.model.sheets = [{}];
						len = options.sheets.length;
						while (i < len) {
							sheet = options.sheets[i];
							prop = {
								rowCount: sheet.rowCount || this.defaults.rowCount,
								colCount: sheet.colCount || this.defaults.colCount
							};
							this.model.sheets.push(prop);
							i++;
						}
					}
                    if (options.nameManager && options.nameManager.length)
                        this.model.nameManager = options.nameManager;
                }
            }
            else {
                len = this.model.sheets.length;
                if (this.model.sheetCount < len)
                    this.model.sheetCount = len;
            }
            if (this.model.apWidth === 300 && this.model.activationPanelWidth !== 300)
                this.model.apWidth = this.model.activationPanelWidth;
            else if (this.model.apWidth !== 300 && this.model.activationPanelWidth === 300)
                this.model.activationPanelWidth = this.model.apWidth;
        },

        _refreshImpStyles: function (hashcode) {
            var format, code, i = 0, len = hashcode.length;
            while (i < len) {
                code = hashcode[i];
                if (this._dataContainer.hashCode.indexOf(code) === -1) {
                    if (code.indexOf("e-format") === -1) {
                        this._dataContainer.hashCode.push(code);
                        if (code.length < 25) // default border hashcode max len 24 
                            this.XLFormat._writeCssRules(code, this.XLFormat._getCssPropertyAsString({ border: this.XLFormat.getBorderFromHashCode(code) }));
                    }
                    else {
                        format = this.XLFormat.getFormatFromHashCode(code);
                        this.XLFormat._createFormatClass(format);
                    }
                }
                i++;
            }
        },

        _refreshImpSheets: function (sheetIdx) {
            var sheet = this._impData.model.sheets[sheetIdx];
            container = this._impData.dataContainer;
            this._refreshImpCells(sheetIdx);
            this._refreshImpCF(sheetIdx);
            if (this.model.allowMerging && sheet.mergedCells)
                this._refreshImpMC(sheet.mergedCells); //possible
            if (this.model.allowFiltering && sheet.filterSettings && sheet.filterSettings.range)
                this.XLFilter._filterCellRange(sheetIdx, sheet.filterSettings.range);
            this._refreshImpHC(sheet.hideColsCollection);
            this._refreshImpHR(sheet.hideRowsCollection);
            this._refreshImpTable(sheet.tableManager);
            this._refreshOverflow();
            if (this.model.allowCellType)
                this._refreshSheetCellTypes(this._impData.dataContainer.sheetCellType, sheetIdx);
			this._refreshShapePosOnImp(sheet.shapeMngr, sheetIdx);
            this._refreshImpCharts(sheet.shapeMngr.chart);
            this._refreshImpSparkline(sheet.shapeMngr.sparkline, sheetIdx)
            this._refreshImpPics(sheet.shapeMngr, sheetIdx);
            this._refreshImpPvts(sheet.pivotMngr, sheetIdx);
            if (sheet.showGridlines === false)
                $("#" + this._id + "_Ribbon_PageLayout_Show_Gridlines").ejCheckBox({ checked: sheet.showGridlines });
            if (sheet.isSheetProtected)
                this.protectSheet(true);
        },

        _refreshImpCells: function (sheetIdx) {
            var data, len, i = 0, usedRange = this.getSheet(sheetIdx).usedRange,
                datas = this.XLEdit._getPropWithCellIdx([0, 0, usedRange.rowIndex, usedRange.colIndex], "value", sheetIdx, true), len = datas.length;
            while (i < len) {
                data = datas[i];
                this.XLEdit._refreshCalcEngine(data.rowIdx, data.colIdx, true, data.value, sheetIdx);
                i++;
            }
            if (this.model.allowCellFormatting && this.model.formatSettings.allowCellBorder) {
                i = 0;
                datas = this.XLEdit._getPropWithCellIdx([0, 0, usedRange.rowIndex, usedRange.colIndex], "borders", sheetIdx);
                len = datas.length;
                while (i < len) {
                    data = datas[i];
                    this.XLFormat.applyBorder(data.value, [data.rowIdx, data.colIdx, data.rowIdx, data.colIdx]);
                    i++;
                }
            }
        },

        _refreshSheetCellTypes: function (sheets, sheetIdx) {
            var arr = [], i, len;
            if (this.getObjectLength(sheets) < 1)
                return;
            for (i = 1, len = this.getObjectLength(sheets[sheetIdx]) ; i <= len; i++)
                arr.push({ "range": sheets[sheetIdx][i].settings.range, "settings": sheets[sheetIdx][i].settings });
            this.XLCellType._rangeCellTypes(arr, sheetIdx, true);
        },

        _refreshImpCF: function (sheetIdx) {
            if (this.model.allowConditionalFormats) {
                var split, i, idx, len = this._impData.dataContainer.cFormatData.length;
                for (i = 0; i < len; i++) {
                    split = this._impData.dataContainer.cFormatData[i].split("_");
                    idx = Number(split[5]);
                    if (idx === sheetIdx) {
                        this.XLCFormat._cFormat(split[0], split[1], split[2], split[3], split[4], split[6], idx, this.getRangeIndices(split[6]));
                        this._impData.dataContainer.cFormatData.splice(i, 1);
                        len = this._impData.dataContainer.cFormatData.length;
                        i--;
                    }
                }
            }
        },

        _refreshImpMC: function (mergeCells) {
            var mergeCell, i = mergeCells.length;
            if (i) {
                while (i--) {
                    mergeCell = mergeCells[i];
                    if (mergeCell.isCenterAlign)
                        this.mergeCenter = true;
                    this.mergeCells(mergeCell.range, true);
                    this.mergeCenter = false;
                }
            }
        },

        _refreshImpHC: function (hideCols) {
            var colIdx, hideIdxCln = this.getObjectKeys(hideCols), i = hideIdxCln.length;
            if (i) {
                while (i--) {
                    colIdx = parseInt(hideIdxCln[i]);
                    this._hideColumn(colIdx, colIdx);
                }
            }
        },

        _refreshImpResRowHght: function (sheetIdx) {
            var i, k, span, cls, cIdx, rIdx, hashIdx, cellsData, sheet = this.getSheet(sheetIdx), rowsCols = sheet._restrictedHeightRows, sheetData = this._dataContainer.sheets[sheetIdx],
            hashCodes = this._dataContainer.hashCode, range, height, cellStyle, canRefresh = true, mRangeCol = [], val;
            if(this._impData && this._impData.model.sheets[sheetIdx] && this._impData.model.sheets[sheetIdx].mergedCells)
			      mergedCells = this._impData.model.sheets[sheetIdx].mergedCells;
		    else if(this._copySheet)
				  mergedCells = sheet.mergedCells;
			else
				  mergedCells = [];
            for (k = 0; k < mergedCells.length; k++) {
                range = this.getRangeIndices(mergedCells[k]["range"]);
                mRangeCol.push(range);
            }
            span = this.element.find("#" + this._id + "_emptyDiv");
            for (i = 0; i < rowsCols.length; i++) {
                rIdx = rowsCols[i];
                cellsData = sheetData[rIdx];
                for (cIdx in cellsData) {
                    val = this._dataContainer.sharedData[cellsData[cIdx].value];
                    if (!val || this.isFormula(val))
                        continue;
                    hashIdx = cellsData[cIdx].formats;
                    if (hashIdx) {
                        cls = hashCodes[hashIdx];
                        if (cellsData[cIdx].wrap) {
                            for (k in mRangeCol) {
                                range = mRangeCol[k];
                                if (range[0] <= rIdx && range[2] >= rIdx) {
                                    if (range[1] <= cIdx && range[3] >= cIdx) {
                                        canRefresh = false;
                                        break;
                                    }
                                }
                            }
                            if (canRefresh) {
                                span.width(sheet.columnsWidthCollection[cIdx] - 3); //3 - td padding (left = 2, right = 1)
                                cls += " e-sswraptext";
                            }
                        }
                        this.addClass(span[0], cls);
                        span.text(val);
                        height = span[0].offsetHeight + 1; // 1 - td bottom border
                        if (sheet.rowsHeightCollection[rIdx] < height)
                            sheet.rowsHeightCollection[rIdx] = height;
                        this._refreshGlobalSpan(null, true);
                        canRefresh = true;
                    }
                }
            }
        },

        _refreshImpHR: function (hideRows) {
            var i, idx, preRowIdx, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), hideRows = hideRows || [];
            var rowColl = this.getRows(sheetIdx), rows = rowColl[1], hdrRows = rowColl[0], rowHdrCon = this._getJSSheetRowHeaderContent(sheetIdx), rowHdrElem = rowHdrCon.find("tr"), len;
            for (i = 0, len = hideRows.length; i < len; i++) {
                idx = parseInt(hideRows[i]);
                preRowIdx = idx ? idx - 1 : 0;
                if (this.isUndefined(this.XLEdit.getPropertyValue(preRowIdx, 0, "isRHide")))
                    this.XLEdit._updateDataContainer({ rowIndex: preRowIdx, colIndex: 0 }, { dataObj: { "hRow": true } });
                if (this.model.scrollSettings.allowVirtualScrolling)
                    this.addClass(rowHdrCon.find("[idx =" + preRowIdx + "] .e-rowheader")[0], "e-hrow");
                else {
                    this.addClass(rowHdrElem.find(".e-rowheader")[preRowIdx], "e-hrow");
                    this.addClass(rows[idx], "e-r-hide");
                    this.addClass(hdrRows[idx], "e-r-hide");
                }
                this.XLScroll._getRowHeights(sheetIdx, sheet.hideRowsCollection.sort()[0]);
            }
        },

        _refreshImpTable: function (tmngr) {
            var range, format, table, i = this.getObjectLength(tmngr);
            if (this.model.allowFormatAsTable && i) {
                while (i--) {
                    table = tmngr[i];
                    range = table.range;
                    format = this.XLFormat._getTableLayoutFromName(table.formatName);
                    if (!format) {
                        format = this.XLFormat._formatAsTableStyle;
                        table.formatName = format.formatName;
                    }
                    this.XLFormat.createTable({ header: true, name: "Table" + (this._tableCnt), format: format.format, formatName: table.formatName, showHeaderRow: table.showHeaderRow }, this._getAlphaRange(this.getActiveSheetIndex(), range[0], range[1], range[2], range[3]));
                }
            }
        },

        _refreshImpCharts: function (charts) {
            if (this.model.allowCharts) {
                var sheet, chart, i = 0, len = this.getObjectLength(charts);
                while (i < len) {
                    chart = charts["chart" + i];
                    sheet = this.getSheet(chart.dataSheetIdx);
                    if (chart.dataSheetIdx != this.getActiveSheetIndex() && sheet._isImported && !sheet._isRequested) {
                        this._intrnlReq = true;
                        this._importSheet(chart.dataSheetIdx, false);
                    }
                    this.XLChart.createChart(chart.series ? null : chart.range , { type: chart.commonSeriesOptions.type, enable3D: chart.enable3D, marker: chart.commonSeriesOptions.marker, top: chart.top, left: chart.left, height: chart.size.height, width: chart.size.width, title: chart.title, legend: chart.legend, primaryYAxis: chart.primaryYAxis, primaryXAxis: chart.primaryXAxis || {labelIntersectAction: 'wrapByWord'}, dataSheetIdx: chart.dataSheetIdx , series:chart.series, seriesRange: chart.seriesRange, isRowColSwitched: chart.isRowColSwitched });
                    i++;
                }
            }
        },
        
          _refreshImpSparkline: function (sparkline, sheetIdx) {
            if (this.model.allowSparkline) {
                var i = 0,cellInfo,dataRngeValue, len, sparklineObj = this.getObjectKeys(sparkline), arr=[];
                while (i < sparklineObj.length) {
                    sparklineChart =  sparkline[sparklineObj[i]];
                    cellInfo = this._getCellInfo({ rowIndex: sparklineChart.rowIndex, colIndex: sparklineChart.colIndex }, sparklineChart.sheetIdx);
                    dataRngeValue = this.getRangeData({range: this._getRangeArgs(sparklineChart.DataRange, Array, sparklineChart.SheetIndex), property:["value"], sheetIdx:sparklineChart.SheetIndex });
                    for(var j=0, len = dataRngeValue.length; j< len; j++)
                        arr.push(parseInt(dataRngeValue[j].value));
                    sparklineChart["dataSource"] = arr;
                    this.XLSparkline._createSparkline(sparklineChart, cellInfo, sheetIdx);
                    arr = [];
                    i++;
                }
            }
        },

        _refreshImpPics: function (shapeMngr, sheetIdx) {
            if (this.model.pictureSettings.allowPictures) {
                var pic, i = 0, picCln = this.getObjectKeys(shapeMngr.picture), len = picCln.length;
                while (i < len) {
                    pic = shapeMngr.picture[picCln[i]];
                    pic.sheetIdx = sheetIdx;
                    if (!this.getSheet(sheetIdx)._isUpdated)
                        this.XLShape._createPicture(sheetIdx, null, shapeMngr.sharedPics[pic.data], pic.top, pic.left, pic.width, pic.height, null, pic.bcolor, pic.bstyle, pic.bwidth, pic);
                    else {
                        pic.imgData = shapeMngr.sharedPics[pic.data];
                        this.XLShape._refreshPictureElement(pic);
                    }
                    i++;
                }
            }
        },

        _refreshShapePosOnImp: function (shapeMngr, sheetIdx) {
            var chartMngr = shapeMngr.chart, picMngr = shapeMngr.picture, i, diff, key, orgHght, topVal, sheet = this.getSheet(sheetIdx), rowHghtColl = sheet._rowHeightCollection, sRowHght = sheet.rowsHeightCollection, impRowHght = this._impData ? this._impData.model.sheets[sheetIdx].rowsHeightCollection : [];
            if (!this.getObjectLength(picMngr) && !this.getObjectLength(chartMngr))
                return false;
            for (i = 0; i < impRowHght.length; i++) {
                if (impRowHght[i] !== sRowHght[i]) {
                    diff = sRowHght[i] - impRowHght[i];
                    orgHght = rowHghtColl[i + 1] - diff;
                    for (key in picMngr) {
                        topVal = picMngr[key].top;
                        if (topVal > orgHght)
                            picMngr[key].top = topVal + diff;
                    }
                    for (key in chartMngr) {
                        topVal = chartMngr[key].top;
                        if (topVal > orgHght)
                            chartMngr[key].top = topVal + diff;
                    }
                }
            }
        },

        _refreshImpPvts: function (pivotMngr, sheetIdx) {
            if (this.model.enablePivotTable && pivotMngr) {
                var pvt, i = 0, len = this.getObjectLength(pivotMngr.pivot), objKeys = this.getObjectKeys(pivotMngr.pivot), settings;
                while (i < len) {
                    pvt = pivotMngr.pivot[objKeys[i]];
                    settings = {
                        rows: pvt.rows,
                        columns: pvt.columns,
                        values: pvt.values,
                        filters: pvt.filters
                    };
                    if (!this.getSheet(sheetIdx)._isUpdated)
                        this.XLPivot.createPivotTable(pvt.dataSheetName + "!" + this._getProperAlphaRange(this._getSheetIndexByName(pvt.dataSheetName), pvt.dataRange[0], pvt.dataRange[1], pvt.dataRange[2], pvt.dataRange[3]), this.getSheet(pvt.sheetIdx).sheetInfo.text + "!" + this._getProperAlphaRange(pvt.sheetIdx, pvt.rowIndex, pvt.colIndex, pvt.rowIndex, pvt.colIndex), objKeys[i], settings, pvt);
                    else
                        this.XLPivot._refreshPivotElement(pvt.dataSheetName + "!" + this._getProperAlphaRange(this._getSheetIndexByName(pvt.dataSheetName), pvt.dataRange[0], pvt.dataRange[1], pvt.dataRange[2], pvt.dataRange[3]), this.getSheet(pvt.sheetIdx).sheetInfo.text + "!" + this._getProperAlphaRange(pvt.sheetIdx, pvt.rowIndex, pvt.colIndex, pvt.rowIndex, pvt.colIndex), objKeys[i], settings, pvt);
                    i++;
                }
            }
            (!this._isExport) && this._getContent(sheetIdx).find(".e-ss-activepivot").removeClass("e-ss-activepivot");
            this.hideActivationPanel();
        },

        _refreshNameMngr: function (nameMgr) {
            nameMgr = nameMgr || this.model.nameManager;
            var i = nameMgr.length;
            if (this.model.showRibbon) {
                if (i) {
                    while (i--)
                        this.XLRibbon._updateNamedRanges(nameMgr[i].name, nameMgr[i].refersto, true);
                }                
                this.XLRibbon._updateUseInFormulaTrgt();
            }
            this.model.nameManager = nameMgr
            this.XLEdit._refreshAutoComplete();
        },

        _getBorderInput: function (str) {
            str = str.split("_");
            var i = 4, obj = {}, arr = ["top", "right", "bottom", "left"];
            while (i--) {
                if (str[i].length)
                    obj[arr[i]] = str[i];
            }
            return obj;
        },

        _refreshHashCode: function (hashCode) {
            hashCode = hashCode || this._dataContainer.hashCode;
            var code, i = hashCode.length;
            while (i--) {
                code = hashCode[i];
                if (code.indexOf("e-format") === -1 && code.indexOf("e-border") === -1)
                    hashCode[i] = "";
            }
        },

        clearUndoRedo: function () {
            this._undoCollection = [];
            this._redoCollection = [];
            this._updateUndoRedoIcons();
        },

        _initializePicture: function (sheetIdx) {
            this._getJSSheetContent(sheetIdx).find(".e-spreadsheetcontentcontainer > .e-content").append(ej.buildTag("div.e-ss-imgvisual"));
        },

        _getShapePositionInManager: function (rowIndex, colIndex, id, shapeType) {
            var sheetIdx = this.getActiveSheetIndex(), cellObj = this._dataContainer.sheets[sheetIdx][rowIndex][colIndex], i, len;
            for (i = 0, len = cellObj.length; i < len; i++)
                if (cellObj[shapeType][i].id === id)
                    break;
            return i;
        },

        _swapVal: function (val) {
            var temp = val.prev;
            val.prev = val.cur;
            val.cur = temp;
        },

        _getValue: function (coll, key) {
            var obj, i = coll.length;
            while (i--) {
                obj = coll[i];
                if (obj.value === key)
                    return obj.value;
            }
        },

        _isRowViewable: function (sheetIdx, rowIdx) {
            var sheet = this.getSheet(sheetIdx), isInView = sheet._isVPRendered;
            if (this.model.scrollSettings.allowVirtualScrolling)
                isInView = sheet._virtualRowIdx.indexOf(rowIdx) > -1;
            return isInView;
        },

        _isColumnViewable: function (sheetIdx, colIdx) {
            return true;
        },

        _undoRedoOperation: function (evtobj) {
            var val, undoVal, actCell = this.getActiveCell();
            if ((evtobj.which === 90 || evtobj.keyCode === 90) && evtobj.ctrlKey) {
                evtobj.preventDefault();
                if (evtobj.target.id.indexOf("_Edit") > -1 || evtobj.target.id.indexOf("_input") > -1) {
                    val = this.XLEdit.getCurrentEditCellData();
                    if (val !== this._cureditedCell) {
                        undoVal = val;
                        if (evtobj.target.id.indexOf("_Edit") > -1)
                            evtobj.target.textContent = this._cureditedCell;
                        else
                            $("#" + this._id + "_Edit")[0].textContent = this._cureditedCell;
                        if (this.model.allowFormulaBar)
                            this._getInputBox().val(this._cureditedCell);
                        this._undoInputobj = { value: undoVal, rowIndex: actCell.rowIndex, colIndex: actCell.colIndex };
                    }
                }
                else {
                    this._isUndo = true;
                    this._performUndoRedo();
                }
            }
            else if ((evtobj.which === 89 || evtobj.keyCode === 89) && evtobj.ctrlKey) {
                evtobj.preventDefault();
                if (evtobj.target.id.indexOf("_Edit") > -1 || evtobj.target.id.indexOf("_input") > -1) {
                    if (actCell.rowIndex === this._undoInputobj.rowIndex && actCell.colIndex === this._undoInputobj.colIndex) {
                        if (evtobj.target.id.indexOf("_Edit") > -1)
                            evtobj.target.textContent = this._undoInputobj.value;
                        else
                            $("#" + this._id + "_Edit")[0].textContent = this._undoInputobj.value;
                        if (this.model.allowFormulaBar)
                            this._getInputBox().val(this._undoInputobj.value);
                    }
                }
                else {
                    this._isUndo = false;
                    this._performUndoRedo();
                }
            }
        },
        undo: function() {
            this._isUndo = true;
            this._performUndoRedo();
        },
        redo: function() {
            this._isUndo = false;
            this._performUndoRedo();
        },

        _performUndoRedo: function () {
            var val = (this._isUndo) ? this._undoCollection.pop() : this._redoCollection.pop(), args;
            if (!ej.isNullOrUndefined(val)) {
                if (val.sheetIndex !== this.getActiveSheetIndex())
                    this.gotoPage(val.sheetIndex, null);
                this._isUndoRedo = true;
                switch (val.reqType) {
                    case "auto-fill":
                        this._undoForAutoFill(val);
                        break;
                    case "auto-sum":
                        this._undoForAutoSum(val);
                        break;
                    case "cell-format":
                        this._undoForFormat(val);
                        break;
                    case "cell-styles":
                        this._undoForStyle(val);
                        break;
                    case "clear-all":
                        this._undoForClAll(val);
                        break;
                    case "clear-comment":
                        this._undoForClComment(val);
                        break;
                    case "clear-content":
                        this._undoForClContent(val);
                        break;
                    case "clear-format":
                        this._undoForClFormat(val);
                        break;
                    case "clear-link":
                        this._undoForCLLink(val);
                        break;
                    case "comment":
                        this._undoForComment(val);
                        break;
                    case "cond-format":
                        this._undoForCondFormat(val);
                        break;
                    case "copy-paste": {
						this._isCopyPaste = true;
                        this._undoForCopyPaste(val);
						this._isCopyPaste = false;
                        break;
					}
                    case "cut-paste":
						this._isCopyPaste = true;
                        this._undoForCutPaste(val);
						this._isCopyPaste = false;
                        break;
                    case "delete":
                        this._undoForDel(val);
                        break;
                    case "edit":
                        this._undoForEdit(val);
                        break;
                    case "filter":
                        this._undoForFilter(val);
                        break;
                    case "filterbycolor":
                        this._undoForFilterByColor(val);
                        break;
                    case "find-replace":
                        this._undoForFind(val);
                        break;
                    case "format-painter":
                        this._undoForFormatPaint(val);
                        break;
                    case "format-table":
                        this._undoForFormatTable(val);
                        break;
                    case "hyperlink":
                        this._undoForHyperlink(val);
                        break;
                    case "insert":
                        this._undoForIns(val);
                        break;
                    case "merge-cells":
                        this._undoForMerge(val);
                        break;
                    case "paging":
                        var tmpIdx = val.nSheetIndex;
                        val.nSheetIndex = val.sheetIndex;
                        val.sheetIndex = tmpIdx;
                        break;
                    case "pivotgrid":
                        this._undoForPivot(val);
                        break;
                    case "resize-column":
                        this._undoForResizeCol(val);
                        break;
                    case "resize-row":
                        this._undoForResizeRow(val);
                        break;
                    case "resize-fit-height":
                        this._undoForResizeFHeight(val);
                        break;
                    case "resize-fit-width":
                        this._undoForResizeFWidth(val);
                        break;
                    case "reorder-cells":
                        this._undoForReOrder(val);
                        break;
                    case "show-hide":
                        this._undoForShowHide(val);
                        break;
                    case "shape":
                        this._undoForShape(val);
                        break;
                    case "sort":
                        this._undoForSort(val);
                        break;
                    case "sortbycolor":
                        this._undoForSortByColor(val);
                        break;
                    case "textwrap":
                        this._undoForTextWrap(val);
                        break;
                    case "validation":
                        this._undoForValidation(val);
                        break;
                    case "sparkline":
                        this.XLSparkline._undoForSparkline(val);
                        break;
                }
                (this._isUndo) ? this._redoCollection.push(val) : this._undoCollection.push(val);
                args = { sheetIdx: val.sheetIndex, reqType: this._isUndo ? "undo" : "redo", operation: val };
                if (this._undoCollection.length > this.undoRedoStep)
                    this._undoCollection.splice(0, 1);
                if (this._redoCollection.length > this.undoRedoStep)
                    this._redoCollection.splice(0, 1);
                this._updateUndoRedoIcons();
                if (this.model.showRibbon)
                    this.XLRibbon._updateRibbonIcons();
                this._isUndoRedo = false;
                this._isUndo = false;
                (this.model.allowSelection && val.reqType != "shape") && this.XLSelection._refreshBorder();
				this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
                if (this._trigActionComplete(args))
                    return;
            }
        },

        _undoForAutoFill: function (val) {
            var sheet = this.getSheet(val.sheetIndex);
            if (this._isUndo) {
                this.clearRangeData(val.range, this._cellProp);
                if (this.model.allowCellFormatting) {
                    this.XLFormat.removeStyle(val.range);
                    this.XLFormat.updateFormat(val.bFormat, val.range);
                    for(var i = val.range[0]; i <= val.range[2]; i++)
                        this.XLResize.setRowHeight(i, val.bHeight[i]);
                }
                this.updateData($.extend(true, [], val.bData), val.range);
                val.actionType == "flash-fill" && this.updateData($.extend(true, [], val.bdData), val.bRange);
                if (val.colSel)
                    this.XLSelection.selectColumns(sheet._startCell.colIndex, sheet._endCell.colIndex);
                else if (val.rowSel)
                    this.XLSelection.selectRows(sheet._startCell.rowIndex, sheet._endCell.rowIndex);
                else
                    this.performSelection({ rowIndex: val.bRange[0], colIndex: val.bRange[1] }, { rowIndex: val.bRange[2], colIndex: val.bRange[3] });
            }
            else {
                if (this.model.allowCellFormatting) {
                    this.XLFormat.removeStyle(val.range);
                    this.XLFormat.updateFormat(val.aFormat, val.range);
                }
                this.updateData($.extend(true, [], val.aData), val.range);
                this.XLCFormat.refreshCFormat();
                val.actionType == "flash-fill" && this.updateData($.extend(true, [], val.adData), val.bRange);
                for (var i = val.range[0]; i <= val.range[2]; i++)
                    this.XLResize.setRowHeight(i, val.aHeight[i]);
                this.performSelection({ rowIndex: val.bRange[0], colIndex: val.bRange[1] }, { rowIndex: val.range[2], colIndex: val.range[3] });
            }
        },

        _undoForAutoSum: function (val) {
            var container = this._dataContainer.sheets[val.sheetIndex], cell, pObj;
            if (this._isUndo) {
                for (var i = 0, len = val.updCell.length; i < len; i++) {
                    cell = this.getCell(val.updCell[i].rowIndex, val.updCell[i].colIndex, val.sheetIndex);
                    this._clearFormula(val.updCell[i].rowIndex, val.updCell[i].colIndex);
                    this.clearRangeData([val.updCell[i].rowIndex, val.updCell[i].colIndex, val.updCell[i].rowIndex, val.updCell[i].colIndex], ["value2"], null, true);
                    pObj = $.extend(true, {}, val.updCell[i].pObj)
                    container[val.updCell[i].rowIndex][val.updCell[i].colIndex] = pObj;
                    cell.text(val.updCell[i].pValue);
                }
                this.performSelection(val.range);
            }
            else
                this.XLRibbon.autoSum(val.oprType, val.range);
        },

        _undoForClAll: function (val) {
            var activeCell, tblRange, tab, sheet = this.model.sheets[val.sheetIndex], rowIdx, colIdx;
            this._isPaste = this._dupDetails = true;
            if (this._isUndo) {
                this.updateData($.extend(true, [], val.bData), val.range);
                this.XLFormat.updateFormat($.extend(true, [], val.bBorder), val.range);
                for (var i = 0, len = val.wrapColl.length; i < len; i++)
                    this.setWrapText("wrap", [val.wrapColl[i].rowIdx, val.wrapColl[i].colIdx, val.wrapColl[i].rowIdx, val.wrapColl[i].colIdx]);
                for (var i = 0, len = val.mergeColl.length; i < len; i++) {
                    this.mergeCenter = val.mergeColl[i].mergeObj.isCenterAlign;
                    this.mergeCells(val.mergeColl[i].mergeObj.mRange, true);
                }
            }
            else {
                if (this.model.showRibbon && this.XLRibbon._isMergeSelect && this.XLRibbon._isFilterSelect.status) {
                    this.clearRangeData(val.range, ["value", "value2", "hyperlink", "cFormatRule", "comment"], "", false);
                    this.XLFormat.removeStyle(null, { cellStyle: true, format: true });
                }
                else
                    this.clearRangeData(val.range, ["value", "value2", "format", "formats", "type", "formatStr", "decimalPlaces", "thousandSeparator", "hyperlink", "comment", "cFormatRule", "border"]);
                this.setWrapText("unwrap", val.range);
                this.unmergeCells(val.range);
            }
            this._isPaste = this._dupDetails = false;
            if (val.tblObj) {
                if (this._isUndo) {
                    this.XLClipboard._isCut = true;
                    this.XLFormat.createTable(val.tblObj, val.tblObj.range);
                    this.XLClipboard._isCut = false;
                }
                else {
                    this.XLFormat.removeTable(val.tblObj.tblId);
                    this.clearRangeData(val.range, ["value", "value2", "format", "formats", "type", "formatStr", "decimalPlaces", "thousandSeparator", "hyperlink", "comment", "cFormatRule"]);
                    this.XLFormat.removeStyle(val.range, { cellStyle: true, tableStyle: true, format: true, border: true });
                    this.XLRibbon._toggleDesignTab(this.getActiveCell());
                }
            }            
			if (this.model.allowConditionalFormats)
                this.XLCFormat.refreshCFormat(val.range);
            (this.model.allowDataValidation && !this._isUndo) && this.XLValidate.clearDV();
            if (this.model.allowFormulaBar)
                this.updateFormulaBar();
        },

        _undoForClComment: function (val) {
            var cell, startCell, endCell;
            if (!val.selectedCell.length)
                return;
            startCell = { rowIndex: val.selectedCell[0].rowIndex, colIndex: val.selectedCell[0].colIndex };
            endCell = { rowIndex: val.selectedCell[val.selectedCell.length - 1].rowIndex, colIndex: val.selectedCell[val.selectedCell.length - 1].colIndex };
            if (this._isUndo) {
                for (var i = 0, len = val.selectedCell.length; i < len; i++) {
                    cell = { rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex };
                    this.XLEdit._updateDataContainer({ rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex }, { dataObj: { "comment": val.selectedCell[i].prevComment } });
                    this.XLSelection.selectRange(cell, cell);
                    this.XLComment.setComment();
                    this.XLComment._updateCurCmntVal();
                }
            }
            else {
                this.XLSelection.selectRange(startCell, endCell);
                this.XLComment.deleteComment(undefined, null, false, "clear");
            }
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForClContent: function (val) {
            (this._isUndo) ? this.updateData($.extend(true, [], val.bData), val.range) : this.clearRangeData(val.range, ["value", "value2", "type", "hyperlink"], val.reqType);
            if (this.model.allowConditionalFormats)
                this.XLCFormat.refreshCFormat(val.range);
            if (this.model.allowFormulaBar)
                this.updateFormulaBar();
        },

        _undoForClFormat: function (val) {
            var container = this._dataContainer.sheets[val.sheetIndex];
            if (this._isUndo) {
                for (var i = 0, len = val.wrapColl.length; i < len; i++)
                    this.setWrapText("wrap", [val.wrapColl[i].rowIdx, val.wrapColl[i].colIdx, val.wrapColl[i].rowIdx, val.wrapColl[i].colIdx]);
                for (var i = 0, len = val.mergeColl.length; i < len; i++) {
                    this.mergeCenter = val.mergeColl[i].mergeObj.isCenterAlign;
                    this.mergeCells(val.mergeColl[i].mergeObj.mRange, true);
                }
                this.updateData($.extend(true, [], val.bData), val.range, val.reqType);
            }
            else {
                if (this.XLRibbon._isMergeSelect && this.XLRibbon._isFilterSelect.status) {
                    this.clearRangeData(val.range, ["decimalPlaces", "thousandSeparator", "hyperlink", "cFormatRule"], "", false, details.reqType);
                    this.XLFormat.removeStyle(null, { cellStyle: true, format: true })
                }
                else
                    this.clearRangeData(val.range, ["format", "formats", "border", "type", "formatstr", "decimalPlaces", "thousandSeparator", "hyperlink", "cFormatRule"], "", false, val.reqType);
                this.setWrapText("unwrap", val.range);
                this.unmergeCells(val.range);
            }
            if (this.model.allowConditionalFormats)
                this.XLCFormat.refreshCFormat(val.range);
        },

        _undoForCLLink: function (val) {
            var startCell = { rowIndex: val.selectedCell[0].rowIndex, colIndex: val.selectedCell[0].colIndex }, temp, currentCell,
            endCell = { rowIndex: val.selectedCell[val.selectedCell.length - 1].rowIndex, colIndex: val.selectedCell[val.selectedCell.length - 1].colIndex };
            this.setActiveCell(val.selectedCell[0].rowIndex, val.selectedCell[0].colIndex);
            this.XLSelection.selectRange(startCell, endCell);
            if (this._isUndo) {
                for (var i = 0, len = val.selectedCell.length; i < len; i++) {
                    if (val.selectedCell[i].prevLink) {
                        currentCell = this.getCell(val.selectedCell[i].rowIndex, val.selectedCell[i].colIndex);
                        (!(val.selectedCell[i].prevLink.webAddr) ? currentCell.html(ej.buildTag("a.e-hyperlinks", val.selectedCell[i].prevText, "")) : currentCell.html(ej.buildTag("a.e-hyperlinks", val.selectedCell[i].prevText, "", { href: val.selectedCell[i].prevLink.webAddr, target: "_blank" })));
                        (this.isUndefined(val.selectedCell[i].prevLink.cellAddr)) ? this.XLEdit._updateDataContainer({ rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex }, { dataObj: { hyperlink: { "webAddr": val.selectedCell[i].prevLink.webAddr } } }) : this.XLEdit._updateDataContainer({ rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex }, { dataObj: { hyperlink: { "cellAddr": val.selectedCell[i].prevLink.cellAddr } } });
                    }
                }
            }
            else
                this._removeHyperlink("clear", val.selectedCell);
            this.XLSelection.selectRange(startCell, endCell);
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
            for (var i = 0, len = val.selectedCell.length; i < len; i++) {
                temp = val.selectedCell[i].prevLink;
                val.selectedCell[i].prevLink = val.selectedCell[i].curLink;
                val.selectedCell[i].curLink = temp;
            }
        },

        _undoForComment: function (val) {
            var cell, startCell, endCell, cmnt;
            startCell = { rowIndex: val.selectedCell[0].rowIndex, colIndex: val.selectedCell[0].colIndex };
            endCell = { rowIndex: val.selectedCell[val.selectedCell.length - 1].rowIndex, colIndex: val.selectedCell[val.selectedCell.length - 1].colIndex };
            for (var i = 0, len = val.selectedCell.length; i < len; i++) {
                cell = { rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex };
                this.XLSelection.selectRange(cell, cell);
                this.getSheet(val.sheetIndex)._startCell = cell;
                if (val.action === "add") {
                    val.selectedCell[i].prevComment = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "comment");
                    this.XLComment && this.XLComment.deleteComment();
                }
                else if (val.action === "edit") {
                    if (this._isRowViewable(val.sheetIndex, cell.rowIndex))
                        this.getCell(cell.rowIndex, cell.colIndex).find('.e-comment-txtarea').val(val.selectedCell[i].prevComment.value);
                    this.XLComment._updateCurCmntVal();
                    cmnt = val.selectedCell[i].prevComment;
                    val.selectedCell[i].prevComment = val.selectedCell[i].curComment;
                    val.selectedCell[i].curComment = cmnt;
                }
                else {
                    this.XLEdit._updateDataContainer(cell, { dataObj: { "comment": val.selectedCell[i].prevComment } });
                    this.XLComment.setComment([cell.rowIndex, cell.colIndex, cell.rowIndex, cell.colIndex], null, false);
                    this.XLSelection.selectRange(cell, cell);
                    this.XLComment._updateCurCmntVal();
                    cmnt = val.selectedCell[i].prevComment;
                    val.selectedCell[i].prevComment = val.selectedCell[i].curComment;
                    val.selectedCell[i].curComment = cmnt;
                }
            }
            if (val.action === "add")
                val.action = "delete";
            else if (val.action === "delete")
                val.action = "add";
            this.XLSelection.selectRange(startCell, endCell);
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForCondFormat: function (val) {
            var i, j, len, ln, sRule, rules, rule, totRules = [], allRules, actCell;
            val.range = val.data;
            if (this._isUndo) {
                if (val.action === "add") {
                    var selCells = this._getSelectedRange({ rowIndex: val.range[0], colIndex: val.range[1] }, { rowIndex: val.range[2], colIndex: val.range[3] });
                    rules = this.XLEdit.getPropertyValue(selCells[0].rowIndex, selCells[0].colIndex, 'cFormatRule');
                    val.poppedRule = rules[rules.length - 1];
                    for (i = 0, len = selCells.length; i < len; i++) {
                        allRules = this.XLEdit.getPropertyValue(selCells[i].rowIndex, selCells[i].colIndex, 'cFormatRule');
                        if (!this.isUndefined(allRules)) {
                            allRules.pop();
                            for (j = 0, ln = allRules.length; j < ln; j++) {
                                sRule = allRules[j];
                                if (totRules.length === 0) {
                                    rule = sRule.indexOf("true") > -1 ? sRule.replace("_true", "") : sRule.replace("_false", "");
                                    totRules.push(rule);
                                }
                                else
                                    totRules = this._addCondFormatRule(totRules, sRule);
                            }
                        }
                        if (this._isRowViewable(val.sheetIndex, selCells[i].rowIndex)) {
                            actCell = this.getCell(selCells[i].rowIndex, selCells[i].colIndex, val.sheetIndex);
                            actCell.removeClass("e-redft e-yellowft e-greenft e-redf e-redt");
                            actCell[0].style.color = "";
                            actCell[0].style.backgroundColor = "";
                            actCell.removeClass("e-cformat");
                        }
                    }
                    this.clearRangeData(val.range, ["cFormatRule"], selCells);
                    for (i = 0, len = totRules.length; i < len; i++) {
                        rule = totRules[i].split("_");
                        this.XLCFormat._cFormat(rule[0], rule[2], rule[3], rule[4], rule[5], rule[6], val.sheetIndex, val.range);
                    }
                }
                else if (val.action === "clear") {
                    for (i = 0, len = val.rule.length; i < len; i++)
                        for (var j = 0, length = val.rule[i].length; j < length; j++)
                            this.XLCFormat.setCFRule(val.rule[i][j]);
                }
            }
            else {
                if (val.action === "add") {
                    if (!ej.isNullOrUndefined(val.poppedRule)) {
                        rule = val.poppedRule.split("_");
                        this.XLCFormat._cFormat(rule[0], rule[2], rule[3], rule[4], rule[5], rule[6], val.sheetIndex, val.range);
                    }
                }
                else if (val.action === "clear") {
                    val.selection ? this.XLCFormat.clearCF(val.range) : this.XLCFormat.clearCF();
                }
            }
        },

        _getCopyText: function (text) {
            var i, j, ln, len, selText = [], splitVal;
            for (i = 0, len = text.length; i < len; i++) {
                splitVal = text[i].split("\t");
                for (j = 0, ln = splitVal.length; j < ln; j++)
                    selText.push(splitVal[j]);
            }
            return selText;
        },

        _cutShape: function (cellObj, cutCell, shapeMgr, pSheetIndex) {
            var shape = ["picture", "chart"], shapeObj;
            for (var i = 0, len = shape.length; i < len; i++) {
                if (shape[i] in cellObj) {
                    this.XLShape._picCellIdx = { rowIndex: cutCell.rowIndex, colIndex: cutCell.colIndex };
                    for (var m = 0, rLen = cellObj[shape[i]].length; m < rLen; m++) {
                        shapeObj = $.extend(true, {}, shapeMgr[shape[i]][cellObj[shape[i]][m]]);
                        this.XLShape._deleteShape(pSheetIndex, this.element.find("#" + shapeObj.id));
                    }
                }
            }
        },

        _pasteShape: function (cellObj, pasteCell, shapeMgr, pSheetIdx) {
            var shape = ["picture", "chart"], shapeObj, range, repStr;
            for (var i = 0, len = shape.length; i < len; i++) {
                if (shape[i] in cellObj) {
                    for (var m = 0, rLen = cellObj.picture.length; m < rLen; m++) {
                        shapeObj = $.extend(true, {}, shapeMgr[shape[i]][cellObj[shape[i]][m]]);
                        !(this.XLChart._shapeCnt === 1) && this.XLChart._shapeCnt--;
                        if (shape[i] === "picture") {
                            repStr = this._id + "_picture";
                            this.XLShape._createPicture(pSheetIdx, { rowIndex: pasteCell.rowIndex, colIndex: pasteCell.colIndex }, shapeMgr.sharedPics[shapeObj.data], shapeObj.top, shapeObj.left, shapeObj.width, shapeObj.height, parseInt(shapeObj.id.replace(repStr, "")));
                        }
                        else {
                            range = shapeObj.range;
                            this.XLChart.createChart(this._getAlphaRange(pSheetIdx, range[0], range[1], range[2], range[3]), shapeObj);
                        }
                    }
                    (shape[i] === "chart") && this.XLSelection.selectRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] }, pSheetIndex);
                }
            }
        },

        _undoForCopyPaste: function (val) {
            var shapeObj = {}, container = this._dataContainer, type, shapeIdx, shapeMgr = this.getSheet(val.pSheetIndex).shapeMngr, cellObj, m, rLen;
            if (val.operation === "shape") {
                type = val.pShapeId.indexOf("picture") > -1 ? "picture" : "chart";
                cellObj = $.extend(true, {}, val.pasteCell.obj);
                if (!ej.isNullOrUndefined(cellObj)) {
                    this.XLShape._picCellIdx = { rowIndex: val.pasteCell.rowIndex, colIndex: val.pasteCell.colIndex };
                    if (type === "chart") {
                        if ("chart" in cellObj) {
                            if (this._isUndo) {
                                shapeObj = $.extend(true, {}, shapeMgr.chart[val.pShapeId]);
                                if (ej.isNullOrUndefined(container.sheets[val.pSheetIndex][val.pasteCell.rowIndex]))
                                    container.sheets[val.pSheetIndex][val.pasteCell.rowIndex] = {};
                                container.sheets[val.pSheetIndex][val.pasteCell.rowIndex][val.pasteCell.colIndex] = cellObj;
                                this.XLShape._deleteShape(val.pSheetIndex, this.element.find("#" + shapeObj.id));
                            }
                            else {
                                this.setActiveCell(val.pasteCell.rowIndex, val.pasteCell.colIndex, val.pSheetIndex);
                                shapeObj = $.extend(true, {}, val.pasteCell.shapeObj);
                                if (shapeObj.isChartSeries) {
                                    this.XLChart.createChart(null, shapeObj);
                                }
                                else {
                                    range = shapeObj.range;
                                    this.XLChart.createChart(this._getAlphaRange(val.sheetIndex, range[0], range[1], range[2], range[3]), shapeObj);
                                    this.XLSelection.selectRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] }, val.cSheetIndex);
                                }
                            }
                        }
                    }
                    else {
                        if ("picture" in cellObj) {
                            if (this._isUndo) {
                                shapeObj = $.extend(true, {}, shapeMgr.picture[val.pShapeId]);
                                if (ej.isNullOrUndefined(container.sheets[val.pSheetIndex][val.pasteCell.rowIndex]))
                                    container.sheets[val.pSheetIndex][val.pasteCell.rowIndex] = {};
                                container.sheets[val.pSheetIndex][val.pasteCell.rowIndex][val.pasteCell.colIndex] = cellObj;
                                this.XLShape._deleteShape(val.pSheetIndex, this.element.find("#" + shapeObj.id));
                            }
                            else {
                                shapeObj = $.extend(true, {}, val.pasteCell.shapeObj);
                                repStr = this._id + "_picture";
                                this.XLShape._createPicture(val.pSheetIndex, { rowIndex: val.pasteCell.rowIndex, colIndex: val.pasteCell.colIndex }, shapeMgr.sharedPics[shapeObj.data], shapeObj.top, shapeObj.left, shapeObj.width, shapeObj.height, parseInt(shapeObj.id.replace(repStr, "")), shapeObj.bcolor, shapeObj.bstyle, shapeObj.bwidth);
                            }
                        }
                    }
                }
                this.XLScroll._getRowHeights(val.pSheetIndex, val.pasteCell.rowIndex);
            }
            else {
                var i, j, m, ln, len, rLen, cell, addr, pObj, nBrdr, range, rowIdx, colIdx, repStr, overflow, settings, pasteCell, isViewed = false, selTxt = [], container = this._dataContainer, cellInfo;
                this._getCopyText(val.text);
                this._dupDetails = true;
                this.element.find(".e-cdata").length && $('td.e-cutright, td.e-cutbottom').removeClass('e-cutright e-cutbottom');
                this.setActiveSheetIndex(val.pSheetIndex);
                for (i = 0, len = val.pasteCells.length; i < len; i++) {
                    pasteCell = val.pasteCells[i];
                    cellObj = ej.isNullOrUndefined(container.sheets[val.pSheetIndex][pasteCell.rowIndex]) ? {} : container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex];
                    if (!this._isUndo) {
                        if ("merge" in pasteCell.prevObj) {
                            this.mergeCenter = pasteCell.prevObj.merge.isCenterAlign;
                            this.mergeCells(pasteCell.prevObj.merge.mRange, true);
                        }
                    }
                    if (this._isRowViewable(val.pSheetIndex, pasteCell.rowIndex)) {
                        cell = this.getCell(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex)[0];
                        if (!this._isUndo) {
                            if (cellObj && !cellObj.selIdxChange) {
                                cell.textContent = selTxt[i];
                                this._removeClass(cell, "e-cellreadonly");
                            }
                        }

                        isViewed = true;
                    }
                    if (!ej.isNullOrUndefined(cellObj)) {
                        this._cutShape(cellObj, pasteCell, shapeMgr, val.pSheetIndex);
                        addr = this._generateHeaderText(pasteCell.colIndex + 1) + (pasteCell.rowIndex + 1);
                        ("wrap" in cellObj) && this.setWrapText("unwrap", addr + ":" + addr);
						if(this.model.allowSparkline) {
							if("sparkline" in cellObj) {
								this.XLSparkline._removeSparklineElem(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex);
								sparklineId = this.XLEdit.getPropertyValue(pasteCell.rowIndex, pasteCell.colIndex, "sparkline", val.pSheetIndex);
								pasteCell.newSparklineProp = $.extend(true, {}, this.getSheet(val.pSheetIndex).shapeMngr.sparkline[sparklineId]);
							}
						}
                        if ("merge" in cellObj) {
                            if (this._isUndo) {
                                pasteCell.newObj = $.extend(true, {}, container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex]);
                                this.unmergeCells(this._getAlphaRange(val.pSheetIndex, pasteCell.rowIndex, pasteCell.colIndex, pasteCell.rowIndex, pasteCell.colIndex));
                                this.getCell(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex).prop("rowspan", 1).prop("colspan", 1);
                                if ("merge" in pasteCell.prevObj) {
                                    this.mergeCenter = pasteCell.prevObj.merge.isCenterAlign;
                                    this.mergeCells(pasteCell.prevObj.merge.mRange, true);
                                    this.mergeCenter = false;
                                }
                            }
                        }						
                    }
                    if (isViewed && this._isUndo) {
                        !("cellType" in cellObj) && (cell.textContent = "");
                        this._removeClass(cell, 'e-commentcell');
                    }
                    ej.isNullOrUndefined(container.sheets[val.pSheetIndex][pasteCell.rowIndex]) && (container.sheets[val.pSheetIndex][pasteCell.rowIndex] = {});
                    !ej.isNullOrUndefined(container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex]) && (overflow = container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex]['overflow']);
                    if (this.model.allowCellFormatting)
                        this.XLFormat.removeStyle(val.pasteBorder.range, { cellStyle: true, tableStyle: true, format: true, border: true });
                    container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex] = $.extend(true, {}, pasteCell.prevObj);
                    (overflow) && (container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex]['overflow'] = overflow);
                    this._textClip(pasteCell.rowIndex, pasteCell.colIndex, 'delete');
                    this._setRowHdrHeight(val.pSheetIndex, pasteCell.rowIndex);
                    cellObj = !ej.isNullOrUndefined(container.sheets[val.pSheetIndex][pasteCell.rowIndex]) ? container.sheets[val.pSheetIndex][pasteCell.rowIndex][pasteCell.colIndex] : {};
                    rowIdx = pasteCell.rowIndex; colIdx = pasteCell.colIndex;
                    this._applyCommentLink(cellObj, { rowIndex: pasteCell.rowIndex, colIndex: pasteCell.colIndex }, rowIdx, colIdx);
                    this._isPaste = true;
                    if (!ej.isNullOrUndefined(cellObj)) {
                        this._pasteShape(cellObj, { rowIndex: rowIdx, colIndex: colIdx }, shapeMgr, val.pSheetIndex);
                        if ('cellType' in cellObj) {
                            if (this._isUndo) {
                                this._removeClass(cell, 'e-cellreadonly');
                                if (cellObj.cTypeObj && this.model.allowCellType) {
                                    settings = this._dataContainer.sheetCellType[cellObj['cellType']];
                                    settings.text = '';
                                    settings.dataSource && (settings.field = "text");
                                }
                                    this.XLCellType._renderControls(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex, settings, true);
                            }
                            else {
                                settings = this._dataContainer.sheetCellType[cellObj['cellType']];
                                settings.text = '';
                                this.model.allowCellType && this.XLCellType._renderControls(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex, settings, true);
                            }
                        }
						if (this.model.allowSparkline && 'sparkline' in cellObj) {
							this.getSheet(val.pSheetIndex).shapeMngr.sparkline[cellObj['sparkline'][0]] = pasteCell.prevSparklineProp;
							if(this._isRowViewable(val.cSheetIndex, pasteCell.rowIndex)) {
								if(!this._getContent(val.cSheetIndex).find("#" + pasteSparkleneId).length) {
									cellInfo = this._getCellInfo({ rowIndex: pasteCell.rowIndex, colIndex: pasteCell.colIndex }, val.cSheetIndex)
									this.XLSparkline._createSparkline(pasteCell.prevSparklineProp, cellInfo, val.pSheetIndex);
								}
							}
						}
                        addr = this._generateHeaderText(pasteCell.colIndex + 1) + (pasteCell.rowIndex + 1);
                        if ("wrap" in cellObj){
							this.XLEdit._clearDataContainer({ cellIdx: pasteCell, property: ['wrap']});
							this.setWrapText("wrap", addr + ":" + addr);
						}
                        this._isPaste = false;
                    }
                    pObj = pasteCell.prevObj;
                    pasteCell.prevObj = pasteCell.newObj;
                    pasteCell.newObj = pObj;
					prevSparkObj = pasteCell.prevSparklineProp;
                    pasteCell.prevSparklineProp = pasteCell.newSparklineProp;
                    pasteCell.newSparklineProp = prevSparkObj;
                }
                if (val.isSpecial) {
                    if (this.model.allowCellFormatting) {
                        this.XLFormat.removeStyle(val.pasteBorder.range, { cellStyle: true, tableStyle: true, format: true });
                        !this.isUndefined(val.pasteBorder.prevBorder) && this.XLFormat.updateFormat(val.pasteBorder.prevBorder, val.pasteBorder.range, "format"); //commented due to border issues
                    }
                    var nBrdr = val.pasteBorder.prevBorder;
                    val.pasteBorder.prevBorder = val.pasteBorder.newBorder;
                    val.pasteBorder.newBorder = nBrdr;
                }
                //table and filter
                if (!ej.isNullOrUndefined(val.pfat)) {
                    var tab = val.pfat.ptable;
                    for (var m = 0, rLen = tab.length; m < rLen; m++) {
                        if (!ej.isNullOrUndefined(val.pSheetIndex)) {
                            this.setActiveSheetIndex(val.pSheetIndex);
                            if (this._isUndo) {
                                this.XLFormat.removeTable(tab[m].id);
                                this.XLFormat.removeStyle(tab[m].range);
                            }
                            else {
                                tab[m].header = true;
                                this.XLFormat.createTable(tab[m], tab[m].range);
                            }
                        }
                    }
                }
                if (!ej.isNullOrUndefined(val.filter)) {
                    this.XLFilter.clearFilter();
                    this.XLFilter.filter(details.filter);
                }
                this._dupDetails = false;
            }
            if (val.operation !== "shape") {
                if (this._isUndo) {
                    (!ej.isNullOrUndefined(val.cSheetIndex)) && this.setActiveSheetIndex(val.cSheetIndex);
                    (val.cutCells.length > 0) && this.XLSelection._focusBorder(val.cutCells[0], val.cutCells[val.cutCells.length - 1], this._cutFocus);
                    this.setActiveSheetIndex(val.pSheetIndex);
                    this.XLSelection.selectRange(val.pasteCells[0], val.pasteCells[val.pasteCells.length - 1]);
                }
                else {
                    (!ej.isNullOrUndefined(val.cSheetIndex)) && this.setActiveSheetIndex(val.cSheetIndex);
                    (val.cutCells.length > 0) && this.XLSelection._focusBorder(val.cutCells[0], val.cutCells[val.cutCells.length - 1], this._cutFocus);
                    this.setActiveSheetIndex(val.pSheetIndex);
                    (val.pasteCells.length > 0) && this.XLSelection.selectRange(val.pasteCells[0], val.pasteCells[val.pasteCells.length - 1]);

                }
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
                this.XLScroll._getRowHeights(val.pSheetIndex, val.pasteCells[0].rowIndex);
            }

        },

        _undoForCutPaste: function (val) {
            var cellObj, overflow, m, rLen, nBrdr, shapeObj = {}, container = this._dataContainer, shapeMgr = this.getSheet(val.pSheetIndex).shapeMngr, repStr, cell, cellwrap, cname;
            if (val.operation === "shape") {
                var type, shapeIdx;
                type = val.pShapeId.indexOf("picture") > -1 ? "picture" : "chart";
                cellObj = $.extend(true, {}, val.pasteCell.obj);
                if (!ej.isNullOrUndefined(cellObj)) {
                    this.XLShape._picCellIdx = { rowIndex: val.pasteCell.rowIndex, colIndex: val.pasteCell.colIndex };
                    shapeObj = $.extend(true, {}, shapeMgr[type][val.pShapeId]);
                    if (ej.isNullOrUndefined(container.sheets[val.pSheetIndex][val.pasteCell.rowIndex]))
                        container.sheets[val.pSheetIndex][val.pasteCell.rowIndex] = {};
                    container.sheets[val.pSheetIndex][val.pasteCell.rowIndex][val.pasteCell.colIndex] = cellObj;
                    this.XLShape._deleteShape(val.pSheetIndex, this.element.find("#" + shapeObj.id));
                }
                cellObj = $.extend(true, {}, val.cutCell.obj);
                type = val.cShapeId.indexOf("picture") > -1 ? "picture" : "chart";
                if (!ej.isNullOrUndefined(cellObj)) {
                    this.setActiveCell(val.cutCell.rowIndex, val.cutCell.colIndex, val.cSheetIndex);
                    if (type === "chart") {
                        if ("chart" in cellObj) {
                            shapeObj = $.extend(true, {}, val.cutCell.shapeObj);
                            range = shapeObj.range;
                            this.setActiveSheetIndex(val.cSheetIndex);
                            this.XLChart.createChart(shapeObj.isChartSeries ? null : this._getAlphaRange(val.sheetIndex, range[0], range[1], range[2], range[3]), shapeObj);
                            this.setActiveSheetIndex(val.sheetIndex);
                            if(!shapeObj.isChartSeries)
                                this.XLSelection.selectRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] }, val.cSheetIndex);
                        }
                    }
                    else {
                        if ("picture" in cellObj) {
                            shapeObj = $.extend(true, {}, val.cutCell.shapeObj);
                            repStr = this._id + "_picture";
                            this.XLShape._createPicture(val.cSheetIndex, { rowIndex: val.cutCell.rowIndex, colIndex: val.cutCell.colIndex }, shapeMgr.sharedPics[shapeObj.data], shapeObj.top, shapeObj.left, shapeObj.width, shapeObj.height, parseInt(shapeObj.id.replace(repStr, "")), shapeObj.bcolor, shapeObj.bstyle, shapeObj.bwidth);
                        }
                    }
                }
                this.XLShape._picCellIdx = { rowIndex: val.cutCell.rowIndex, colIndex: val.cutCell.colIndex };
                var pasteCell = val.pasteCell;
                val.pasteCell = val.cutCell;
                val.cutCell = pasteCell;
                var pShapeId = val.pShapeId;
                val.pShapeId = val.cShapeId;
                val.cShapeId = pShapeId;

            }
            else {
                var i, j, ln, len, pObj, addr, range, cell, cutCel, rowIdx, colIdx, curCell, selTxt = [], settings, container = this._dataContainer, cellInfo, sparklineId;
                this.element.find(".e-cdata").length && $('td.e-cutright, td.e-cutbottom').removeClass('e-cutright e-cutbottom');
                this._getCopyText(val.text);
                for (i = 0, len = val.pasteCells.length; i < len; i++) {
                    if (!ej.isNullOrUndefined(val.pSheetIndex)) {
                        if (!this.isUndefined(container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex]))
                            cellObj = container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex];
                        addr = this._generateHeaderText(val.pasteCells[i].colIndex + 1) + (val.pasteCells[i].rowIndex + 1);
                        ('wrap' in cellObj) && this.setWrapText("unwrap", addr + ":" + addr);
                        if (this._isRowViewable(val.pSheetIndex, val.pasteCells[i].rowIndex)) {
                            cell = this.getCell(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, val.pSheetIndex)[0];
							if(this.model.allowSparkline && 'sparkline' in cellObj) {
								this.XLSparkline._removeSparklineElem(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, val.pSheetIndex);
								sparklineId = this.XLEdit.getPropertyValue(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, "sparkline", val.pSheetIndex);
								val.pasteCells[i].newSparklineProp = $.extend(true, {}, this.getSheet(val.pSheetIndex).shapeMngr.sparkline[sparklineId]);
							}
							cell.textContent = "";
                            this._removeClass(cell, 'e-commentcell');
                        }
                        if (!this.isUndefined(cellObj)) {
                            this._cutShape(cellObj, val.pasteCells[i], shapeMgr, val.pSheetIndex);
                            if ("merge" in cellObj) {
                                if (this._isUndo) {
                                    $.extend(true, val.pasteCells[i].newObj, container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex]);
                                    this.setActiveSheetIndex(val.pSheetIndex);
                                    this.unmergeCells(cellObj.merge.mRange);
                                    this.getCell(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, val.pSheetIndex).prop("rowspan", 1).prop("colspan", 1);
                                    if ("merge" in val.pasteCells[i].prevObj) {
                                        this.mergeCenter = val.pasteCells[i].prevObj.merge.isCenterAlign;
                                        this.mergeCells(val.pasteCells[i].prevObj.merge.mRange, true);
                                        this.mergeCenter = false;
                                    }
                                }
                                else {
                                    this.setActiveSheetIndex(val.pSheetIndex);
                                    this.unmergeCells(cellObj.merge.mRange, true);
                                    if ("merge" in val.pasteCells[i].prevObj) {
                                        this.mergeCenter = val.pasteCells[i].prevObj.merge.isCenterAlign;
                                        this.mergeCells(val.pasteCells[i].prevObj.merge.mRange, true);
                                        this.mergeCenter = false;
                                    }
                                    this.setActiveSheetIndex(val.cSheetIndex);
                                    this.unmergeCells(this._getAlphaRange(val.pSheetIndex, val.cutCells[i].rowIndex, val.cutCells[i].colIndex, val.cutCells[i].rowIndex, val.cutCells[i].colIndex));
                                    range = this.getRangeIndices(val.cutCells[i].prevObj.merge.mRange);
                                    this.XLSelection.selectRange({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] }, val.sheetIndex);
                                }
                            }
                            if ('cellType' in cellObj) {
                                this._removeClass(cell, 'e-cellreadonly');
                                if (cellObj.cTypeObj && this.model.allowCellType) {
                                    settings = this._dataContainer.sheetCellType[cellObj['cellType']];
                                    settings.text = '';
                                    settings.dataSource && (settings.field = "text");
                                }
                                this.XLCellType._renderControls(pasteCell.rowIndex, pasteCell.colIndex, val.pSheetIndex, settings, true);
                            }
                        }
                        if (this.isUndefined(container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex]))
                            container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex] = {};
                        !ej.isNullOrUndefined(container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex]) && (overflow = container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex]['overflow']);
                        if (this.model.allowCellFormatting)
                            this.XLFormat.removeStyle(val.pasteBorder.range, { cellStyle: true, tableStyle: true, format: true, border: true });
                        if (container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex].wrap)
                            cellwrap = true;
                        cname = this.XLEdit.getPropertyValue(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, "tableName") || "";
                        container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex] = $.extend(true, {}, val.pasteCells[i].prevObj);
                        this._textClip(val.pasteCells[i].rowIndex, val.pasteCells[i].colIndex, 'delete');
                        if (!this.isUndefined(container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex])) {
                            (overflow) && (container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex]['overflow'] = overflow);
                            this._setRowHdrHeight(val.pSheetIndex, val.pasteCells[i].rowIndex);
                            cellObj = container.sheets[val.pSheetIndex][val.pasteCells[i].rowIndex][val.pasteCells[i].colIndex];
                            rowIdx = val.pasteCells[i].rowIndex, colIdx = val.pasteCells[i].colIndex;
                            this._applyCommentLink(cellObj, { rowIndex: rowIdx, colIndex: colIdx }, rowIdx, colIdx);
                            (cellwrap) && (cellObj.wrap = cellwrap);
                            this._isPaste = true;
                            if (!ej.isNullOrUndefined(cellObj)) {
                                this._pasteShape(cellObj, { rowIndex: rowIdx, colIndex: colIdx }, shapeMgr, val.pSheetIndex, val.sheetIndex);
                                addr = this._generateHeaderText(colIdx + 1) + (rowIdx + 1);
                                if ("wrap" in cellObj){
									this.XLEdit._clearDataContainer({ cellIdx: val.pasteCells[i], property: ['wrap']});
									this.setWrapText("wrap", addr + ":" + addr);
								}
                            }
                        }
                        pObj = val.pasteCells[i].prevObj;
                        val.pasteCells[i].prevObj = val.pasteCells[i].newObj;
                        val.pasteCells[i].newObj = pObj;
						prevSparkObj = val.pasteCells[i].prevSparklineProp;
                        val.pasteCells[i].prevSparklineProp = val.pasteCells[i].newSparklineProp;
                        val.pasteCells[i].newSparklineProp = prevSparkObj;						
                        this._isPaste = false;
                    }
                }
				var prevSparkObj;
                for (var i = 0; i < val.cutCells.length; i++) {
                    if (!ej.isNullOrUndefined(val.cSheetIndex)) {
                        cutCel = val.cutCells[i];
                        if (this._isRowViewable(val.cSheetIndex, cutCel.rowIndex)) {
                            curCell = this.getCell(cutCel.rowIndex, cutCel.colIndex, val.cSheetIndex)[0];
                            curCell.textContent = selTxt[i];
                        }
                        this.setActiveSheetIndex(val.cSheetIndex);
                        cellObj = ej.isNullOrUndefined(container.sheets[val.cSheetIndex][cutCel.rowIndex]) ? {} : container.sheets[val.cSheetIndex][cutCel.rowIndex][cutCel.colIndex];
                        if (!ej.isNullOrUndefined(cellObj))
                            this._cutShape(cellObj, cutCel, shapeMgr, val.cSheetIndex);
                        (ej.isNullOrUndefined(container.sheets[val.cSheetIndex][cutCel.rowIndex])) && (container.sheets[val.cSheetIndex][cutCel.rowIndex] = {});
                        !ej.isNullOrUndefined(container.sheets[val.cSheetIndex][cutCel.rowIndex][cutCel.colIndex]) && (overflow = container.sheets[val.cSheetIndex][cutCel.rowIndex][cutCel.colIndex]['overflow']);
                        (cutCel.prevObj.tableName) && delete cutCel.prevObj.tableName;
                        container.sheets[val.cSheetIndex][cutCel.rowIndex][cutCel.colIndex] = $.extend(true, {}, cutCel.prevObj);
                        if (this.getObjectLength(overflow) > 0)
                            (container.sheets[val.cSheetIndex][cutCel.rowIndex][cutCel.colIndex]['overflow'] = overflow) && (overflow = {});
                        pObj = cutCel.prevObj;
                        cutCel.prevObj = cutCel.newObj;
                        cutCel.newObj = pObj;
						prevSparkObj = cutCel.prevSparklineProp;
						cutCel.prevSparklineProp = cutCel.newSparklineProp;
						cutCel.newSparklineProp = prevSparkObj;
                        rowIdx = cutCel.rowIndex; colIdx = cutCel.colIndex;
                        this._setRowHdrHeight(val.cSheetIndex, rowIdx);
                        this.XLScroll._getRowHeights(val.cSheetIndex, rowIdx);
                        cellObj = ej.isNullOrUndefined(container.sheets[val.cSheetIndex][rowIdx]) ? {} : container.sheets[val.cSheetIndex][rowIdx][colIdx];
                        this._applyCommentLink(cellObj, { rowIndex: rowIdx, colIndex: colIdx }, rowIdx, colIdx);
                        this._isPaste = true;
                        if (!ej.isNullOrUndefined(cellObj)) {
                            this._pasteShape(cellObj, { rowIndex: rowIdx, colIndex: colIdx }, shapeMgr, val.cSheetIndex);
                            if ("merge" in cellObj) {
                                this.mergeCenter = cellObj.merge.isCenterAlign;
                                this.mergeCells(cellObj.merge.mRange, true);
                                this.mergeCenter = false;
                            }
                            if ('cellType' in cellObj) {
                                settings = this._dataContainer.sheetCellType[cellObj['cellType']];
                                settings.text = '';
                                this.model.allowCellType && this.XLCellType._renderControls(cutCel.rowIndex, cutCel.colIndex, val.pSheetIndex, settings, true);
                            }
							if (this.model.allowSparkline && 'sparkline' in cellObj) {
								this.getSheet(val.pSheetIndex).shapeMngr.sparkline[cellObj['sparkline'][0]] = cutCel.newSparklineProp;
								if(this._isRowViewable(val.cSheetIndex, cutCel.rowIndex)) {
									if(!this._getContent(val.cSheetIndex).find("#" + pasteSparkleneId).length)
										this.XLSparkline._refreshSparklineClipboard(cutCel.rowIndex, cutCel.colIndex, val.pSheetIndex, val.cSheetIndex, true);
								}
							}
                            this._dupDetails = true;
                            addr = this._generateHeaderText(cutCel.colIndex + 1) + (cutCel.rowIndex + 1);
                            if ("wrap" in cellObj){
								this.XLEdit._clearDataContainer({ cellIdx: cutCel, property: ['wrap']});
								this.setWrapText("wrap", addr + ":" + addr);
							}
                            this._dupDetails = false;
                        }
                        this._isPaste = false;
                    }
                }
                this.XLScroll._getRowHeights(val.pSheetIndex, (val.pasteCells[0].rowIndex < val.cutCells[0].rowIndex) ? val.pasteCells[0].rowIndex : val.cutCells[0].rowIndex);
                if (this.model.allowCellFormatting && !ej.isNullOrUndefined(val.pSheetIndex)) {
                    this.setActiveSheetIndex(val.pSheetIndex);
                    this.XLFormat.removeStyle(val.pasteBorder.range, { cellStyle: true, tableStyle: true, format: true });
                    !this.isUndefined(val.pasteBorder.prevBorder) && this.XLFormat.updateFormat(val.pasteBorder.prevBorder, val.pasteBorder.range, "format");      //commented due to border issues
                }
                nBrdr = val.pasteBorder.prevBorder;
                val.pasteBorder.prevBorder = val.pasteBorder.newBorder;
                val.pasteBorder.newBorder = nBrdr;
                if (this.model.allowCellFormatting && !ej.isNullOrUndefined(val.cSheetIndex)) {
                    this.setActiveSheetIndex(val.cSheetIndex);
                    if (val.isSpecial)
                        this.XLFormat.removeStyle(val.cutBorder.range, { cellStyle: true, tableStyle: true, format: true });
                    if (val.cutBorder.prevBorder)
                        this.XLFormat.updateFormat(val.cutBorder.prevBorder, val.cutBorder.range, "format");
                }
                nBrdr = val.cutBorder.prevBorder;
                val.cutBorder.prevBorder = val.cutBorder.newBorder;
                val.cutBorder.newBorder = nBrdr;

                //table and filter
                if (!ej.isNullOrUndefined(val.pfat)) {
                    var rng, tab = val.pfat.table, tblRange, minRowIdx = val.pfat.minRowIdx, minColIdx = val.pfat.minColIdx, tblId, prange = val.pfat.range;
                    for (var m = 0, rLen = tab.length; m < rLen; m++) {
                        tblRange = tab[m].range;
                        if (!ej.isNullOrUndefined(val.pSheetIndex)) {
                            this.setActiveSheetIndex(val.pSheetIndex);
                            tblId = tab[m].tblObj.tblId;
                            rng = val.pfat.ptable[m].range;
                            this.XLFormat.removeTable(tblId);
                            this.XLFormat.removeStyle(rng);
                        }
                        if (!ej.isNullOrUndefined(val.cSheetIndex)) {
                            this.setActiveSheetIndex(val.cSheetIndex);
                            this.XLClipboard._isCut = true;
                            if (this._isUndo) {
                                this.XLFormat.createTable(tab[m].tblObj, tab[m].range);
                                tab[m].tblObj.totalRow && this.XLFormat._updateTotalRow(val.sheetIndex, tblId, tab[m].tblObj.fnNumber, tab[m].range, true);
                            }
                            else {
                                rng = this.getRangeIndices(this._getAlphaRange(val.cSheetIndex, tblRange[0] + minRowIdx - prange[0], tblRange[1] + minColIdx - prange[1], minRowIdx - prange[0] + tblRange[2], minColIdx - prange[1] + tblRange[3]));
                                this.XLFormat.createTable(tab[m].tblObj, rng);
                                tab[m].tblObj.totalRow && this.XLFormat._updateTotalRow(val.sheetIndex, tblId, tab[m].tblObj.fnNumber, rng, true);
                            }
                            this.XLClipboard._isCut = false;
                        }
                    }
                }
                if (!ej.isNullOrUndefined(val.filter)) {
                    this.XLFilter.clearFilter();
                    this.XLFilter.filter(details.filter);
                }
            }
            if (val.operation !== "shape") {
                if (this._isUndo) {
                    if (!ej.isNullOrUndefined(val.cSheetIndex)) {
                        this.setActiveSheetIndex(val.cSheetIndex);
                        this.XLSelection.selectRange(val.cutCells[0], val.cutCells[val.cutCells.length - 1]);
                    }
                    if (!ej.isNullOrUndefined(val.pSheetIndex)) {
                        this.setActiveSheetIndex(val.pSheetIndex);
                        this.XLSelection.selectRange(val.pasteCells[0], val.pasteCells[val.pasteCells.length - 1]);
                    }
                }
                else {
                    if (!ej.isNullOrUndefined(val.pSheetIndex)) {
                        this.setActiveSheetIndex(val.pSheetIndex);
                        this.XLSelection._focusBorder(val.pasteCells[0], val.pasteCells[val.pasteCells.length - 1], this._cutFocus);
                        this.XLSelection.selectRange(val.pasteCells[0], val.pasteCells[val.pasteCells.length - 1]);
                    }
                    if (!ej.isNullOrUndefined(val.cSheetIndex)) {
                        this.setActiveSheetIndex(val.cSheetIndex);
                        this.XLSelection.selectRange(val.cutCells[0], val.cutCells[val.cutCells.length - 1]);
                    }
                }
            }
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
            var pasteCells = val.pasteCells;
            val.pasteCells = val.cutCells;
            val.cutCells = pasteCells;
            var pasteBorder = val.pasteBorder;
            val.pasteBorder = val.cutBorder;
            val.cutBorder = pasteBorder;
            var tempIdx = val.cSheetIndex;
            val.cSheetIndex = val.pSheetIndex;
            val.pSheetIndex = tempIdx;
        },

        _undoForDel: function (val) {
            this._delCells = $.extend(true, [], val.delCells);
            this._deletedText = $.extend(true, [], val.text);
            this._removeMergeColl = $.extend(true, [], val.removeMerge);
            this._deletedDimension = $.extend(true, [], val.deletedDimension);
            if (this._isUndo) {
                this._fRow.fRowCnt = val.fRow.fRowCnt;
                this._fCol.fColCnt = val.fCol.fColCnt;
                this._fRow.rowAdj = val.fRow.rowAdj;
                this._fCol.colAdj = val.fCol.colAdj;
            }
            switch (val.action) {
                case "deleteShiftUp":
                    this.deleteShiftUp(val.startCell, val.endCell);
                    break;
                case "deleteShiftLeft":
                    this.deleteShiftLeft(val.startCell, val.endCell);
                    break;
                case "deleteRow":
                    this.deleteEntireRow(val.startCell.rowIndex, val.endCell.rowIndex);
                    break;
                case "deleteColumn":
                    this.deleteEntireColumn(val.startCell.colIndex, val.endCell.colIndex);
                    break;
            }
        },

        _undoForEdit: function (val) {
            var i, hLink, curVal, fObj, temp, cFormatStr, len, cFormatRule = val.cFormatRule, selCell = { rowIndex: val.rowIndex, colIndex: val.colIndex }, cmnt, cell, textDecoration, rows = this.getRows(val.sheetIndex);
            this.setActiveCell(val.rowIndex, val.colIndex, val.sheetIndex);
            this.XLSelection.selectRange(val.startCell, val.endCell);
            if (this._isRowViewable(val.sheetIndex, val.rowIndex)) {
                cell = this.getCell(val.rowIndex, val.colIndex);
                textDecoration = cell.find("a").css("text-decoration");
                if (val.altwrap)
                    if (this._isUndo){
						this.XLEdit._clearDataContainer({ cellIdx: selCell, property: ["altTxt"] });
						this.unWrapText([val.rowIndex, val.colIndex, val.rowIndex, val.colIndex]);
					}
					else {
						this.XLEdit._updateDataContainer(selCell, { dataObj: { altTxt: true } });
						this.wrapText([val.rowIndex, val.colIndex, val.rowIndex, val.colIndex]);
					}
            }
            hLink = this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "hyperlink", val.sheetIndex);
            if (!ej.isNullOrUndefined(hLink)) {
                curVal = this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "value2");
                val.action = (curVal.length < 1) ? "add" : "delete";
                val.reqType = "edit";
                selCell.prevLink = hLink;
                selCell.prevText = curVal;
                val.selectedCell = [];
            }
            cmnt = this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "comment");
            this.XLEdit._updateCellValue({ rowIndex: val.rowIndex, colIndex: val.colIndex }, val.pValue);
            this._dupDetails = true;
            if (cFormatRule && cFormatRule.length) {
                for (i = 0, len = cFormatRule.length; i < len; i++) {
                    cFormatStr = cFormatRule[i].split("_");
                    this.XLCFormat._cFormat(cFormatStr[0], cFormatStr[2], cFormatStr[3], cFormatStr[4], cFormatStr[5], cFormatStr[6]);
                }
                this.XLCFormat.refreshCFormat(this._getAlphaRange(val.sheetIndex, val.rowIndex, val.colIndex, val.rowIndex, val.colIndex));
            }
            if (val.prevFrmtObj && val.curFrmtObj) {
                fObj = this._isUndo ? val.prevFrmtObj : val.curFrmtObj;
                this.XLFormat.format(fObj, this._getAlphaRange(val.sheetIndex, val.rowIndex, val.colIndex, val.rowIndex, val.colIndex));
            }
            this._dupDetails = false;
            this._textClip(val.rowIndex, val.colIndex, (val.pValue.length > 0) ? 'add' : 'delete');
            if (!ej.isNullOrUndefined(cmnt)) {
                this.XLEdit._updateDataContainer({ rowIndex: val.rowIndex, colIndex: val.colIndex }, { dataObj: { "comment": cmnt } });
                this.XLComment.setComment();
                this.XLComment._updateCurCmntVal();
            }
            if (this._isRowViewable(val.sheetIndex, val.rowIndex)) {
                hLink && (!(hLink.webAdr) ? cell.html(ej.buildTag("a", cell.text(), "", {"class": "e-hyperlinks" })) : cell.html(ej.buildTag("a", cell.text(), "", { href: hldata.webAdr, target: "_blank", "class": "e-hyperlinks" })));
                cell.find("a").css("text-decoration", textDecoration);
                cell.removeClass("e-commentcell");
            }
            if (!ej.isNullOrUndefined(hLink)) {
                selCell.curLink = this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "hyperlink");
                selCell.curText = this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "value2");
                val.selectedCell.push(selCell);
            }
            if (val.prevHeight != val.newHeight) {
                this.getSheet(val.sheetIndex).rowsHeightCollection[val.rowIndex] = val.prevHeight;
                if (this._isRowViewable(val.sheetIndex, val.rowIndex)) {
                    rows[0][val.rowIndex].style.height = val.prevHeight + "px";
                    rows[1][val.rowIndex].style.height = val.prevHeight + "px";
                }
                this._setRowHdrHeight(val.sheetIndex, val.rowIndex);
                this.XLScroll._getRowHeights(val.sheetIndex, val.rowIndex);
                temp = val.newHeight;
                val.newHeight = val.prevHeight;
                val.prevHeight = temp;
            }
            temp = val.cValue;
            val.cValue = val.pValue;
            val.pValue = temp;
            this.XLEdit._isEdit = false;
            temp = val.previousValue;
            val.previousValue = val.value;
            val.value = temp;
            if (this.model.allowFormulaBar)
                this.updateFormulaBar();
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForFilter: function (val) {
            var fltrChk = false, filterdCol = [], prevFltr, cell, selCells = [], i, len, fltr, rIdx, cIdx, filterCell, sheetIdx = val.sheetIndex || this.getActiveSheetIndex(), container = this._dataContainer.sheets[sheetIdx];
            if (val.operation === "filter" && val.requestType !== "filterbycell") {
                if (this._isUndo) {
                    for (i = this._undoCollection.length - 1; i >= 0 ; i--) {
                        if (this._undoCollection[i].reqType === "filter" && this._undoCollection[i].tableID === val.tableID && this._undoCollection[i].action === "filtering" && this._undoCollection[i].status !== "apply-filterIcon") {
                            if (this._undoCollection[i].rowIndex === val.rowIndex && this._undoCollection[i].colIndex === val.colIndex) {
                                delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                                prevFltr = this._undoCollection[i];
                                this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, prevFltr.tableID);
                                for (i = 0, len = prevFltr.filterCollection.length; i < len; i++)
                                    filterdCol.push(prevFltr.filterCollection[i]);
                                this.model.sheets[prevFltr.sheetIndex].filterSettings.filteredColumns = filterdCol;
                                if (ej.isNullOrUndefined(this._excelFilter._predicates[prevFltr.sheetIndex][prevFltr.fieldName]))
                                    this._excelFilter._predicates[prevFltr.sheetIndex][prevFltr.fieldName] = {};
                                this._excelFilter._predicates[prevFltr.sheetIndex][prevFltr.fieldName] = prevFltr.ejpredicate;
                                this.model.sheets[prevFltr.sheetIndex]._selectedRange = prevFltr.range;
                                this.XLFilter._filterHandler(prevFltr);
                                fltr = "undo";
                                fltrChk = true;
                                break;
                            }
                        }
						if (this._undoCollection[i].reqType === "filter" && this._undoCollection[i].tableID === val.tableID && this._undoCollection[i].action === "clearfiltering") {
							delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                            prevFltr = this._undoCollection[i];
                            this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, prevFltr.tableID);
							fltrChk = true;
							break;
						}
                        if (this._undoCollection[i].requestType === "filterbycell") {
                            if (this._undoCollection[i].rowIndex === val.rowIndex && this._undoCollection[i].colIndex === val.colIndex) {
                                prevFltr = this._undoCollection[i];
                                delete this._excelFilter._predicates[prevFltr.sheetIndex][prevFltr.fieldName];
                                this.XLFilter._clearFilterColumn(prevFltr.fieldName, "", "", "Or", null, null, prevFltr.tableID);
                                $.extend(true, selCells, prevFltr.selCells);
                                this.XLFilter._filterActiveCell(prevFltr.sheetIndex, prevFltr.activeCell, selCells, prevFltr.filteredValue, prevFltr.selRange);
                                fltr = "undo";
                                fltrChk = true;
                                break;
                            }
                        }
                    }
                    if (!fltrChk) {
                        delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                        this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, val.tableID);
                    }
                }
                else {
                    filterdCol = [];
                    delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                    this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, val.tableID);
                    for (i = 0, len = val.filterCollection.length; i < len; i++)
                        filterdCol.push(val.filterCollection[i]);
                    this.model.sheets[val.sheetIndex].filterSettings.filteredColumns = filterdCol;
                    (ej.isNullOrUndefined(this._excelFilter._predicates[val.sheetIndex][val.fieldName])) && (this._excelFilter._predicates[val.sheetIndex][val.fieldName] = {});
                    this._excelFilter._predicates[val.sheetIndex][val.fieldName] = val.ejpredicate;
                    if (val.filterCollection.length)
                        this.XLFilter._filterHandler(val);
                    fltr = "redo";
                }
            }
            else {
                if (this._isUndo) {
                    if (val.operation === "apply-filter" && val.requestType !== "filterbycell") {
                        for (i = 0, len = val.filteredCells.length; i < len; i++) {
                            rIdx = val.filteredCells[i].rowIndex; cIdx = val.filteredCells[i].colIndex;
                            filterCell = this.getCell(rIdx, cIdx, val.sheetIndex);
                            filterCell.find(".e-ssfilter").remove();
                            this._removeClass(filterCell[0], "e-filterhdr");
                            this.addClass(filterCell[0], "e-wrapword");
                            (this.isNumber(filterCell.text()) || this.XLEdit._parseValue(filterCell.text(), { rowIndex: rIdx, colIndex: cIdx }).type === "datetime" || this.XLEdit._parseValue(filterCell.text(), { rowIndex: rIdx, colIndex: cIdx }).type === "currency" || this.XLEdit._parseValue(filterCell.text()).type === "percentage") && filterCell.addClass(this._rAlign);
                            delete container[rIdx][cIdx]["isFilterHeader"];
                            delete container[rIdx][cIdx]["filterState"];
                            delete container[rIdx][cIdx]["isFilterVisible"];
							if(this.XLEdit.getPropertyValue(rIdx, cIdx, "isFilterWrap"))
								this.setWrapText("wrap", this._getAlphaRange(sheetIdx, rIdx,cIdx, rIdx, cIdx));
                        }
                    }
                    if (val.requestType === "filterbycell") {
                        delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                        this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, val.tableID);
                        if (!this.isUndefined(val.filteredCells)) {
                            for (i = 0, len = val.filteredCells.length; i < len; i++) {
                                filterCell = this.getCell(val.filteredCells[i].rowIndex, val.filteredCells[i].colIndex, val.sheetIndex);
                                filterCell.find(".e-ssfiltered, .e-ssfilter").remove();
                                this._removeClass(filterCell[0], "e-filterhdr");
                                this.addClass(filterCell[0], "e-wrapword");
                                (this.isNumber(filterCell.text()) || this.XLEdit._parseValue(filterCell.text(), { rowIndex: val.filteredCells[i].rowIndex, colIndex: val.filteredCells[i].colIndex }).type === "datetime" || this.XLEdit._parseValue(filterCell.text(), { rowIndex: val.filteredCells[i].rowIndex, colIndex: val.filteredCells[i].colIndex }).type === "currency" || this.XLEdit._parseValue(filterCell.text(), { rowIndex: val.filteredCells[i].rowIndex, colIndex: val.filteredCells[i].colIndex }).type === "percentage") && filterCell.addClass(this._rAlign);
                            }
                        }
                    }
                    this.model.sheets[val.sheetIndex].filterSettings.range = "";
                    if ((val.operation === "apply-filter" && val.requestType != "filterbycell") || (val.requestType === "filterbycell" && !this.isUndefined(val.filteredCells))) {
                        var tabRange = this.model.sheets[val.sheetIndex].filterSettings.tableRange, tabIdx;
                        for (var i = 0, len = tabRange.length; i < len; i++) {
                            if (tabRange[i].tableID === val.tableID) {
                                tabIdx = i;
                                break;
                            }
                        }
                        val.filterRange = tabRange.splice(tabIdx, 1)[0];
                    }
                    if (val.operation === "remove-filter") {
                        var pCol = this._undoCollection[this._undoCollection.length - 1], sheet = this.getSheet(val.sheetIndex);
                        if (pCol.requestType === "filterbycell") {
                            $.extend(true, selCells, pCol.selCells);
                            this.XLFilter._filterActiveCell(pCol.sheetIndex, pCol.activeCell, selCells, pCol.filteredValue, pCol.selRange);
                        }
                        else {
                            var filterIcon;
                            for (i = 0, len = val.filteredCells.length; i < len; i++) {
                                filterIcon = this.XLFilter._getFilterIcon();
                                this.XLFilter._applyFilterIcon(val.filteredCells[i], filterIcon);
                            }
                        }
						sheet._selectedRange = val.selRange;
						sheet.filterSettings.filteredRange = val.fltrdRange;
						sheet.filterSettings.filteredColumns = val.filteredCols;
						sheet.filterSettings.range = val.fRange;
						sheet.filterSettings.tableRange.push(val.filterRange);
						for(var k = 0, kLen = val.filterCollection.length; k < kLen; k++) {
							this._excelFilter._predicates[val.sheetIndex][val.filterCollection[k].fieldName] = val.filterCollection[k].predicate;
							this.XLFilter._filterHandler(val.filterCollection[k]);
						}
                    }
                }
                else {
                    if (val.operation === "remove-filter") {
                        if (val.requestType === "filterbycell") {
                            if (this._isRowViewable(val.sheetIndex, val.activeCell.rowIndex)) {
                                cell = this.getCell(val.activeCell.rowIndex, val.activeCell.colIndex);
                                cell.find("span.e-ssfilter").remove();
                            }
                            delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                            this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, val.tableID);
                            $.extend(true, selCells, val.selectedCell);
                            this.XLFilter._filterActiveCell(val.sheetIndex, val.activeCell, selCells, val.filteredValue, val.selRange);
                        }
                        else
                            this.XLFilter.clearFilter("remove");
                    }
                    if (val.operation === "filter") {
                        if (val.requestType === "filterbycell") {
                            delete this._excelFilter._predicates[val.sheetIndex][val.fieldName];
                            this.XLFilter._clearFilterColumn(val.fieldName, "", "", "Or", null, null, val.tableID);
                            $.extend(true, selCells, val.selectedCell);
                            this.XLFilter._filterActiveCell(val.sheetIndex, val.activeCell, selCells, val.filteredValue, val.selRange);
                        }
                    }
                    if (val.operation === "apply-filter") {
                        var filterIcon, sheet = this.getSheet(val.sheetIndex);
                        for (i = 0, len = val.filteredCells.length; i < len; i++) {
                            filterIcon = this.XLFilter._getFilterIcon();
                            this.XLFilter._applyFilterIcon({ rowIndex: val.filteredCells[i].rowIndex, colIndex: val.filteredCells[i].colIndex }, filterIcon);
                        }
                        sheet.filterSettings.range = val.fRange;
                        sheet.filterSettings.tableRange.push(val.filterRange);
                    }
                }
            }
        },

        _undoForFilterByColor: function (val) {
            var avble = false, filterColl, coll = [];
            coll.push(val);
            filterColl = (this._isUndo) ? this._undoCollection : coll;
            delete this._excelFilter._predicates[val.sheetIndex][val.columnName];
            if (val.columnName)
                this.XLFilter._clearFilterColumn(val.columnName, "", "", "Or", null, null, val.tableID);
            for (var i = filterColl.length - 1; i >= 0 ; i--) {
                if ((filterColl[i].reqType === "filterbycolor" || filterColl[i].reqType === "filter") && filterColl[i].tableID === val.tableID) {
                    if (filterColl[i].rowIndex === val.rowIndex && filterColl[i].colIndex === val.colIndex) {
                        this.XLFilter._filterHandler(filterColl[i]);
                        break;
                    }
                }
            }
        },

        _undoForFind: function (val) {
            var cell, i, len, t;
            switch (val.operation) {
                case "replace": {
                    this.XLEdit._updateCellValue({ rowIndex: val.rowIndex, colIndex: val.colIndex }, val.prevData.value, null, val.sheetIndex);
                    t = val.prevData;
                    val.prevData = val.newData;
                    val.newData = t;
                    this.XLSelection.selectRange({ rowIndex: val.rowIndex, colIndex: val.colIndex }, { rowIndex: val.rowIndex, colIndex: val.colIndex });
                    break;
                }
                case "replaceAll": {
                    for (i = 0, len = val.selectedCell.length; i < len; i++) {
                        this.XLEdit._updateCellValue({ rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex }, val.selectedCell[i].prevData.value, null, val.selectedCell[i].sheetIndex);
                        t = val.selectedCell[i].prevData;
                        val.selectedCell[i].prevData = val.selectedCell[i].newData;
                        val.selectedCell[i].newData = t;
                    }
                    break;
                }
                case "blanks":
                case "conditions":
                case "validations":
                case "formulas":
                case "rowdiff":
                case "coldiff":
                case "comments":
                case "constants": {
                    for (i = 0, len = val.selectedCell.length; i < len; i++) {
                        cell = this.getCell(val.selectedCell[i].rowIndex, val.selectedCell[i].colIndex, val.sheetIndex);
                        if (this._isUndo) {
                            if (cell.operation === "coldiff" || cell.operation === "rowdiff")
                                (val.selectedCell[i].isApply) ? cell.removeClass("e-selected") : cell.addClass("e-selected");
                            else
                                (val.selectedCell[i].isApply) ? cell.addClass("e-selected") : cell.removeClass("e-selected");
                        }
                        else {
                            cell.removeClass("e-selected");
                        }
                    }
                    break;
                }
            }
            if (this.model.allowFormulaBar)
                this.updateFormulaBar();
        },

        _undoForFormat: function (val) {
            var isViewed = false, range, cell, formatCls, cElem, container = this._dataContainer.sheets[val.sheetIndex], val2, s, regx, prefix = "";
            if (ej.isNullOrUndefined(val.process)) {
                if (val.oprType === "style") {
                    this.XLFormat.removeStyle(val.range, { cellStyle: true, format: true });
                    prefix = "e-format";
                    if (!ej.isNullOrUndefined(val.process) && val.process.indexOf("border") > -1)
                        prefix = "e-border";
                    regx = new RegExp('\\b' + prefix + '.*?\\b', 'g')
                }
                range = { startCell: val.selectedCell[0], endCell: val.selectedCell[val.selectedCell.length - 1] };
                for (var i = 0, len = val.selectedCell.length; i < len; i++) {
                    cell = val.selectedCell[i];
                    if (this._isRowViewable(val.sheetIndex, cell.rowIndex)) {
                        cElem = this.getCell(cell.rowIndex, cell.colIndex)[0];
                        isViewed = true;
                    }
                    if (ej.isNullOrUndefined(container[cell.rowIndex]))
                        container[cell.rowIndex] = {};
                    if (ej.isNullOrUndefined(container[cell.rowIndex][cell.colIndex]))
                        container[cell.rowIndex][cell.colIndex] = {};
                    $.extend(true, container[cell.rowIndex][cell.colIndex], val.selectedCell[i].beforeFormat);
                    if (isViewed) {
                        if (val.oprType === "format") {
                            val2 = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "value2");
                            this.XLEdit._refreshTextNode(cElem, ej.isNullOrUndefined(val2) ? "" : val2);
							this.XLEdit._refreshCellAlignment({ 'cellIdx': { 'rowIndex': cell.rowIndex, 'colIndex': cell.colIndex } })
                        }
                        else {
                            formatCls = (prefix === "e-format") ? this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "format") : this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "border");
                            cElem.className = cElem.className.replace(regx, "");
                            formatCls = ej.isNullOrUndefined(formatCls) ? "" : formatCls;
                            this.addClass(cElem, formatCls);
                        }
                    }
                    if ((val.selectedCell[0].colIndex === val.selectedCell[i].colIndex) && this.model.allowResizing)
                        (this._isUndo) ? this.XLResize.setRowHeight(val.selectedCell[i].rowIndex, val.selectedCell[i].bRowHeight) : this.XLResize.setRowHeight(val.selectedCell[i].rowIndex, val.selectedCell[i].aRowHeight);
                    s = val.selectedCell[i].beforeFormat;
                    val.selectedCell[i].beforeFormat = val.selectedCell[i].afterFormat;
                    val.selectedCell[i].afterFormat = s;
                    isViewed = false;
                }
            }
            if (!ej.isNullOrUndefined(val.process) && val.process.indexOf("border") > -1) {
                this.XLFormat.removeStyle(val.range, { cellStyle: true, tableStyle: true, format: false, border: true });
                (this._isUndo) ? this.XLFormat.updateFormat(val.beforeFormat, val.range) : (val.process === "noborder") ? this.XLFormat.format({ border: {} }, val.range) : this.XLFormat.applyBorder($.extend(true, {}, val.options), val.range);
                s = val.beforeFormat;
                val.beforeFormat = val.afterFormat;
                val.afterFormat = s;
                if (val.prevHeight.length) {
                    for (var i = 0, len = val.prevHeight.length; i < len ; i++)
                        this.XLResize.setRowHeight(val.prevHeight[i][0], val.prevHeight[i][1]);
                    s = val.prevHeight;
                    val.prevHeight = val.newHeight;
                    val.newHeight = s;
                }
            }
            val.status = "undo-cellformat";
            this.performSelection(val.range);
        },

        _undoForFormatPaint: function (val) {
            var temp, i, rangeData, cells, sheet = this._dataContainer.sheets[val.sheetIndex], wraplen, unwraplen;
            this.XLCFormat.clearCF(val.range);
            this.XLFormat.removeStyle(val.range);
            this.updateData($.extend(true, [], val.beforeData), val.range);
            this.XLCFormat.refreshCFormat(val.range);
            rangeData = this.getRangeData({ range: val.range }), cells = this._getSelectedRange({ rowIndex: val.range[0], colIndex: val.range[1] }, { rowIndex: val.range[2], colIndex: val.range[3] });
            for (i = 0, unwraplen = val.unwrapCells.length; i < unwraplen; i++)
                this.setWrapText('unwrap', this._getAlphaRange(val.sheetIndex, val.unwrapCells[i].rowIndex, val.unwrapCells[i].colIndex, val.unwrapCells[i].rowIndex, val.unwrapCells[i].colIndex));
            for (i = 0, wraplen = val.wrapCells.length; i < wraplen; i++)
                this.setWrapText('wrap', this._getAlphaRange(val.sheetIndex, val.wrapCells[i].rowIndex, val.wrapCells[i].colIndex, val.wrapCells[i].rowIndex, val.wrapCells[i].colIndex));
            temp = val.unwrapCells;
            val.unwrapCells = val.wrapCells;
            val.wrapCells = temp;
            temp = val.beforeData;
            val.beforeData = val.afterData;
            val.afterData = temp;
        },

        _undoForFormatTable: function (val) {
            var j, ln, hdrCol, rng, selCells, tname, rangeData, merge, mlen, mergeData, range, i = 0, sheetIdx = val.sheetIndex,
                tmgr = this.getSheet(sheetIdx).tableManager, tclass, header = val.header, robj = $('#' + this._id + '_Ribbon').data('ejRibbon'), tabRange, isUndo = this._isUndo;
            switch (val.action) {
                case "Design_Tools_ConvertToRange":
                    if (this._isUndo) {
                        tmgr[val.tableID] = { name: val.name, range: val.beforeRange, format: val.format, formatName: val.formatName };
                        this.performSelection(this._getAlphaRange(sheetIdx, val.beforeRange[0], val.beforeRange[1], val.beforeRange[2], val.beforeRange[3]));
                        this.XLFilter._filterTable(sheetIdx, val.tableID);
                        this.updateUniqueData({ tableName: 'e-table' + val.tableID }, tmgr[val.tableID].range);
                        tmgr[val.tableID]["isFilter"] = val.isFilter;
                        tmgr[val.tableID]["firstColumn"] = val.firstColumn;
                        tmgr[val.tableID]["lastColumn"] = val.lastColumn;
                        tmgr[val.tableID]["totalRow"] = val.totalRow;
                        tmgr[val.tableID]["fnNumber"] = val.fnNumber;
                        this.getSheet(sheetIdx)._header[val.tableID] = header;
                        range = this._getDollarAlphaRange(tmgr[val.tableID].range, true);
                        this.XLRibbon.addNamedRange(val.name, range, null, sheetIdx);
                    }
                    else {
                        if (val.tableID in tmgr) {
                            tclass = 'e-table' + val.tableID;
                            this.XLFormat.removeTable(val.tableID);
                            this.XLFilter._clearFilterTable(sheetIdx, val.tableID);
                            delete tmgr[val.tableID];
                            delete this.model.sheets[sheetIdx]._header[val.tableID];
                        }
                    }
                    break;
                case "filtericon":
                    var fIcon = $("#" + val.id).data("ejCheckBox"), tid = val.tableId;
                    (val.check) ? fIcon.option("checked", false) : fIcon.option("checked", true);
                    tmgr[tid]["isFilter"] = !(val.check);
                    val.check = !(val.check);
                    break;
                case "firstlastcolumn":
                    var cc = $("#" + val.id).data("ejCheckBox");
                    if (val.check) {
                        this.XLFormat.format({ style: { 'font-weight': 'normal' } }, val.range);
                        cc.option("checked", false);
                    }
                    else {
                        this.XLFormat.format({ style: { 'font-weight': 'bold' } }, val.range);
                        cc.option("checked", true);
                    }
                    tmgr[val.tableId][val.prop] = !val.check;
                    val.check = !(val.check);
                    break;
                case "totalrow":
                    $("#" + val.id).ejCheckBox('option', { checked: !val.check });
                    val.check = !(val.check);
                    break;
                case "Design_Tools_ResizeTable":
                    var tblmngr;
                    if (this._isUndo) {
                        this._isFATResize = true;
                        val.afterRange = $.extend(true, [], val.afterRange);
                        if (val.totalRow) {
                            this._dupDetails = true;
                            this.XLFormat._calculateTotalRow(sheetIdx, val.tableId, false);
                            val.beforeRange[2] -= 1;
                            tmgr[val.tableId].range[2] -= 1;
                        }
                        tname = tmgr[val.tableId].name;
                        this.XLFormat.removeTable(val.tableId);
                        this.XLFormat.removeStyle(val.afterRange);
                        hdrCol = val.beforeRange[3] - val.beforeRange[1] + 1;
                        rangeData = header[val.tableId].header ? this.getRangeData({ range: val.beforeRange }) : this.getRangeData({ range: val.beforeRange }).splice(hdrCol, this.getRangeData({ range: val.beforeRange }).length);
                        this.clearRangeData(val.beforeRange);
                        header[val.tableId].header ? this.updateData(rangeData, [val.beforeRange[0], val.beforeRange[1], val.beforeRange[2], val.beforeRange[3]]) : this.updateData(rangeData, [val.beforeRange[0], val.beforeRange[1], val.beforeRange[2] - 1, val.beforeRange[3]]);
                        tblmngr = { header: header[val.tableId].header, tblId: val.tableId, name: tname, range: val.beforeRange, format: val.format, formatName: val.formatName, firstColumn: val.firstColumn, lastColumn: val.lastColumn, isFilter: val.isFilter, totalRow: val.totalRow };
                        this.XLClipboard._isCut = true;
                        header[val.tableId].header ? this.XLFormat.createTable(tblmngr, val.beforeRange) : this.XLFormat.createTable(tblmngr, [val.beforeRange[0], val.beforeRange[1], val.beforeRange[2] - 1, val.beforeRange[3]]);
                        if (val.totalRow) {
                            this._dupDetails = true;
                            this.XLFormat._calculateTotalRow(sheetIdx, val.tableId, true);
                            val.beforeRange = tmgr[val.tableId].range;
                        }
                        tabRange = this.getSheet(sheetIdx).filterSettings.tableRange;
                        for (i = 0; i < tabRange.length; i++) {
                            if (tabRange[i].tableID == val.tableId) {
                                tabRange[i].endRow = tabRange[i].selectedRange.endRow = val.beforeRange[2];
                                break;
                            }
                        }
                        this.XLClipboard._isCut = false;
                        this._isFATResize = false;
                    }
                    else {
                        this._isFATResize = true;
                        val.beforeRange = $.extend(true, [], val.beforeRange);
                        if (val.totalRow) {
                            this.XLFormat._calculateTotalRow(sheetIdx, val.tableId, false);
                            val.afterRange = tmgr[val.tableId].range = [val.afterRange[0], val.afterRange[1], val.afterRange[2] - 1, val.afterRange[3]];
                        }
                        tname = tmgr[val.tableId].name;
                        this.XLFormat.removeTable(val.tableId);
                        this.XLFormat.removeStyle(val.beforeRange);
                        hdrCol = val.beforeRange[3] - val.beforeRange[1] + 1;
                        rangeData = header[val.tableId].header ? this.getRangeData({ range: val.afterRange }) : this.getRangeData({ range: val.afterRange }).splice(hdrCol, this.getRangeData({ range: val.afterRange }).length);
                        this.clearRangeData(val.afterRange);
                        header[val.tableId].header ? this.updateData(rangeData, val.afterRange) : this.updateData(rangeData, [val.afterRange[0], val.afterRange[1], val.afterRange[2] - 1, val.afterRange[3]]);
                        tblmngr = { header: header[val.tableId].header, tblId: val.tableId, name: tname, range: val.beforeRange, format: val.format, formatName: val.formatName, firstColumn: val.firstColumn, lastColumn: val.lastColumn, isFilter: val.isFilter, totalRow: val.totalRow };
                        this.XLClipboard._isCut = true;
                        header[val.tableId].header ? this.XLFormat.createTable(tblmngr, val.afterRange) : this.XLFormat.createTable(tblmngr, [val.afterRange[0], val.afterRange[1], val.afterRange[2] - 1, val.afterRange[3]]);
                        this.XLFilter._extendFilterRange(val.tableId, val.afterRange);
                        if (val.totalRow) {
                            this.XLFormat._calculateTotalRow(sheetIdx, val.tableId, true);
                            val.afterRange = tmgr[val.tableId].range;
                        }
                        this.XLClipboard._isCut = false;
                        this._isFATResize = false;
                    }
                    break;
                case "renaming":
                    this.XLRibbon.removeNamedRange(tmgr[val.tableId].name);
                    if (document.getElementById(this._id + '_Ribbon_Design_Properties_TableName'))
                        document.getElementById(this._id + '_Ribbon_Design_Properties_TableName').value = tmgr[val.tableId].name = (this._isUndo) ? val.prevName : val.newName;
                    this.XLRibbon.addNamedRange(tmgr[val.tableId].name, val.range, null, sheetIdx);
                    robj.showTab(this._getLocStr('Design'));
                    break;
                default:
                    if (this._isUndo) {
                        tname = tmgr[val.tableID].name;
                        this.XLFormat.removeTable(val.tableID);
                        this.XLFormat.removeStyle(val.afterRange);
                        if (!val.tableStyle.header) {
                            hdrCol = val.afterRange[3] - val.afterRange[1] + 1;
                            this.clearRangeData(val.afterRange);
                            this.updateData($.extend(true, [], val.beforeRangeData), val.afterRange);
                        }
                        else {
                            for (j = 0, ln = val.beforeRangeHeader.length; j < ln; j++) {
                                if (ej.isNullOrUndefined(val.beforeRangeHeader[j].value2))
                                    this.XLEdit._updateCellValue(this._getCellIdx(val.pcells[j]), "");
                                else {
                                    if (this.isNumber(val.pcells[j].innerHTML))
                                        this.XLEdit._refreshCellAlignment({ cellIdx: this._getCellIdx(val.pcells[j]) });
                                }
                            }
                        }
                        this.XLFormat.updateFormat(val.beforeFormat, val.afterRange);
                        merge = val.beforeMergeRange;
                        mlen = merge.length;
                        if (mlen) {
                            while (i < mlen) {
                                mergeData = merge[i].value;
                                if (mergeData) {
                                    rng = this.getRangeIndices(mergeData.mRange);
                                    selCell = this._getSelectedRange({ rowIndex: rng[0], colIndex: rng[1] }, { rowIndex: rng[2], colIndex: rng[3] });
                                    this.mergeCenter = mergeData.isCenterAlign;
                                    this._mergeCells(val.sheetIndex, selCell, {}, []);
                                }
                                i++;
                            }
                        }
                    }
                    else
                        this.XLFormat.createTable(val.tableStyle, val.beforeRange);
                    break;
            }
        },

        _autosumFormatUpdate: function (data, range, isTable, isChecked) {
            var temp = {}, aRange, sheetIdx = this.getActiveSheetIndex();
            if (data.type !== "general") {
                this._dupDetails = true;
                temp["type"] = data.type;
                if (isTable)
                    aRange = this._getAlphaRange(sheetIdx, range[2] + 1, range[3], range[2] + 1, range[3]);
                else
                    aRange = this._getAlphaRange(sheetIdx, range[0], range[1], range[2], range[3]);
                if (isChecked)
                    this.XLFormat.format({ type: "general" }, aRange + ":" + aRange);
                else
                    this.XLFormat.format(temp, aRange + ":" + aRange);
                this._dupDetails = false;
            }
        },
        _undoForHyperlink: function (val) {
            var i, len, endCell = { rowIndex: val.selectedCell[val.selectedCell.length - 1].rowIndex, colIndex: val.selectedCell[val.selectedCell.length - 1].colIndex },
            startCell = { rowIndex: val.selectedCell[0].rowIndex, colIndex: val.selectedCell[0].colIndex }, lnk, txt, color;
            this.setActiveCell(val.selectedCell[0].rowIndex, val.selectedCell[0].colIndex);
            this.XLSelection.selectRange(startCell, endCell);
            if (val.action === "add")
                this._removeHyperlink(val.reqType, val.selectedCell);
            else if (val.action === "edit")
                this._setLink(val.selectedCell);
            else
                this._setLink(val.selectedCell);
            for (i = 0, len = val.selectedCell.length; i < len; i++) {
                lnk = val.selectedCell[i].prevLink;
                val.selectedCell[i].prevLink = val.selectedCell[i].curLink;
                val.selectedCell[i].curLink = lnk;
                txt = val.selectedCell[i].prevText;
                val.selectedCell[i].prevText = val.selectedCell[i].curText;
                val.selectedCell[i].curText = txt;
                color = val.selectedCell[i].prevColor;
                val.selectedCell[i].prevColor = val.selectedCell[i].curColor;
                val.selectedCell[i].curColor = color;
            }
            if (val.action === "add")
                val.action = "delete";
            else if (val.action === "delete")
                val.action = "add";
            this.XLSelection.selectRange(startCell, endCell);
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForIns: function (val) {
            $.extend(true, this._delCells, val.delCells);
            $.extend(true, this._deletedText, val.text);
            $.extend(true, this._removeMergeColl, val.removeMerge);
            switch (val.action) {
                case "insertShiftRight":
                    this.insertShiftRight(val.startCell, val.endCell);
                    break;
                case "insertShiftBottom":
                    this.insertShiftBottom(val.startCell, val.endCell);
                    break;
                case "insertRow":
                    this.insertEntireRow(val.startCell.rowIndex, val.endCell.rowIndex);
                    break;
                case "insertColumn":
                    this.insertEntireColumn(val.startCell.colIndex, val.endCell.colIndex);
                    break;
            }
        },

        _undoForMerge: function (val) {
            var rng, selectedCells, hiddenCount, pObj, cObj;
            this._delCells = val.hideCells;
            this._selMergeCells = [];
            switch (val.action) {
                case "merge-all":
                case "merge-across":
                case "un-merge":
                    for (var i = 0, len = val.mCells.length; i < len; i++) {
                        pObj = ej.isNullOrUndefined(val.mCells[i].prevObj) ? {} : ej.isNullOrUndefined(val.mCells[i].prevObj.merge) ? {} : val.mCells[i].prevObj.merge;
                        cObj = ej.isNullOrUndefined(val.mCells[i].curObj) ? {} : ej.isNullOrUndefined(val.mCells[i].curObj.merge) ? {} : val.mCells[i].curObj.merge;
                        if (val.action === "un-merge") {
                            if (!ej.isNullOrUndefined(pObj.mRange)) {
                                rng = this.getRangeIndices(pObj.mRange);
                                selectedCells = this._getSelectedRange({ rowIndex: rng[0], colIndex: rng[1] }, { rowIndex: rng[2], colIndex: rng[3] });
                                this.mergeCenter = pObj.isCenterAlign;
                                this._mergeCells(val.sheetIndex, selectedCells, {}, []);
                            }
                        }
                        else {
                            hiddenCount = this._getHiddenRowColumnCount(val.sheetIndex, cObj.mRange);
                            this._unMergeAllCells(val.sheetIndex, i, val.mCells, [], hiddenCount.hRow, hiddenCount.hCol);
                        }
                        var nObj = val.mCells[i].prevObj;
                        val.mCells[i].prevObj = val.mCells[i].curObj;
                        val.mCells[i].curObj = nObj;
                    }
                    if (val.action !== "un-merge") {
                        for (var i = 0, len = val.mCells.length; i < len; i++) {
                            pObj = ej.isNullOrUndefined(val.mCells[i].prevObj) ? {} : ej.isNullOrUndefined(val.mCells[i].prevObj.merge) ? {} : val.mCells[i].prevObj.merge;
                            cObj = ej.isNullOrUndefined(val.mCells[i].curObj) ? {} : ej.isNullOrUndefined(val.mCells[i].curObj.merge) ? {} : val.mCells[i].curObj.merge;
                            if (!ej.isNullOrUndefined(cObj.mRange)) {
                                rng = this.getRangeIndices(cObj.mRange);
                                selectedCells = this._getSelectedRange({ rowIndex: rng[0], colIndex: rng[1] }, { rowIndex: rng[2], colIndex: rng[3] });
                                this.mergeCenter = cObj.isCenterAlign;
                                this._mergeCells(val.sheetIndex, selectedCells, {}, []);
                            }
                        }
                    }
                    val.action = (val.action === "un-merge") ? "merge-all" : "un-merge";
                    break;
            }
            rng = this._getSelectedCells(val.sheetIndex, val.range).range;
            selectedCells = this._getSelectedRange({ rowIndex: rng[0], colIndex: rng[1] }, { rowIndex: rng[2], colIndex: rng[3] });
            this.performSelection(selectedCells[0], selectedCells[selectedCells.length - 1]);
            this._delCells = [];
        },

        _undoForReOrder: function (val) {
            var sheet = this.getSheet(val.sheetIndex), tmgr = this.getSheet(val.sheetIndex).tableManager;
            if (this._isUndo) {
                this.XLComment && this.XLComment.deleteComment();
				for (var i = val.destinationRange[0]; i <= val.destinationRange[2]; i++){
					for (var j = val.destinationRange[1]; j <= val.destinationRange[3]; j++)
						if (this.XLEdit.getPropertyValue(i, j, 'wrap'))
							this.setWrapText("unwrap", this._getAlphaRange(val.sheetIndex, i, j, i, j));
				}
                this.clearRangeData(val.destinationRange, val.property);
                this.XLFormat.removeStyle(val.destinationRange);
                this.XLCFormat.clearCF(val.destinationRange);
                if (!this.isUndefined(val.tblObj)) {
                    this.XLFormat.removeTable(val.tblObj.tblId);
                    this.XLClipboard._isCut = true;
                    this.XLFormat.createTable(val.tblObj, val.sourceRange);
                    val.tblObj.totalRow && this.XLFormat._updateTotalRow(val.sheetIndex, val.tblObj.tblId, val.tblObj.fnNumber, val.sourceRange, false);
                    this.XLClipboard._isCut = false;
                }
                this.updateData($.extend(true, [], val.sourceData), val.sourceRange);
                this.updateData($.extend(true, [], val.destinationData), val.destinationRange);
                if (val.tRange) {
                    this._dupDetails = true;
                    this.XLFilter.clearFilter("remove");
                    this.XLFilter.filter(val.tRange);
                    this._dupDetails = false;
                }
                this.XLFormat.updateFormat(val.sourceFormat, val.sourceRange);
                this.XLFormat.updateFormat(val.destinationFormat, val.destinationRange);
                if (!this.isUndefined(val.sourceCFormat) && !(val.sourceCFormat instanceof Array))
                    this.XLCFormat.setCFRule(val.sourceCFormat);
                this.setActiveCell(val.sourceRange[0], val.sourceRange[1]);
                this.XLSelection.selectRange({ rowIndex: val.sourceRange[0], colIndex: val.sourceRange[1] }, { rowIndex: val.sourceRange[2], colIndex: val.sourceRange[3] }, val.sheetIndex);
                sheet._startCell = { rowIndex: val.sourceRange[0], colIndex: val.sourceRange[1] };
                sheet._endCell = { rowIndex: val.sourceRange[2], colIndex: val.sourceRange[3] };
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
                this.setHeightToRows(val.prevDestRowHt);
            }
            else {
                this.XLSelection.selectRange({ rowIndex: val.sourceRange[0], colIndex: val.sourceRange[1] }, { rowIndex: val.sourceRange[2], colIndex: val.sourceRange[3] }, val.sheetIndex);
                this.XLComment && this.XLComment.deleteComment();
				for (var i = val.sourceRange[0]; i <= val.sourceRange[2]; i++){
					for (var j = val.sourceRange[1]; j <= val.sourceRange[3]; j++)
						if (this.XLEdit.getPropertyValue(i, j, 'wrap'))
							this.setWrapText("unwrap", this._getAlphaRange(val.sheetIndex, i, j, i, j));
				}
                this.clearRangeData(val.sourceRange, val.property);
                this.clearRangeData(val.destinationRange, val.property);
                if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(val.destinationRange[0], val.destinationRange[1], "tableName")))
                    this.XLFormat.removeStyle(val.destinationRange);
                if (!this.isUndefined(val.tblObj)) {
                    this.XLFormat.removeTable(val.tblObj.tblId);
                    this.XLClipboard._isCut = true;
                    this.XLFormat.createTable(val.tblObj, val.destinationRange);
                    this.XLClipboard._isCut = false;
                }
                if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(val.sourceRange[0], val.sourceRange[1], "tableName")))
                    this.XLFormat.removeStyle(val.sourceRange);
                this.XLCFormat.clearCF(val.sourceRange);
                this.updateData($.extend(true, [], val.sourceData), val.destinationRange);
                if (val.tRange) {
                    this._dupDetails = true;
                    this.XLFilter.clearFilter("remove");
                    this.XLFilter.filter(val.destinationRange);
                    this._dupDetails = false;
                }
                this.XLFormat.updateFormat(val.sourceFormat, val.destinationRange);
                val.tblObj && val.tblObj.totalRow && this.XLFormat._updateTotalRow(val.sheetIndex, val.tblObj.tblId, val.tblObj.fnNumber, val.destinationRange, false);
                if (!this.isUndefined(val.destinationCFormat) && !(val.destinationCFormat instanceof Array))
                    this.XLCFormat.setCFRule(val.destinationCFormat);
                this.setHeightToRows(val.destHeight);
                this.setActiveCell(val.destinationRange[0], val.destinationRange[1]);
                this.XLSelection.selectRange({ rowIndex: val.destinationRange[0], colIndex: val.destinationRange[1] }, { rowIndex: val.destinationRange[2], colIndex: val.destinationRange[3] }, val.sheetIndex);
                sheet._startCell = { rowIndex: val.destinationRange[0], colIndex: val.destinationRange[1] };
                sheet._endCell = { rowIndex: val.destinationRange[2], colIndex: val.destinationRange[3] };
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
            }
        },

        _undoForPivot: function (val) {
            var coll = (this._isUndo) ? this._undoCollection : this._redoCollection;
            var args = { curOperation: val, prevOperation: coll[coll.length - 1], isUndo: this._isUndo };
            this._trigger("_readUndoRedo", args);
        },

        _undoForResizeCol: function (val) {
            this.XLResize._resizeColumnUsingDiff(val.oldWidth, val.newWidth, val.cols);
            var temp = val.oldWidth;
            val.oldWidth = val.newWidth;
            val.newWidth = temp;
            if (this.model.allowAutoFill)
                this.XLDragFill.positionAutoFillElement();
        },

        _undoForResizeRow: function (val) {
            this.XLResize._resizeRowUsingDiff(val.oldHeight, val.newHeight, val.rows);
            var temp = val.oldHeight;
            val.oldHeight = val.newHeight;
            val.newHeight = temp;
            if (this.model.allowAutoFill)
                this.XLDragFill.positionAutoFillElement();
        },

        _undoForResizeFHeight: function (val) {
            var isUndo = this._isUndo,
			temp = val.newHeight;
			val.newHeight = val.oldHeight;
			val.oldHeight = temp;
            this.XLResize.setRowHeight(val.rowIndex, val.newHeight);
            this._isUndo ? this.XLEdit._clearDataContainer({ sheetIdx: val.sheetIndex, cellIdx: { rowIndex: val.rowIndex, colIndex: 0 }, property: ["isFitHeight"] }) : this.XLEdit._updateDataContainer({ rowIndex: val.rowIndex, colIndex: 0 }, { dataObj: { "isFitHeight": true } });
            if (this.model.allowAutoFill)
                this.XLDragFill.positionAutoFillElement();
            this._isUndo = isUndo;
        },

        _undoForResizeFWidth: function (val) {
            var cell = this.getCell(0, val.colIndex).get(0), isUndo = this._isUndo;
            var newWidth = val.newWidth;
            val.newWidth = (cell.offsetWidth === val.oldWidth) ? val.newWidth : val.oldWidth;
            val.oldWidth = newWidth;
            this.XLResize._applyWidth(val.target, val.sheetIndex, val.colIndex, val.newWidth);
            this.XLScroll._getColWidths(val.sheetIndex, val.colIndex);
            this._isUndo ? this.XLEdit._clearDataContainer({ sheetIdx: val.sheetIndex, cellIdx: { rowIndex: 0, colIndex: val.colIndex }, property: ["isFitWidth"] }) : this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: val.colIndex }, { dataObj: { "isFitWidth": true } });
            if (this.model.allowAutoFill)
                this.XLDragFill.positionAutoFillElement();
            this._isUndo = isUndo;
        },

        _undoForShape: function (val) {
            var cObj, dataVal, chartId, ddObj, idx = 0, chartThemes, shapeMgr = this.getSheet(val.sheetIndex).shapeMngr;
            (this.model.showRibbon) && (chartThemes = this.XLRibbon._chartThemes);
            if (val.action != "chartType" && val.action !== "create" && val.action !== "remove" && val.action !== "edit" && val.action !== "border" && val.action !== "resetpicture" && val.action !== "changepicture" && val.action !== "picturesize" && val.action !== "chartTheme" && val.action !== "chartType" && val.action !== "selectData") {
                cObj = $("#" + val.cid).data("ejChart");
                dataVal = this.getSheet(val.sheetIndex).shapeMngr.chart[this.XLEdit.getPropertyValue(val.rowIndex, val.colIndex, "chart")[0]];
            }
            switch (val.action) {
                case "create":
                    this.XLShape._picCellIdx = this.XLShape._getCellIndexFromOffset(val.position.top, val.position.left);
                    this.XLShape._deleteShape(val.sheetIndex, $("#" + val.id));
                    val.action = "remove";
                    break;
                case "remove":
                    if (val.shapeType === "picture") {
                        this.XLShape._createPicture(val.sheetIndex, val.actCell, val.img, val.position.top, val.position.left, val.position.width, val.position.height, val.cnt, val.bcolor, val.bstyle, val.bwidth);
                        this.XLRibbon._formatTabUpdate();
                        $(val.actCell).addClass("e-activecell");
                    }
                    else {
                        if (!val.options.isChartSeries) {
                            this.XLSelection.selectRange({ rowIndex: val.range[0], colIndex: val.range[1] }, { rowIndex: val.range[0], colIndex: val.range[1] }, val.sheetIndex);
                            this.setActiveCell(val.range[0], val.range[1], val.sheetIndex);                           
                        }
                         this.XLChart.createChart(val.options.isChartSeries ? null : this._getAlphaRange(val.sheetIndex, val.range[0], val.range[1], val.range[2], val.range[3]), val.options, val.id);
                    }
                    val.action = "create";
                    break;
                case "edit":
                    var rng, container = this._dataContainer.sheets[val.sheetIndex], shapeType = val.id.split("_")[1].replace(/[0-9]/g, ''), imgElem = {}, objIdx, prevCellIdx;
                    $("#" + val.id).css({ left: val.prev.left, top: val.prev.top, height: val.prev.height, width: val.prev.width });
                    (shapeType === "chart") && this.XLChart.resizeChart(val.id, val.prev.height, val.prev.width);
                    val.visualImg.hide();
                    this.XLShape._picCellIdx = this.XLShape._getCellIndexFromOffset(val.prev.top, val.prev.left), prevCellIdx = this.XLShape._getCellIndexFromOffset(val.cur.top, val.cur.left);
                    rng = this._getShapePositionInManager(prevCellIdx.rowIndex, prevCellIdx.colIndex, val.id, shapeType);
                    imgElem[shapeType] = val.obj[shapeType][rng];
                    if (val.actionType != "resize") {
                        if (this.getObjectLength(container[prevCellIdx.rowIndex][prevCellIdx.colIndex]) < 2 && container[prevCellIdx.rowIndex][prevCellIdx.colIndex][shapeType].length < 2)
                            delete container[prevCellIdx.rowIndex][prevCellIdx.colIndex];
                        else if (container[prevCellIdx.rowIndex][prevCellIdx.colIndex][shapeType].length < 2)
                            delete container[prevCellIdx.rowIndex][prevCellIdx.colIndex][shapeType];
                        else {
                            container[prevCellIdx.rowIndex][prevCellIdx.colIndex][shapeType].some(function (obj, i) { if (imgElem.id === obj.id) { objIdx = i; return true; } });
                            container[prevCellIdx.rowIndex][prevCellIdx.colIndex][shapeType].splice(objIdx, 1);
                        }
                    }
                    this.XLEdit._updateDataContainer({ rowIndex: this.XLShape._picCellIdx.rowIndex, colIndex: this.XLShape._picCellIdx.colIndex }, { dataObj: imgElem });
                    this.getCell(this.XLShape._picCellIdx.rowIndex, this.XLShape._picCellIdx.colIndex, val.sheetIndex).addClass("e-activecell");
                    if (this.model.showRibbon && this.element.find(".e-ss-activeimg").length < 1)
                        shapeType === "picture" ? this.XLRibbon._toggleFormatTab() : this.XLRibbon._toggleChartDesignTab();
                    this.XLRibbon._setShapeWidthHeight({ "width": val.prev.width, "height": val.prev.height, "shapeType": shapeType });
                    this._swapVal(val);
                    break;
                case "PHAxis":
                case "PVAxis":
                    var pAxis = (val.action == "PHAxis") ? "primaryXAxis" : "primaryYAxis", axis = (val.action === "PHAxis") ? "xAxis" : "yAxis";
                    val.visibility = !(val.visibility);
                    cObj.option(pAxis, { visible: val.visibility });
                    dataVal[axis].visible = val.visibility;
                    break;
                case "PX":
                case "PY":
                    var pAxis = (val.action == "PX") ? "primaryXAxis" : "primaryYAxis", axis = (val.action === "PX") ? "xAxis" : "yAxis";
                    ej.isNullOrUndefined(val.prev.text) && (val.prev.text = "");
                    cObj.option(pAxis, { title: { text: val.prev.text } });
                    dataVal[axis].title.text = val.prev.text;
                    this._swapVal(val);
                    break;
                case "CT":
                    cObj.option("title", { textAlignment: val.prev.align, text: val.prev.text });
                    dataVal.title = { text: val.prev.text, textAlignment: val.prev.align };
                    this._swapVal(val);
                    break;
                case "DLNone":
                    cObj.option({ series: val.prev.series });
                    dataVal.dataLabel = { visible: val.prev.series[0].marker.dataLabel.visible };
                    this._swapVal(val);
                    break;
                case "DL":
                    cObj.option({ series: val.prev.series });
                    dataVal.dataLabel = { visible: val.prev.series[0].marker.dataLabel.visible, vAlign: val.prev.series[0].marker.dataLabel.verticalTextAlignment, tPosn: val.prev.series[0].marker.dataLabel.textPosition };
                    this._swapVal(val);
                    break;
                case "PMajorH":
                    val.visibility = !(val.visibility);
                    cObj.option("primaryYAxis", { majorGridLines: { visible: val.visibility } });
                    dataVal.yAxis.majorGridLines = { visible: val.visibility };
                    break;
                case "PMajorV":
                    val.visibility = !(val.visibility);
                    cObj.option("primaryXAxis", { majorGridLines: { visible: val.visibility } });
                    dataVal.xAxis.majorGridLines = { visible: val.visibility };
                    break;
                case "PMinorH":
                    val.visibility = !(val.visibility);
                    cObj.option("primaryYAxis", { minorGridLines: { visible: val.visibility }, minorTicksPerInterval: 5, minorTickLines: { visible: val.visibility } });
                    dataVal.yAxis.minorGridLines = { visible: val.visibility };
                    break;
                case "PMinorV":
                    val.visibility = !(val.visibility);
                    cObj.option("primaryXAxis", { minorGridLines: { visible: val.visibility }, minorTicksPerInterval: 5, minorTickLines: { visible: val.visibility } });
                    dataVal.xAxis.minorGridLines = { visible: val.visibility };
                    break;
                case "LNone":
                    val.visibility = !(val.visibility);
                    cObj.option("legend", { visible: val.visibility });
                    dataVal.legend.visible = val.visibility;
                    break;
                case "Legend":
                    cObj.option("legend", { position: val.prev.position });
                    dataVal.legend.position = val.prev.position;
                    this._swapVal(val);
                    break;
                case "width":
                    var opt = { width: val.prev.width, height: val.prev.height,'shapeType': 'chart' };
                    var chartEle = $("#" + cObj._id);
                    cObj.option("size", $.extend(true, {}, opt));
                    chartEle[0].style.height = val.prev.height + "px";
                    chartEle[0].style.width = val.prev.width + "px";
                    dataVal.width = val.prev.width;
                    dataVal.height = val.prev.height;
                    this.XLRibbon._setShapeWidthHeight(opt);
                    this._swapVal(val);
                    break;
                case "height":
                    var opt = { width: val.prev.width, height: val.prev.height, 'shapeType': 'chart' };
                    var chartEle = $("#" + cObj._id);
                    cObj.option("size", $.extend(true, {}, opt));
                    chartEle[0].style.height = val.prev.height + "px";
                    chartEle[0].style.width = val.prev.width + "px";
                    dataVal.width = val.prev.width;
                    dataVal.height = val.prev.Height;
                    this.XLRibbon._setShapeWidthHeight(opt);
                    this._swapVal(val);
                    break;
                case "srcolumn":
                    var obj, chOptions;
                    cObj.model.series.length = 0;
                    dataVal.isRowColSwitched = !dataVal.isRowColSwitched;
                    obj = { xRange: dataVal.xRange, yRange: dataVal.yRange, lRange: dataVal.lRange, isRowColSwitched: dataVal.isRowColSwitched, dataSheetIdx: dataVal.dataSheetIdx };
                    chOptions = this.XLChart._processChartSeries(obj);
                    cObj.option({ series: chOptions.series });
                    this.getActiveSheetIndex() === dataVal.dataSheetIdx && this.XLChart._focusChartRange(chOptions.xRange, chOptions.yRange, chOptions.lRange);
                    dataVal.xAxis.range = chOptions.xRange;
                    dataVal.yAxis.range = chOptions.yRange;
                    dataVal.legend.range = chOptions.lRange;
                    break;
                case "border":
                    var temp, style, shapeObj = this._dataContainer.sheets[val.sheetIndex][val.cellIdx.rowIndex][val.cellIdx.colIndex].picture[val.picIdx], elem = $("#" + val.id);
                    this._removeClass(elem[0], val.curClass);
                    this.addClass(elem[0], val.prevClass);
                    style = this.XLShape._getImgStyleFromHashCode(val.prevClass);
                    shapeObj = { bcolor: style["border-color"], bstyle: style["border-style"], bwidth: style["border-width"] };
                    temp = val.prevClass;
                    val.prevClass = val.curClass;
                    val.curClass = temp;
                    break;
                case "resetpicture":
                    var elem = $("#" + val.id), regx = new RegExp("\\b" + "e-shapebdr" + ".*?\\b", "g");
                    if (this._isUndo)
                        (elem[0].className.match(regx)) && this.XLShape.changePictureBorder(elem[0].id, val.prev.bwidth, val.prev.bstyle, val.prev.bcolor);
                    else
                        elem[0].className = elem[0].className.replace(regx, "");
                    if (val.actionType !== "resetpicture") {
                        elem.css({ width: val.prev.width, height: val.prev.height });
                        this.XLShape._selectImg(elem);
                        this.XLShape._updateShapeObj(elem[0]);
                    }
                    this._swapVal(val);
                    break;
                case "changepicture":
                    var num, container = this._dataContainer;
                    $("#" + val.id).css("background-image", "url('" + val.prev.img + "')");
                    shapeMgr.picture[val.prev.pcIdx].data = val.prev.data;
                    this._swapVal(val);
                    break;
                case "picturesize":
                    var elem = $("#" + val.id), opt = { "width": val.prev.width, "height": val.prev.height, "shapeType": "picture" };
                    elem.css(opt);
                    this.XLRibbon._setShapeWidthHeight(opt);
                    this._swapVal(val);
                    break;
                case "chartTheme":
                    chartId = this.element.find("#" + this._id + "_chart").val(), ddObj = $("#" + this._id + "_Ribbon_ChartDesign_ChartThemes_ChartThemes").data("ejDropDownList");
                    (val.prev.theme.indexOf("dark") > -1) ? ($("#" + chartId).addClass('e-ss-charttheme')) : ($("#" + chartId).removeClass('e-ss-charttheme'));
                    this.XLChart.refreshChart(chartId, { theme: val.prev.theme });
                    for (var i = 0, len = chartThemes.length; len > i ; i++) {
                        if (val.prev.theme === chartThemes[i].value.toLowerCase()) {
                            idx = i;
                            break;
                        }
                    }
                    ddObj && ddObj.option({ selectedItemIndex: idx })
                    this._swapVal(val);
                    break;
                case "chartType":
                    this.XLChart.refreshChart(val.chartId, { type: val.prev.chartType, enable3D: val.prev.enable3D, marker: val.prev.marker });
                    this._swapVal(val);
                    break;
                case "selectData":
                    this.XLChart.changeDataRange(document.getElementById(this._id + "_chart").value, val.prev.xRange, val.prev.yRange, val.prev.lRange);
                    this._swapVal(val);
                    break;
            }
        },

        _undoForShowHide: function (val) {
            var i, len, rowHdrs, colHdrs;
            if (val.operation === "row") {
                rowHdrs = this._getJSSheetRowHeaderContent(val.sheetIndex);
                (val.action === "show") ? this._hideRow(val.hideRows[0], val.hideRows[val.hideRows.length - 1], "isRHide") : this._showRow(val.hideRows[0], val.hideRows[val.hideRows.length - 1], "isRHide");
                for (i = 0, len = val.remBRows.length; i < len; i++) {
                    this.addClass(rowHdrs.find('td')[val.remBRows[i]], "e-hrow");
                    this.XLEdit._updateDataContainer({ rowIndex: val.remBRows[i], colIndex: 0 }, { dataObj: { hRow: true } });
                }
                for (i = 0, len = val.addBRows.length; i < len; i++) {
                    this._removeClass(rowHdrs.find('td')[val.addBRows[i]], "e-hrow");
                    this._dataContainer.sheets[val.sheetIndex][val.addBRows[i]][0]["hRow"];
                }
                this.setActiveCell(val.bSelect.startRow, 0);
                (val.bSelect.startRow === val.bSelect.endRow) ? this.XLSelection.selectRow(val.bSelect.startRow, val.sheetIndex) : this.XLSelection.selectRows(val.bSelect.startRow, val.bSelect.endRow, val.sheetIndex);
                var addBRows = val.addBRows;
                val.addBRows = val.remBRows;
                val.remBRows = addBRows;
            }
            else {
                colHdrs = this._getJSSheetHeader(val.sheetIndex).find('th');
                (val.action === "show") ? this._hideColumn(val.hideCols[0], val.hideCols[val.hideCols.length - 1]) : this._showColumn(val.hideCols[0], val.hideCols[val.hideCols.length - 1]);
                for (i = 0, len = val.remBCols.length; i < len; i++) {
                    this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: val.remBCols[i] }, { dataObj: { hCol: true } });
                    this.addClass(colHdrs[val.remBCols[i]], "e-hcol");
                }
                for (i = 0, len = val.addBCols.length; i < len; i++) {
                    this._removeClass(colHdrs[val.addBCols[i]], "e-hcol");
                    this._dataContainer.sheets[val.sheetIndex][0][val.addBCols[i]]["hCol"];
                }
                this.setActiveCell(0, val.bSelect.startCol);
                (val.bSelect.startCol === val.bSelect.endCol) ? this.XLSelection.selectColumn(val.bSelect.startCol, val.sheetIndex) : this.XLSelection.selectColumns(val.bSelect.startCol, val.bSelect.endCol, val.sheetIndex);
                var addBCols = val.addBCols;
                val.addBCols = val.remBCols;
                val.remBCols = addBCols;
            }
            val.action = (val.action === "show") ? "hide" : "show";
            var bSelect = val.bSelect;
            val.bSelect = val.aSelect;
            val.aSelect = bSelect;
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForSort: function (val) {
            var colIdx = this.XLEdit.getColumnIndexByField(val.columnName), prevIcon, fSpan, fCol, rng, filterColl = this.getSheet(val.sheetIndex)._filterColl;
            if (val.colSelected < 1) {
                rng = val.range[0];
                if (val.range[0] > 0)
                    rng = val.range[0] - 1;
            }
            if (val.operation === "unsort") {
                this._dupDetails = true;
                this.XLComment.deleteComment(val.range, null, true, null);
                this._removeHyperlink(null, null, true, val.range);
                this.clearRangeData(val.range, ["value", "value2", "type", "formatStr", "decimalPlaces", "thousandSeparator", "comment", "hyperlink", "format"], null, true);
                this.XLFormat.removeStyle(val.range, { cellStyle: true, tableStyle: true, format: true, skipHiddenRow: true });
                this.XLEdit.updateCellWithContainer(val.rangeData, val.range, val.sheetIndex, true);
                this.XLSort._refreshRowHeight(val.range, val.rangeData);
                this._dupDetails = false;
                val.operation = "sort";
            }
            else {
                this.XLSort._isSortByFilter = val.isSortByFilter;
                this.XLSort.sortByRange(val.range, val.columnName, val.direction);
                val.operation = "unsort";
            }
            if (val.isSortByFilter) {
                for (var i = 0; i < val.filterIcons.length; i++) {
                    fCol = filterColl[val.filterIcons[i].rowIdx][val.filterIcons[i].colIdx];
                    if (fCol.status.indexOf("-asc") > 1)
                        fCol.status = fCol.status.replace("-asc", val.filterIcons[i].prevIcon);
                    else if (fCol.status.indexOf("-dsc") > 1)
                        fCol.status = fCol.status.replace("-dsc", val.filterIcons[i].prevIcon);
                    else
                        fCol.status = fCol.status + val.filterIcons[i].prevIcon;
                    if (this._isRowViewable(val.sheetIndex, val.filterIcons[i].rowIdx)) {
                        fSpan = this.getCell(val.filterIcons[i].rowIdx, val.filterIcons[i].colIdx).find(".e-filterspan")[0];
                        if (fSpan.className.indexOf("-asc") > 1)
                            fSpan.className = fSpan.className.replace("-asc", val.filterIcons[i].prevIcon);
                        else if (fSpan.className.indexOf("-dsc") > 1)
                            fSpan.className = fSpan.className.replace("-dsc", val.filterIcons[i].prevIcon);
                        else {
                            if (fSpan.className.indexOf("e-ssfiltered") > -1)
                                fSpan.className = fSpan.className.replace("e-ssfiltered", "e-ssfiltered" + val.filterIcons[i].prevIcon);
                            else
                                fSpan.className = fSpan.className.replace("e-ssfilter", "e-ssfilter" + val.filterIcons[i].prevIcon);
                        }
                    }
                    prevIcon = val.filterIcons[i].prevIcon;
                    val.filterIcons[i].prevIcon = val.filterIcons[i].currIcon;
                    val.filterIcons[i].currIcon = prevIcon;
                }
            }
        },

        _undoForSortByColor: function (val) {
            var rng = val.range, pData = val.prev.data, i, format, colIdx = this._generateColCount(val.columnName) - 1;
            this.XLComment.deleteComment(rng, null, true, null);
            this._isSort = true;
            this._dupDetails = true;
            this._removeHyperlink(null, null, true, rng);
            this._isSort = false;
            this._dupDetails = false;
            this.clearRangeData(rng, ["value", "value2", "type", "formatStr", "decimalPlaces", "thousandSeparator", "comment", "hyperlink", "format"], null, true);
            this.XLFormat.removeStyle(rng, { cellStyle: true, tableStyle: true, format: true, skipHiddenRow: true });
            this.XLEdit.updateCellWithContainer(pData, rng, val.sheetIndex, true);
            if (val.oprType.indexOf("Put") < 0) {
                var filterSpan = this.getCell(rng[0] - 1, colIdx).find(".e-filterspan");
                if (filterSpan.length > 0)
                    filterSpan[0].className = filterSpan[0].className.replace(val.cur.icon, val.prev.icon);
            }
            this._swapVal(val);
        },

        _undoForStyle: function (val) {
            this.XLFormat.updateUniqueFormat(val.beforeFormat, val.range, val.opr);
            this._updateRangeStyle(val.range, val.beforeFormat);
            var s = this.changePosition(val.beforeFormat, val.afterFormat);
            this._refreshRangeTRHght(this.getActiveSheetIndex(), val.range);
            val.beforeFormat = s[1];
            val.afterFormat = s[0];
            this._isUndoRedo = true;
            val.status = "undo-cellstyles";
        },

        _undoForTextWrap: function (val) {
            if (val.operation === "wrap") {
                this.setWrapText("unwrap", val.range);
                val.operation = "unwrap";
            }
            else {
                this.setWrapText("wrap", val.range);
                val.operation = "wrap";
            }
            this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
        },

        _undoForValidation: function (val) {
            var i, len, range = this.getRangeIndices(val.range);
            this.performSelection({ rowIndex: range[0], colIndex: range[1] }, { rowIndex: range[2], colIndex: range[3] });
            if (val.operation === "cl-hl-data") {
                this.XLValidate.highlightInvalidData(val.range);
                val.operation = "hl-data";
            }
            else if (val.operation === "apply-validation") {
                var selCells = val.selectedCell, rule, curRule, selected = [];
                for (i = 0, len = selCells.length; i < len; i++) {
                    curRule = this.XLEdit.getPropertyValue(selCells[i].rowIndex, selCells[i].colIndex, "rule");
                    rule = this.changePosition(selCells[i].prevRule, curRule);
                    val.selectedCell[i].prevRule = rule[1];
                    if (!ej.isNullOrUndefined(rule[0])) {
                        rule[0].customVal = rule[0].customVal;
                        this.XLEdit._updateDataContainer({ rowIndex: selCells[i].rowIndex, colIndex: selCells[i].colIndex }, { dataObj: { "rule": rule[0] } });
                    }
                    selected.push(selCells[i]);
                }
                if (ej.isNullOrUndefined(rule[0]))
                    this.clearRangeData(null, ["rule"], selected);
            }
            else if (val.operation === "hl-data") {
                this.XLValidate.clearHighlightedValData(val.range);
                val.operation = "cl-hl-data";
            }
            else {
                if (this._isUndo) {
                    for (i = 0, len = val.selectedCell.length; i < len; i++)
                        this.XLEdit._updateDataContainer({ rowIndex: val.selectedCell[i].rowIndex, colIndex: val.selectedCell[i].colIndex }, { dataObj: { "rule": val.selectedCell[i].rules } });
                    if (val.hlStatus)
                        this.XLValidate.highlightInvalidData(val.range);
                }
                else
                    this.XLValidate.clearDV(val.range);
            }
        },

        _applyCommentLink: function (cellObj, cell, rowIdx, colIdx) {
            var container = this._dataContainer, hldata, cFormatData = container.cFormatData, actCell, isViewed = false, sheetIdx = this.getActiveSheetIndex();
            if (this._isRowViewable(sheetIdx, cell.rowIndex)) {
                actCell = this.getCell(cell.rowIndex, cell.colIndex);
                isViewed = true;
                $(actCell).removeClass("e-redft e-yellowft e-greenft e-redf e-redt");
                if (actCell.hasClass("e-cformat")) {
                    actCell[0].style.color = "";
                    actCell[0].style.backgroundColor = "";
                    actCell.removeClass("e-cformat");
                }
            }
            if (cellObj) {
                var value2 = this.isNumber(cellObj.value2) ? container.sharedData[cellObj.value2] : cellObj.value2;
                cellObj = $.extend(true, {}, cellObj);
                this.XLEdit._updateCellValue(cell, value2);
                if ("cFormatRule" in cellObj) {
                    var cFormatRule = cellObj.cFormatRule, splitStr;
                    for (var m = 0, rLen = cFormatRule.length; m < rLen; m++) {
                        splitStr = cFormatData[m].split("_");
                        this.XLCFormat._cFormat(splitStr[0], splitStr[2], splitStr[3], splitStr[4], splitStr[5], null, null, [rowIdx, colIdx, rowIdx, colIdx]);
                    }
                }
                if ("hyperlink" in cellObj) {
                    var hldata = cellObj.hyperlink;
                    if (isViewed) {
                        if (hldata && !hldata.webAddr)
                            actCell.html(ej.buildTag("a.e-hyperlinks", this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, 'value2', sheetIdx), ""));
                        else
                            actCell.html(ej.buildTag("a.e-hyperlinks", this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, 'value2', sheetIdx), "", { href: hldata.webAddr, target: "_blank" }));
                    }
                }
                if ("comment" in cellObj) {
                    isViewed && actCell.removeClass("e-commentcell");
                    this.XLComment.setComment([cell.rowIndex, cell.colIndex, cell.rowIndex, cell.colIndex], null, false);
                }
            }
        },

        changePosition: function (first, second) {
            var swap = [];
            swap.push(second);
            swap.push(first);
            ej.swap(swap, 0, 1);
            return swap;
        },

        _addValidationRule: function (totRules, rule) {
            var dupRule = [];
            $.extend(true, dupRule, totRules);
            for (var i = 0, len = totRules.length; i < len; i++)
                if (totRules[i].customVal !== rule.customVal && totRules[i].required !== rule.required && totRules[i].Number !== rule.number)
                    dupRule.push(rule);
            totRules = dupRule;
            return totRules;
        },

        _addCondFormatRule: function (totRules, rule) {
            var avble = false, dupRule = [];
            $.extend(true, dupRule, totRules);
            for (var i = 0, len = totRules.length; i < len; i++) {
                rule = rule.indexOf("true") > -1 ? rule.replace("_true", "") : rule.replace("_false", "");
                if (totRules[i] === rule) {
                    avble = true;
                    break;
                }
            }
            (!avble) && dupRule.push(rule);
            totRules = dupRule;
            return totRules;
        },

        getCellClass: function (curCell) {
            var regx = this._formatRegx;
            var currClass = curCell && (curCell.className.indexOf("e-format") > -1) ? curCell.className.match(regx)[0] : "";
            return currClass;
        },


        //Insert Or Delete Rows and Columns
        _renderInsertDeleteDialog: function (operation) {
            var dlgId = this._id + "_insertdeletedlg", $dlg, $content, $okBtn, $canBtn, $btndiv, $btnctn, $content, text;
            $dlg = ej.buildTag("div#" + dlgId, "", { display: "none" });
            $content = ej.buildTag("div#" + dlgId + "_content.e-dlg-fields e-dlgctndiv");
            $dlg.append($content);
            $btndiv = ej.buildTag("div#" + dlgId + "_btndiv.e-dlg-btnfields");
            $btnctn = ej.buildTag("div");
            $okBtn = ej.buildTag("input#" + dlgId + "_okbtn", "", { "margin-left": 4 });
            $canBtn = ej.buildTag("input#" + dlgId + "_cantn");
            $okBtn.ejButton({ text: this._getLocStr("Ok"), showRoundedCorner: true, width: 60, click: ej.proxy(this._insertDeleteOk, this), enabled: true , cssClass: "e-ss-okbtn"});
            $canBtn.ejButton({ text: this._getLocStr("Cancel"), click: ej.proxy(this._insertDeleteCancel, this), showRoundedCorner: true, width: 60 });
            $btndiv.append($btnctn.append($okBtn, $canBtn));
            $dlg.append($btndiv);
            $dlg.ejDialog({ showOnInit: false, enableModal: true, enableResize: false, allowKeyboardNavigation: false, width: "auto", height: "auto", cssClass: "e-ss-dialog e-" + this._id + "-dlg e-ss-insdeldlg", minWidth: 150 });
        },

        _refreshInsDelDialog: function (operation) {
            var enableBtn, $dlg = $("#" + this._id + "_insertdeletedlg"), $content, text;
            $dlg.ejDialog({ title: this._getLocStr(operation) });
            $dlg.ejDialog("open");
            this._insDelStatus = operation.toLowerCase();
            $content = $("#" + $dlg[0].id + "_content");
            text = (this._insDelStatus === "insert") ? ["ShiftRight", "ShiftBottom", "EntireRow", "EntireColumn"] : ["ShiftLeft", "ShiftUp", "EntireRow", "EntireColumn"];
            $content.children().empty();
            this._createRadioButton($dlg, $content, text);
            enableBtn = (this._insDelStatus === "insert") ? "ShiftBottom" : "ShiftLeft";
            $("#" + $dlg[0].id + "_" + enableBtn).ejRadioButton({ checked: true });
            $dlg.find("input[type='submit']:first").focus();
        },

        _createRadioButton: function ($dlg, $content, text) {
            var input, lbl, table, tr1, td1;
            table = ej.buildTag("table");
            for (var i = 0, len = text.length; i < len; i++) {
                tr1 = ej.buildTag("tr");
                td1 = ej.buildTag("td");
                lbl = ej.buildTag("label", this._getLocStr(text[i]), { "padding-bottom": 4 }, { "for": $dlg[0].id + "_" + text[i] });
                input = ej.buildTag("input#" + $dlg[0].id + "_" + text[i], "", {}, { type: "radio", name: "inserdelete" });
                td1.append(input);
                tr1.append(td1);
                td1 = ej.buildTag("td");
                td1.append(lbl);
                input.ejRadioButton({ size: "medium" });
                tr1.append(td1);
                table.append(tr1);
            }
            $content.append(table);
        },

        _getSelectedOption: function (text) {
            var dlgId = this._id + "_insertdeletedlg", selIdx = 0;
            for (var i = 0; i < 4; i++) {
                var rbtn = $("#" + dlgId + "_" + text[i]).data("ejRadioButton");
                if (rbtn.model.checked) {
                    selIdx = i;
                    break;
                }
            }
            return selIdx;
        },

        _insertDeleteOk: function () {
            this._isUndo = false, this._isUndoRedo = false;
            this._delCells = [];
            this._deletedText = [];
            this._removeMergeColl = [];
            this._deletedDimension = [];
            var text, selIdx, sheetIdx = this.getActiveSheetIndex(),
                startCell = this.model.sheets[sheetIdx]._selectedCells[0], endCell = this.model.sheets[sheetIdx]._selectedCells[this.model.sheets[sheetIdx]._selectedCells.length - 1];
            if (this._insDelStatus.indexOf("insert") > -1) {
                text = ["ShiftRight", "ShiftBottom", "EntireRow", "EntireColumn"];
                selIdx = this._getSelectedOption(text);
                if (text[selIdx].indexOf("ShiftRight") > -1)
                    this.insertShiftRight(startCell, endCell);
                else if (text[selIdx].indexOf("ShiftBottom") > -1)
                    this.insertShiftBottom(startCell, endCell);
                else if (text[selIdx].indexOf("EntireRow") > -1)
                    this.insertEntireRow(startCell.rowIndex, endCell.rowIndex);
                else
                    this.insertEntireColumn(startCell.colIndex, endCell.colIndex);
            }
            else {
                text = ["ShiftLeft", "ShiftUp", "EntireRow", "EntireColumn"];
                selIdx = this._getSelectedOption(text);
                if (text[selIdx].indexOf("ShiftLeft") > -1)
                    this.deleteShiftLeft(startCell, endCell);
                else if (text[selIdx].indexOf("ShiftUp") > -1)
                    this.deleteShiftUp(startCell, endCell);
                else if (text[selIdx].indexOf("EntireRow") > -1)
                    this.deleteEntireRow(startCell.rowIndex, endCell.rowIndex);
                else
                    this.deleteEntireColumn(startCell.colIndex, endCell.colIndex);
            }
            $("#" + this._id + "_insertdeletedlg").ejDialog("close");
            var sheetChart = this.model.sheets[this.model.activeSheetIndex].shapeMngr.chart;
            for (var i = 0; i < sheetChart.length; i++)
                this.XLChart._refreshChart(sheetChart[i]);
        },

        _insertDeleteCancel: function () {
            $("#" + this._id + "_insertdeletedlg").ejDialog("close");
        },

        _undoredoDetails: function (sheetIndex, startCell, endCell, reqType, action) {
            var details = { sheetIndex: sheetIndex, startCell: startCell, endCell: endCell, reqType: reqType, action: action, delCells: $.extend(true, [], this._delCells), text: this._deletedText, deletedDimension: this._deletedDimension, removeMerge: this._removeMergeColl, fRow: $.extend(true, {}, this._fRow), fCol: $.extend(true, {}, this._fCol) };
            if (!this.isImport && !this._isExport && !this._intrnlReq) {
                this._completeAction(details);
                this._trigActionComplete(details);
            }
            this._removeMergeColl = [];
            this._delCells = [];
            this._fRow.fRowCnt = 0;
            this._fCol.fColCnt = 0;
            this._fRow.rowAdj = true;
            this._fCol.colAdj = true;
        },

        _getRangeFrmFormula: function (formula) {
            var pAlpha = formula.substring(formula.indexOf("(") + 1, formula.indexOf(")")), regx = new RegExp('^\\b[a-zA-Z][0-9]*:[a-zA-Z][0-9]*\\b$', 'g');
            if (regx.test(pAlpha))
                return pAlpha;
            else if (pAlpha.indexOf(',') > 1)
                if (regx.test(pAlpha.split(',')[1]))
                    return pAlpha.split(',')[1];
                else if (regx.test(pAlpha.replace(',', ':')))
                    return pAlpha.replace(',', ':');
        },

        _refreshFormula: function (rowIdx, colIdx, count, status, type, startIdx, isShift) {
            var sheetIdx = this.getActiveSheetIndex(), diff, diff1, val = this.XLEdit.getPropertyValue(rowIdx, colIdx, "value"), pAlpha, nAlpha, range, cellArgs, actSheet = this.getSheet(sheetIdx), deleteIdxs = [], i, splitFormula, fArg, ridx, hasREFVal = false;
            if (this._isUndo && (this._formulaChanged.pop() === "true"))
                return;
            if (this.isFormula(val)) {
                if (status === "delete") {
                    for (i = 1; i <= count; i++)
                        deleteIdxs.push(startIdx + i);
                }
                splitFormula = this.XLDragFill._parseFormula(val);
                for (i = 0; i < splitFormula.length; i++) {
                    fArg = splitFormula[i].trim();
                    if (this._isCellReference(fArg)) {
                        range = this.getRangeIndices(fArg);
                        diff = (type === "column") ? (status === "insert") ? range[3] + count : range[3] - count : (status === "insert") ? range[2] + count : range[2] - count;
                        diff1 = (type === "column") ? (status === "insert") ? range[1] + count : range[1] - count : (status === "insert") ? range[0] + count : range[0] - count;
                        (type === "column") ? (startIdx > range[1] && (diff1 = range[1])) : (startIdx > range[0] && (diff1 = range[0]));
                        (type === "column") ? (startIdx > range[3] && (diff = range[3])) : (startIdx > range[2] && (diff = range[2]));
                        if (diff1 > -1)
                            nAlpha = (type === "column") ? this._getAlphaRange(sheetIdx, range[0], diff1, range[2], diff) : this._getAlphaRange(sheetIdx, diff1, range[1], diff, range[3]);
                        else {
                            nAlpha = "#REF!";
                            hasREFVal = true;
                        }
                        if (status === "delete") {
                            ridx = parseInt(type === "row" ? fArg.replace(/[A-Z]/g, "") : this._generateColCount(fArg.replace(/[0-9]/g, "")));
                            if (deleteIdxs.indexOf(ridx) > -1) {
                                nAlpha = "#REF!";
                                hasREFVal = true;
                            }
                        }
                        splitFormula[i] = nAlpha;
                    }
                    else if (fArg == "#REF!")
                        hasREFVal = true;
                }
                if (hasREFVal && !this._isUndo)
                    this._ref.push(val);
                val = (hasREFVal && this._isUndo) ? this._ref.pop() : "=" + splitFormula.join('');
                val = this.XLEdit._parseSheetRef(val);
                cellArgs = new ValueChangedArgs(rowIdx + 1, colIdx + 1, val);
                this._calcEngine.valueChanged(actSheet.sheetInfo.value, cellArgs);
                this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: colIdx }, { dataObj: { value: val } });
                this._applyFormula(sheetIdx, rowIdx, colIdx);
                !this._isUndo && ((pAlpha === nAlpha) ? this._formulaChanged.push("true") : this._formulaChanged.push("false"));
                return true;
            }
        },

        _applyFormula: function (sheetIdx, rowIdx, colIdx) {
            var formulaColl, sheet = this.getSheet(sheetIdx), rowColl = sheet._formulaCollection[rowIdx];
            if (ej.isNullOrUndefined(rowColl))
                sheet._formulaCollection[rowIdx] = {};
		    sheet._formulaCollection[rowIdx][colIdx] = this._calcEngine.getFormulaInfoTable().getItem(this._calcEngine.cell);
        },

        _clearFormula: function (i, j) {
            var formulaInfo, formulaIdx, formulaColl, calcEngine = this.getCalcEngine(), sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), val = this.XLEdit.getPropertyValue(i, j, "value");
            if (this.isFormula(val)) {
                //clear formula for the particular cell
                formulaInfo = sheet._formulaCollection[i][j];
                formulaColl = calcEngine.getFormulaInfoTable().values();
                formulaIdx = formulaColl.indexOf(formulaInfo);
                cellRef = calcEngine.getFormulaInfoTable().keys()[formulaIdx];
                formulaColl.splice(formulaIdx, 1);
                calcEngine.getFormulaInfoTable().remove(cellRef);
                calcEngine.clearFormulaDependentCells(cellRef);
                delete sheet._formulaCollection[i][j];
            }
        },

        _refreshValAndCF: function (i, j, vRule, cRule, rCount, cCount, action) {
            var cFormatRule, sheetIdx = this.getActiveSheetIndex(), container = this._dataContainer.sheets[sheetIdx], cFormatData = this._dataContainer.cFormatData, rule,
                oldRng, newRng, rngIndices, dupRuleIdx, dupRule;
            if (this.isUndefined(vRule) && this.isUndefined(cRule))
                delete container[i][j];
            else {
                if (!this.isUndefined(vRule))
                    container[i][j] = { rule: vRule };
                if (!this.isUndefined(cRule)) {
                    cFormatRule = cFormatData[cRule[0]];
                    if (cFormatRule.indexOf("true") > -1) {
                        dupRule = cFormatRule.replace("true", "false");
                        dupRuleIdx = cFormatData.indexOf();
                    }
                    else {
                        dupRule = cFormatRule.replace("false", "true");
                        dupRuleIdx = cFormatData.indexOf(dupRule);
                    }
                    oldRng = cFormatRule.split("_")[5];
                    rngIndices = this.getRangeIndices(oldRng);
                    if (action.indexOf("Bottom") > -1 || action.indexOf("Row") > -1)
                        rngIndices[2] = rngIndices[2] + rCount;
                    else
                        rngIndices[3] = rngIndices[3] + cCount;
                    newRng = this._getAlphaRange(sheetIdx, rngIndices[0], rngIndices[1], rngIndices[2],rngIndices[3])
                    cFormatRule = cFormatRule.replace(oldRng, newRng);
                    dupRule = dupRule.replace(oldRng, newRng);
                    cFormatData[cRule[0]] = cFormatRule;
                    cFormatData[dupRuleIdx] = dupRule;
                    rule = cFormatRule.replace("true", "false");
                    if (cFormatData.indexOf(rule) < 0)
                        cFormatData.push(rule);
                    container[i][j] = { cFormatRule: [cFormatData.indexOf(rule)] };
                }
            }
        },

        _refreshRows: function (sheetIdx) {
            var rowhdrrows = this._getRowHdrTBody(sheetIdx).find("tr"), contentrows = this._getContTBody(sheetIdx).find("tr");
            this.setRows([rowhdrrows, contentrows], sheetIdx);
        },

        _refreshFilterColl: function (sheetIdx, stIdx, count, operation, action) {
            var colDiff, i, j, sheet = this.getSheet(sheetIdx), filterColl = sheet._filterColl, fCollKeys = this.getObjectKeys(filterColl), fCollCKeys, filterVal, delIdx, addIdx;
            if (operation === "row") {
                if (action === "insert") {
                    for (var rIdx = fCollKeys.length - 1; rIdx >= 0; rIdx--) {
                        i = parseInt(fCollKeys[rIdx]);
                        if (i >= stIdx) {
                            sheet._filterColl[i + count] = $.extend(true, {}, sheet._filterColl[i]);
                            delete sheet._filterColl[i];
                        }
                    }
                }
                else {
                    for (var rIdx = 0; rIdx < fCollKeys.length; rIdx++) {
                        i = parseInt(fCollKeys[rIdx]);
                        if (i >= stIdx) {
                            sheet._filterColl[i - count] = $.extend(true, {}, sheet._filterColl[i]);
                            delete sheet._filterColl[i];
                        }
                    }
                }
            }
            else {
				var isInside, isSameTable = false, isVScroll = this.model.scrollSettings.allowVirtualScrolling;
                for (var rIdx = 0 ; rIdx < fCollKeys.length; rIdx++) {
                    i = parseInt(fCollKeys[rIdx]);
					fCollCKeys = this.getObjectKeys(sheet._filterColl[i]);
					if (action === "insert") {
						isInside = false;
                        for (var cIdx = fCollCKeys.length - 1; cIdx >= 0; cIdx--) {
							colDiff = fCollCKeys[cIdx] - fCollCKeys[cIdx - ((cIdx === 0) ? 0 : 1)];
							if(colDiff === 1 || colDiff === 0)
								isSameTable = true;
							else
								isSameTable = false;
                            j = parseInt(fCollCKeys[cIdx]);
							if (j >= stIdx || isInside) {
								isInside = true;
                                filterVal = sheet._filterColl[i][j];
                                if (filterVal.status.indexOf("filtered") > -1) {
                                    delIdx = $.inArray(this._generateHeaderText(j + 1), sheet._filteredColumns);
                                    if (delIdx > -1)
                                        sheet._filteredColumns.splice(delIdx, 1);
                                    addIdx = $.inArray(this._generateHeaderText(j + count + 1), sheet._filteredColumns);
                                    if (addIdx < 0)
                                        sheet._filteredColumns.push(this._generateHeaderText(j + count + 1));
                                }
                                sheet._filterColl[i][j + count] = $.extend(true, {}, sheet._filterColl[i][j]);
                                if(!isVScroll && !this._isUndoRedo) 
									delete sheet._filterColl[i][j];
								else {
									if(isSameTable) {
										sheet._filterColl[i][j].status = "e-ssfilter";
										this.XLEdit._updateDataContainer({ rowIndex: i, colIndex: j }, { dataObj: { isFilterHeader: true, filterState: "filter", isFilterVisible: true }, sheetIdx: sheetIdx })
									}
									else
										delete sheet._filterColl[i][j];
								}
								if(!isSameTable)
									isInside = false;
                            }
                        }
                    }
                    else {
                        for (var cIdx = 0; cIdx < fCollCKeys.length; cIdx++) {
                            j = parseInt(fCollCKeys[cIdx]);
                            if (j >= stIdx) {
                                filterVal = sheet._filterColl[i][j];
                                if (filterVal.status.indexOf("filtered") > -1) {
                                    delIdx = $.inArray(this._generateHeaderText(j + 1), sheet._filteredColumns);
                                    if (delIdx > -1)
                                        sheet._filteredColumns.splice(delIdx, 1);
                                    addIdx = $.inArray(this._generateHeaderText(j - count + 1), sheet._filteredColumns);
                                    if (addIdx < 0)
                                        sheet._filteredColumns.push(this._generateHeaderText(j - count + 1));
                                }
                                (j - count >= 0) && (sheet._filterColl[i][j - count] = $.extend(true, {}, sheet._filterColl[i][j]));
                                delete sheet._filterColl[i][j];
                            }
                        }
                    }
                }
            }
        },

        _refreshDataContainer: function (sIdx, value) {
            var stRow, enRow, stCol, enCol, vRule, cRule, i, j, k, len, ln, currText, remText, maxCol = 0, lt = 0, nContainer, maxRow, freezeRow, freezeCol, topIdx, leftIdx, hiddenHgt = 0, hiddenWth = 0, container = this._dataContainer.sheets[sIdx], cCount, rCount, sCol, remCells, rmColl, columns, count, picture, chart, index,
                isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, sheet = this.getSheet(sIdx), usedRange = sheet.usedRange, fRowIdx = this.getFrozenRows(), fColIdx = this.getFrozenColumns(), currCell, remCell, currTxt, remTxt, isFormula;
            maxRow = parseInt(this.getObjectKeys(container)[this.getObjectLength(container) - 1]), rowHtColl = sheet.rowsHeightCollection, colWtColl = sheet.columnsWidthCollection;
            for (i = 0; i <= maxRow; i++) {
                if (!ej.isNullOrUndefined(container[i])) {
                    nContainer = this.getObjectKeys(container[i]);
                    lt = parseInt(nContainer[nContainer.length - 1]);
                    (lt > maxCol) && (maxCol = lt);
                }
            }
            sCol = (value.startCol <= maxCol) ? value.colCount + value.startCol : maxCol - 1;
            cCount = (value.status.indexOf("shift") > -1) ? sCol : maxCol - 1;
            rCount = (value.status.indexOf("shift") > -1) ? value.rowCount + value.startRow : maxRow;
            stRow = value.startRow; enRow = (value.startRow + value.rowCount) - 1;
            stCol = value.startCol; enCol = (value.startCol + value.colCount) - 1;
            if (this._isFrozen(fRowIdx - 1) && fRowIdx > stRow) {
                for (i = sheet._frozenRows - 1; i < sheet._ftopRowIdx; i++)
                    hiddenHgt += sheet.rowsHeightCollection[i];
                this._scrollContent({ y: -hiddenHgt });
            }
            if (this._isFrozen(fColIdx - 1) && fColIdx > stCol) {
                for (i = sheet._frozenColumns - 1; i < sheet._fleftColIdx; i++)
                    hiddenWth += sheet.columnsWidthCollection[i];
                this._scrollContent({ x: -hiddenWth });
            }
            switch (value.status) {
                case "insertRow":
                    for (i = maxRow, len = value.startRow; i >= len; i--) {
                        if (!ej.isNullOrUndefined(container[i])) {
                            container[i + value.rowCount] = $.extend(true, {}, container[i]);
                            if (!ej.isNullOrUndefined(container[i + value.rowCount])) {
                                columns = this.getObjectKeys(container[i + value.rowCount]);
                                for (j = 0, ln = columns.length; j < ln; j++) {
                                    this._clearFormula(i, columns[j]);
                                    //refresh Validation
                                    if (this._checkIndicesInContainer(sIdx, i, columns[j], "wrap")) {
                                        this._wrapCollection(i + value.rowCount, columns[j], sheet._wrapColl[i][columns[j]], sIdx);
                                        delete sheet._wrapColl[i][columns[j]];
                                    }
                                    if (i >= stRow && i <= enRow) {
                                        vRule = this._checkIndicesInContainer(sIdx, stRow, columns[j], "rule") ? (this._dataContainer.sheets[sIdx][stRow][columns[j]]["rule"]) : undefined;
                                        cRule = this._checkIndicesInContainer(sIdx, stRow, columns[j], "cFormatRule") ? (this._dataContainer.sheets[sIdx][stRow][columns[j]]["cFormatRule"]) : undefined;
                                        this._refreshValAndCF(i, columns[j], vRule, cRule, value.rowCount, 0, value.status);
                                        if (!isVirtualScroll)
                                            !(stRow < 1) && this.addClass(this.getCell(i, columns[j])[0], this.XLFormat.getFormatClass(this.getCell(stRow - 1, columns[j])[0].className, false));
                                    }
                                    else
                                        delete container[i][columns[j]];
									if(this.model.allowSparkline)
										this.XLSparkline._refreshSparklineForInsDel(i + value.rowCount, parseInt(columns[j]), value.rowCount, "row", "insert", sIdx );
                                    isFormula = this._refreshFormula(i + value.rowCount, parseInt(columns[j]), value.rowCount, "insert", "row", value.startRow, false);
                                    !isFormula && this.XLEdit._refreshCalcEngine(i + value.rowCount, parseInt(columns[j]));
                                }
                            }
                            (this.getObjectLength(container[i]) < 1) && delete container[i];
                        }
                        rowHtColl[i + value.rowCount] = rowHtColl[i];
                        rowHtColl[i] = this.model.rowHeight;
                        sheet._rowIdxColl[i + value.rowCount] = sheet._rowIdxColl[i] + value.rowCount;
                    }
                    this._refreshHideRowColCollection(sheet.hideRowsCollection, value.startRow, value.rowCount, "row", "insert")
                    this._refreshFilterColl(sIdx, value.startRow, value.rowCount, "row", "insert");
                    if (this._isUndo && this._delCells.length > 0) {
                        remCells = this._delCells;
                        count = remCells[remCells.length - 1].row - remCells[0].row;
                        for (i = 0, len = remCells.length; i < len; i++) {
                            container[remCells[i].row] = remCells[i].value;
                            columns = this.getObjectKeys(container[remCells[i].row]);
                            for (j = 0, ln = columns.length; j < ln; j++) {
                                this._refreshFormula(remCells[i].row, parseInt(columns[j]), count, "insert", "row", "", false);
                                this.XLEdit._refreshCalcEngine(remCells[i].row, parseInt(columns[j]));
                                if (this._checkIndicesInContainer(sIdx, remCells[i].row, columns[j], "wrap"))
                                    this._wrapCollection(remCells[i].row, columns[j], this._delWrapColl[remCells[i].row][columns[j]], sIdx);
                            }
                            rowHtColl[remCells[i].row] = remCells[i].height;
                        }
                        this._delWrapColl = {};
                    }
                    if (this.model.allowFreezing && this._isFrozen(fRowIdx) && (stRow < fRowIdx || (this._isUndo && this._fRow.fRowCnt > 0))) {
                        freezeRow = sheet.frozenRows + ((this._fRow.fRowCnt > 0) ? this._fRow.fRowCnt : value.rowCount);
                        freezeCol = sheet.frozenColumns;
                        this._fRow.fRowCnt = 0;
                        if (!this._fRow.rowAdj) {
                            freezeRow -= 1;
                            this._fRow.rowAdj = !this._fRow.rowAdj;
                        }
                        if (this._isFrozen(fColIdx)) {
                            this.XLFreeze.unfreezePanes();
                            this.XLFreeze.freezePanes(freezeRow, freezeCol);
                        }
                        else
                            this.XLFreeze.freezeRows(freezeRow);
                    }
                    this.XLScroll._getRowHeights(sIdx, value.startRow);
                    break;
                case "insertColumn":
                    var isDeletCol = false;
                    for (i = 0 ; i <= rCount; i++) {
                        for (j = maxCol, len = value.startCol; j >= len ; j--) {
                            picture = chart = null;
                            if (i == 0) {
                                if (!ej.isNullOrUndefined(container[0])) {
                                    if (!ej.isNullOrUndefined(container[0][j])) {
                                        if ("isCHide" in container[0][j]) {
                                            this._deleteRule(j, sIdx);
                                            isDeletCol = true;
                                        }
                                    }
                                }
                            }
                            if (!ej.isNullOrUndefined(container[i])) {
                                if (!ej.isNullOrUndefined(container[i][j])) {
                                    if (!ej.isNullOrUndefined(container[i][j + value.colCount])) {
                                        if (!ej.isNullOrUndefined(container[i][j + value.colCount].picture))
                                            picture = container[i][j + value.colCount].picture;
                                        if (!ej.isNullOrUndefined(container[i][j + value.colCount].chart))
                                            chart = container[i][j + value.colCount].chart;
                                    }
                                    container[i][j + value.colCount] = container[i][j];
                                    if (!ej.isNullOrUndefined(container[i][j].picture) || !ej.isNullOrUndefined(container[i][j].chart)) {
                                        if (!ej.isNullOrUndefined(container[i][j].picture))
                                            picture = container[i][j].picture;
                                        if (!ej.isNullOrUndefined(container[i][j].chart))
                                            chart = container[i][j].chart;
                                    }
                                    if (!ej.isNullOrUndefined(container[i][j + value.colCount])) {
                                        if (!ej.isNullOrUndefined(picture))
                                            container[i][j + value.colCount].picture = picture;
                                        if (!ej.isNullOrUndefined(chart))
                                            container[i][j + value.colCount].chart = chart;
                                    }
                                    if (container[i][j].wrap) {
                                        this._wrapCollection(i, j + value.colCount, sheet._wrapColl[i][j], sIdx);
                                        delete sheet._wrapColl[i][j];
                                    }
                                }
                                this._clearFormula(i, j);
                                //refresh Validation
                                if (j >= stCol && j <= enCol) {
                                    vRule = this._checkIndicesInContainer(sIdx, i, stCol, "rule") ? (this._dataContainer.sheets[sIdx][i][stCol]["rule"]) : undefined;
                                    cRule = this._checkIndicesInContainer(sIdx, i, stCol, "cFormatRule") ? (this._dataContainer.sheets[sIdx][i][stCol]["cFormatRule"]) : undefined;
                                    this._refreshValAndCF(i, j, vRule, cRule, 0, value.colCount, value.status);
                                    if (!isVirtualScroll)
                                        (!stCol < 1) && this.addClass(this.getCell(i, j)[0], this.XLFormat.getFormatClass(this.getCell(i, stCol - 1)[0].className, false));
                                }
                                else
                                    delete container[i][j];
                                if (ej.isNullOrUndefined(container[i][j]) && (!ej.isNullOrUndefined(picture) || !ej.isNullOrUndefined(chart)))
                                    container[i][j] = {};
                                if (!ej.isNullOrUndefined(picture))
                                    container[i][j].picture = picture;
                                if (!ej.isNullOrUndefined(chart))
                                    container[i][j].chart = chart;
								if(this.model.allowSparkline)
									this.XLSparkline._refreshSparklineForInsDel(i, j + value.colCount, value.colCount, "column", "insert", sIdx );
                                isFormula = this._refreshFormula(i, j + value.colCount, value.colCount, "insert", "column", value.startCol, false);
                                !isFormula && this.XLEdit._refreshCalcEngine(i, j + value.colCount);
                            }
                            if (i === 0) {
                                if (isDeletCol) {
                                    this._writeRule(j + value.colCount, sIdx);
                                    isDeletCol = false;
                                }
                                if (isVirtualScroll && !this._isUndoRedo) {
                                    colWtColl[j + value.colCount] = colWtColl[j];
                                    colWtColl[j] = sheet.columnWidth;
                                }
                            }
                        }
                    }
                    this._refreshHideRowColCollection(sheet.hideColsCollection, value.startCol, value.colCount, "column", "insert")
                    this._refreshFilterColl(sIdx, value.startCol, value.colCount, "column", "insert");
                    if (this.model.allowFreezing && this._isFrozen(fColIdx) && (stCol < fColIdx || (this._isUndo && this._fCol.fColCnt > 0))) {
                        freezeRow = sheet.frozenRows;
                        freezeCol = sheet.frozenColumns + (this._fCol.fColCnt > 0 ? this._fCol.fColCnt : value.colCount);
                        this._fCol.fColCnt = 0;
                        if (!this._fCol.colAdj) {
                            freezeCol -= 1;
                            this._fCol.colAdj = !this._fCol.colAdj;
                        }
                        if (this._isFrozen(fRowIdx)) {
                            this.XLFreeze.unfreezePanes();
                            this.XLFreeze.freezePanes(freezeRow, freezeCol);
                        }
                        else
                            this.XLFreeze.freezeColumns(freezeCol);
                    }
                    if (this._isUndo && this._delCells.length > 0) {
                        remCells = this._delCells;
                        count = remCells[remCells.length - 1].col - remCells[0].col;
                        for (k = 0, len = remCells.length; k < len; k++) {
                            if (ej.isNullOrUndefined(container[remCells[k].row]))
                                container[remCells[k].row] = {};
                            container[remCells[k].row][remCells[k].col] = remCells[k].value;
                            this._refreshFormula(remCells[k].row, remCells[k].col, count, "insert", "column", "", false);
                            this.XLEdit._refreshCalcEngine(remCells[k].row, remCells[k].col);
                            if (remCells[k].value.wrap)
                                this._wrapCollection(remCells[k].row, remCells[k].col, remCells[k].height, sIdx);
                        }
                    }
                    break;
                case "deleteRow":
                    this._delCells = [];
                    rmColl = [];
                    for (i = 0; i < value.startRow; i++) {
                        columns = this.getObjectKeys(container[i]);
                        for (j = 0, len = columns.length; j < len; j++) {
                            isFormula = this._refreshFormula(i, parseInt(columns[j]), value.rowCount, "delete", "row", value.startRow, false);
                            !isFormula && this.XLEdit._refreshCalcEngine(i, parseInt(columns[j]));
                        }
                    }
                    for (i = value.startRow; i <= maxRow; i++) {
                        if (i < (value.startRow + value.rowCount)) {
                            this._delCells.push({ row: i, value: $.extend(true, {}, container[i]), height: rowHtColl[i] });
                            if (!ej.isNullOrUndefined(container[i])) {
                                columns = this.getObjectKeys(container[i]);
                                for (j = 0, len = columns.length; j < len; j++) {
                                    if (this._checkIndicesInContainer(sIdx, i, columns[j], "wrap")) {
                                        if (!this._delWrapColl[i])
                                            this._delWrapColl[i] = {};
                                        this._delWrapColl[i][columns[j]] = $.extend(true, {}, sheet._wrapColl[i][columns[j]]);
                                        delete sheet._wrapColl[i][columns[j]];
                                    }
                                    container[i][columns[j]] = {};
                                }
                            }
                            container[i] = {};
                            rmColl.push({ row: i });
                        }
                        if (!ej.isNullOrUndefined(container[i + value.rowCount])) {
                            container[i] = $.extend(true, {}, container[i + value.rowCount]);
                            columns = this.getObjectKeys(container[i]);
                            for (j = 0, len = columns.length; j < len; j++) {
                                if (this._checkIndicesInContainer(sIdx, i + value.rowCount, columns[j], "wrap")) {
                                    this._wrapCollection(i, columns[j], sheet._wrapColl[i + value.rowCount][columns[j]], sIdx);
                                    delete sheet._wrapColl[i + value.rowCount][columns[j]];
                                }
                                this._clearFormula(i + value.rowCount, columns[j]);
                                container[i + value.rowCount][columns[j]] = {};
								if(this.model.allowSparkline)
									this.XLSparkline._refreshSparklineForInsDel(i, columns[j], value.rowCount, "row", "delete", sIdx );
                                isFormula = this._refreshFormula(i, parseInt(columns[j]), value.rowCount, "delete", "row", value.startRow, false);
                                !isFormula && this.XLEdit._refreshCalcEngine(i, parseInt(columns[j]));
                            }
                            container[i + value.rowCount] = {};
                            rmColl.push({ row: i + value.rowCount });
                        }
                        if (!this.isUndefined(rowHtColl[i + value.rowCount])) {
                            rowHtColl[i] = rowHtColl[i + value.rowCount];
                            rowHtColl[i + value.rowCount] = this.model.rowHeight;
                            sheet._rowIdxColl[i] = sheet._rowIdxColl[i + value.rowCount] - value.rowCount;
                        }
                    }
                    if (this.model.scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Normal) {
                        rowHtColl.splice(rowHtColl.length - value.rowCount, value.rowCount);
                        sheet._rowHeightCollection.splice(sheet._rowHeightCollection.length - value.rowCount, value.rowCount);
                    }
                    this._refreshHideRowColCollection(sheet.hideRowsCollection, value.startRow, value.rowCount, "row", "delete")
                    for (k = 0, len = rmColl.length; k < len; k++) {
                        if (this.getObjectLength(container[rmColl[k].row]) === 0) {
                            this._clearFormula(rmColl[k].row, rmColl[k].col);
                            delete container[rmColl[k].row];
                        }
                    }
                    this._refreshFilterColl(sIdx, value.startRow, value.rowCount, "row", "delete");
                    this.XLScroll._getRowHeights(sIdx, value.startRow);
                    if (this.model.allowFreezing && this._isFrozen(fRowIdx) && stRow < fRowIdx ) {
                        if (enRow >= fRowIdx )
                            for (var i = stRow; i < fRowIdx ; i++)
                                this._fRow.fRowCnt++;
                        else
                            this._fRow.fRowCnt = 0;
                        freezeRow = sheet.frozenRows - ((this._fRow.fRowCnt > 0) ? this._fRow.fRowCnt : value.rowCount);
                        topIdx = sheet.frozenRows - ((this._fRow.fRowCnt > 0) ? this._fRow.fRowCnt : value.rowCount) - sheet._topRow.idx;
                        freezeCol = sheet.frozenColumns;
                        this._fRow.rowAdj = topIdx > 1;
                        if (this._isFrozen(fColIdx )) {
                            this.XLFreeze.unfreezePanes();
                            this.XLFreeze.freezePanes(this._fRow.rowAdj ? freezeRow : freezeRow + 1, freezeCol);
                        }
                        else
                            this.XLFreeze.freezeRows(this._fRow.rowAdj ? freezeRow : 1);
                    }
                    break;
                case "deleteColumn":
                    this._delCells = [];
                    rmColl = [];
                    var isDeleteCol = false, dupContainer = $.extend(true, {}, container[0]);
                    for (i = 0 ; i <= rCount; i++) {
                        for (j = value.startCol; j <= maxCol; j++) {
                            picture = chart = null;
                            if (i == 0) {
                                if (!ej.isNullOrUndefined(dupContainer)) {
                                    if (!ej.isNullOrUndefined(dupContainer[j])) {
                                        if ("isCHide" in dupContainer[j]) {
                                            this._deleteRule(j, sIdx);
                                            isDeleteCol = true;
                                        }
                                    }
                                }
                            }
                            if (j < (value.startCol + value.colCount)) {
                                if (!ej.isNullOrUndefined(container[i])) {
                                    if (!ej.isNullOrUndefined(container[i][j])) {
                                        this._delCells.push({ row: i, col: j, value: $.extend(true, {}, container[i][j], container[i][j].wrap ? sheet._wrapColl[i][j] : rowHtColl[i]) });
                                        this._clearFormula(i, j);
                                        container[i][j] = {};
                                        if (!ej.isNullOrUndefined(this._delCells[this._delCells.length - 1])) {
                                            index = this._delCells.length - 1;
                                            if (!ej.isNullOrUndefined(this._delCells[index].value.picture))
                                                container[i][j].picture = this._delCells[index].value.picture;
                                            if (!ej.isNullOrUndefined(this._delCells[index].value.chart))
                                                container[i][j].chart = this._delCells[index].value.chart;
                                        }
                                        rmColl.push({ row: i, col: j });
                                        if (sheet._wrapColl[i])
                                            delete sheet._wrapColl[i][j];
                                    }
                                }
                            }							
                            if (!ej.isNullOrUndefined(container[i]) && (!ej.isNullOrUndefined(container[i][j + value.colCount]))) {
                                container[i][j] = $.extend(true, {}, container[i][j + value.colCount]);
                                if (container[i][j + value.colCount].wrap) {
                                    this._wrapCollection(i, j, sheet._wrapColl[i][j + value.colCount], sIdx);
                                    delete sheet._wrapColl[i][j + value.colCount];
                                }
                                if (!ej.isNullOrUndefined(container[i][j + value.colCount].picture))
                                    picture = container[i][j + value.colCount].picture;
                                if (!ej.isNullOrUndefined(container[i][j + value.colCount].chart))
                                    chart = container[i][j + value.colCount].chart;
                                this._clearFormula(i, j + value.colCount);
                                container[i][j + value.colCount] = {};
                                if (!ej.isNullOrUndefined(picture))
                                    container[i][j + value.colCount].picture = picture;
                                if (!ej.isNullOrUndefined(chart))
                                    container[i][j + value.colCount].chart = chart
                                if (!ej.isNullOrUndefined(this._delCells[this._delCells.length - 1])) {
                                    index = this._delCells.length - 1;
                                    if (!ej.isNullOrUndefined(this._delCells[index].value.picture))
                                        container[i][j].picture = this._delCells[index].value.picture;
                                    if (!ej.isNullOrUndefined(this._delCells[index].value.chart))
                                        container[i][j].chart = this._delCells[index].value.chart;
                                }
                                rmColl.push({ row: i, col: j + value.colCount });
                                isFormula = this._refreshFormula(i, j, value.colCount, "delete", "column", value.startCol, false);
                                !isFormula && this.XLEdit._refreshCalcEngine(i, j);
                                if (!isVirtualScroll)
                                    if(this.XLComment) {
										if(this._isRowViewable(sIdx, i))
											this._removeClass(this.getCell(i, j), "e-commentcell");
										this.XLComment._updateCmntFrmCntnr(i, j);
									}
                            }
							if(this.model.allowSparkline)
								this.XLSparkline._refreshSparklineForInsDel(i, j, value.colCount, "column", "delete", sIdx );
                            if (i == 0) {
                                if (isDeleteCol) {
                                    this._writeRule(j - value.colCount, sIdx);
                                    isDeleteCol = false;
                                }
                            }
                        }
                        for (k = 0, len = rmColl.length; k < len; k++)
                            if (this.getObjectLength(container[rmColl[k].row][rmColl[k].col]) === 0) {
                                this._clearFormula(rmColl[k].row, rmColl[k].col);
                                delete container[rmColl[k].row][rmColl[k].col];
                            }
                        rmColl = [];
                    }
                    this._refreshHideRowColCollection(sheet.hideColsCollection, value.startCol, value.colCount, "column", "delete")
                    if (this.model.allowFreezing && this._isFrozen(fColIdx) && stCol < fColIdx) {
                        if (enCol >= fColIdx )
                            for (var i = stCol; i < fColIdx ; i++)
                                this._fCol.fColCnt++;
                        else
                            this._fCol.fColCnt = 0;
                        freezeRow = sheet.frozenRows;
                        freezeCol = sheet.frozenColumns - (this._fCol.fColCnt > 0 ? this._fCol.fColCnt : value.colCount);
                        leftIdx = sheet.frozenColumns - (this._fCol.fColCnt > 0 ? this._fCol.fColCnt : value.colCount) - sheet._leftCol.idx;
                        this._fCol.colAdj = leftIdx > 1;
                        if (this._isFrozen(fRowIdx )) {
                            this.XLFreeze.unfreezePanes();
                            this.XLFreeze.freezePanes(freezeRow, this._fCol.colAdj ? freezeCol : freezeCol + 1);
                        }
                        else
                            this.XLFreeze.freezeColumns(this._fCol.colAdj ? freezeCol : 1);
                    }
                    this._refreshFilterColl(sIdx, value.startCol, value.colCount, "column", "delete");
                    break;
                case "shiftRight":
                    var cValue;
                    for (i = value.startRow ; i < rCount; i++) {
                        for (j = maxCol, len = value.startCol; j >= len ; j--) {
                            if (!ej.isNullOrUndefined(container[i])) {
                                if (!ej.isNullOrUndefined(container[i][j])) {
                                    container[i][j + value.colCount] = $.extend(true, {}, container[i][j]);
                                    if (container[i][j].wrap) {
                                        this._wrapCollection(i, j + value.colCount, sheet._wrapColl[i][j], sIdx);
                                        delete sheet._wrapColl[i][j];
                                    }
                                    this._clearFormula(i, j);
                                    //refresh Validation
                                    if (j >= stCol && j <= enCol) {
                                        this._checkIndicesInContainer(sIdx, i, stCol, "rule") && (vRule = this._dataContainer.sheets[sIdx][i][stCol]["rule"]);
                                        this._checkIndicesInContainer(sIdx, i, stCol, "cFormatRule") && (cRule = this._dataContainer.sheets[sIdx][i][stCol]["cFormatRule"]);
                                        this._refreshValAndCF(i, j, vRule, cRule, 0, value.colCount, value.status);
                                        !(stCol < 1) && this.addClass(this.getCell(i, j)[0], this.XLFormat.getFormatClass(this.getCell(i, stCol - 1)[0].className, false));
                                    }
                                    else
                                        delete container[i][j];
                                    isFormula = this._refreshFormula(i, j + value.colCount, value.colCount, "insert", "column", value.startCol, true);
                                    !isFormula && this.XLEdit._refreshCalcEngine(i, j + value.colCount);
                                    !isFormula && this.XLEdit._refreshCalcEngine(i, j);
									if(this.model.allowSparkline)
										this.XLSparkline._refreshSparklineForInsDel(i, j + value.colCount, value.colCount, "column", "insert", sIdx );
                                }
                            }
                        }
                    }
                    if (this._isUndo && this._delCells.length > 0) {
                        remCells = this._delCells;
                        count = remCells[remCells.length - 1].col - remCells[0].col;
                        for (k = 0, len = remCells.length; k < len; k++) {
                            container[remCells[k].row][remCells[k].col] = remCells[k].value;
                            this._refreshFormula(remCells[k].row, remCells[k].col, count, "insert", "column", value.startRow, false);
                            this.XLEdit._refreshCalcEngine(remCells[k].row, remCells[k].col);
                            if (!isVirtualScroll)
                                this.XLComment && this.XLComment._updateCmntFrmCntnr(remCells[k].row, remCells[k].col);
                            if (remCells[k].value.wrap)
                                this._wrapCollection(remCells[k].row, remCells[k].col, remCells[k].height, sIdx);
                        }
                    }
                    break;
                case "shiftLeft":
                    this._delCells = [];
                    rmColl = [];
                    for (i = value.startRow ; i < rCount; i++) {
                        for (j = value.startCol; j <= maxCol; j++) {
                            if (j < (value.startCol + value.colCount) && !ej.isNullOrUndefined(container[i])) {
                                if (!ej.isNullOrUndefined(container[i][j])) {
                                    this._delCells.push({ row: i, col: j, value: $.extend(true, {}, container[i][j]), height: container[i][j].wrap ? sheet._wrapColl[i][j] : rowHtColl[i] });
                                    this._clearFormula(i, j);
                                    if (container[i][j].wrap)
                                        delete sheet._wrapColl[i][j];
                                    container[i][j] = {};
                                    rmColl.push({ row: i, col: j });
                                }
                            }
                            if (!ej.isNullOrUndefined(container[i]))
                                if (!ej.isNullOrUndefined(container[i][j + value.colCount])) {
                                    container[i][j] = $.extend(true, {}, container[i][j + value.colCount]);
                                    if (container[i][j + value.colCount].wrap) {
                                        this._wrapCollection(i, j, sheet._wrapColl[i][j + value.colCount], sIdx);
                                        delete sheet._wrapColl[i][j + value.colCount];
                                    }
                                    currCell = this.getCell(i + value.rowCount, j);
                                    remCell = this.getCell(i, j);
                                    if (currCell) {
                                        currText = currCell[0].outerHTML;
                                        this.clearTextNode(currCell);
                                    }
                                    if (remCell) {
                                        remText = remCell[0].outerHTML;
                                        this.clearTextNode(remCell, this.XLEdit.getPropertyValue(i, j, "value2"));
                                    }
                                    rmColl.push({ row: i, col: j + value.colCount });
                                    this._clearFormula(i, j + value.colCount);
                                    container[i][j + value.colCount] = {};
                                    isFormula = this._refreshFormula(i, j, value.colCount, "delete", "column", value.startCol, true);
                                    currCell && (currCell[0].outerHTML = currText);
                                    remCell && (remCell[0].outerHTML = remText);
									if(this.model.allowSparkline)
										this.XLSparkline._refreshSparklineForInsDel(i, j, value.colCount, "column", "delete", sIdx );
                                }
                            !isFormula && this.XLEdit._refreshCalcEngine(i, j);
                        }
                        for (k = 0, len = rmColl.length; k < len; k++) {
                            if (this.getObjectLength(container[rmColl[k].row][rmColl[k].col]) === 0) {
                                this._clearFormula(rmColl[k].row, rmColl[k].col);
                                this.XLEdit._refreshCalcEngine(rmColl[k].row, rmColl[k].col);
                                delete container[rmColl[k].row][rmColl[k].col];
                            }
                        }
                        rmColl = [];
                    }
                    break;
                case "shiftBottom":
                    var isWrapRow, colWtColl = this.getSheet(sIdx).columnsWidthCollection, rowHtColl = this.getSheet(sIdx).rowsHeightCollection, rowHt;
                    for (i = maxRow, len = value.startRow; i >= len; i--) {
                        isWrapRow = this._checkIndicesInContainer(sIdx, i, 0, "wrapRow");
                        for (j = value.startCol; j < cCount; j++) {
                            if (!ej.isNullOrUndefined(container[i])) {
                                if (!ej.isNullOrUndefined(container[i][j])) {
                                    if (ej.isNullOrUndefined(container[i + value.rowCount]))
                                        container[i + value.rowCount] = {};
                                    if (isWrapRow) {
                                        rowHt = sheet._wrapColl[i][j];
                                        rowHtColl[i + value.rowCount] = ej.max([rowHt, rowHtColl[i + value.rowCount]]);
                                        if (!this._checkIndicesInContainer(sIdx, i + value.rowCount, 0, "wrapRow"))
                                            this.XLEdit._updateDataContainer({ rowIndex: i + value.rowCount, colIndex: 0 }, { dataObj: { wrapRow: true } });
                                        this._wrapCollection(i + value.rowCount, j, rowHt, sIdx);
                                    }
                                    container[i + value.rowCount][j] = $.extend(true, {}, container[i][j]);
                                    this._clearFormula(i, j);
                                    //refresh Validation
                                    if (i >= stRow && i <= enRow) {
                                        this._checkIndicesInContainer(sIdx, stRow, j, "rule") && (vRule = this._dataContainer.sheets[sIdx][stRow][j]["rule"]);
                                        this._checkIndicesInContainer(sIdx, stRow, j, "cFormatRule") && (cRule = this._dataContainer.sheets[sIdx][stRow][j]["cFormatRule"]);
                                        this._refreshValAndCF(i, j, vRule, cRule, value.rowCount, 0, value.status);
                                        if (!isVirtualScroll)
                                            !(stRow < 1) && this.addClass(this.getCell(i, j)[0], this.XLFormat.getFormatClass(this.getCell(stRow - 1, j)[0].className, false));
                                    }
                                    else
                                        delete container[i][j];
                                    isWrapRow && delete sheet._wrapColl[i][j];
                                    isFormula = this._refreshFormula(i + value.rowCount, j, value.rowCount, "insert", "row", value.startRow, true);
									if(this.model.allowSparkline)
										this.XLSparkline._refreshSparklineForInsDel(i + value.rowCount, j, value.rowCount, "row", "insert", sIdx );
								}
                            }
                            !isFormula && this.XLEdit._refreshCalcEngine(i, j);
                            !isFormula && this.XLEdit._refreshCalcEngine(i + value.rowCount, j);
                        }
                        if (isWrapRow) {
                            rowHtColl[i] = ej.max(this._getObjectValues(sheet._wrapColl[i])); //this.XLResize._getContentHeight(i, sIdx, true);
                            !rowHtColl[i] && (rowHtColl[i] = this.model.rowHeight);
                            //check and remove wrapRow value
                            if (!this.getObjectLength(sheet._wrapColl[i]))
                                delete this._dataContainer.sheets[sIdx][i][0]["wrapRow"];
                        }
                        if (!ej.isNullOrUndefined(container[i]))
                            (this.getObjectLength(container[i]) === 0) && delete container[i];
                    }
                    if (this._isUndo && this._delCells.length > 0) {
                        var rRowIdx, rColIdx, isWrapCell;
                        remCells = this._delCells;
                        count = remCells[remCells.length - 1].row - remCells[0].row;
                        for (i = 0, len = remCells.length; i < len; i++) {
                            rRowIdx = remCells[i].row;
                            rColIdx = remCells[i].col;
                            if (ej.isNullOrUndefined(container[rRowIdx]))
                                container[rRowIdx] = {};
                            container[rRowIdx][rColIdx] = remCells[i].value;
                            this._refreshFormula(rRowIdx, rColIdx, count, "insert", "row", value.startRow, true);
                            this.XLEdit._refreshCalcEngine(rRowIdx, rColIdx);
                            isWrapRow = this._checkIndicesInContainer(sIdx, rRowIdx, 0, "wrapRow");
                            isWrapCell = remCells[i].value.wrap;
                            if (isWrapRow || isWrapCell) {
                                rowHt = isWrapCell ? remCells[i].height : this.model.rowHeight; //this._detailsFromGlobalSpan(rRowIdx, rColIdx, "height", this.XLEdit.getPropertyValue(rRowIdx, rColIdx, "value2"), colWtColl[rColIdx]);
                                rowHtColl[rRowIdx] = ej.max([rowHt, rowHtColl[rRowIdx]]);
                                if (!this._checkIndicesInContainer(sIdx, rRowIdx, 0, "wrapRow"))
                                    this.XLEdit._updateDataContainer({ rowIndex: rRowIdx, colIndex: 0 }, { dataObj: { wrapRow: true } });
                                this._wrapCollection(rRowIdx, rColIdx, rowHt, sIdx);
                            }
                            if (!isVirtualScroll)
                                this.XLComment && this.XLComment._updateCmntFrmCntnr(rRowIdx, rColIdx);
                        }
                    }
                    break;
                case "shiftUp":
                    rmColl = [];
                    var currCell, isDelWrapRow, isWrapRow, colWtColl = this.getSheet(sIdx).columnsWidthCollection, rowHtColl = this.getSheet(sIdx).rowsHeightCollection, rowHt;
                    for (i = value.startRow; i <= maxRow; i++) {
                        isDelWrapRow = this._checkIndicesInContainer(sIdx, i, 0, "wrapRow");
                        isWrapRow = this._checkIndicesInContainer(sIdx, i + value.rowCount, 0, "wrapRow");
                        for (j = value.startCol; j < cCount; j++) {
                            if (i < (value.startRow + value.rowCount) && !ej.isNullOrUndefined(container[i]))
                                if (!ej.isNullOrUndefined(container[i][j])) {
                                    this._delCells.push({ row: i, col: j, value: $.extend(true, {}, container[i][j]), height: isDelWrapRow ? sheet._wrapColl[i][j] : rowHtColl[i] });
                                    this._clearFormula(i, j);
                                    container[i][j] = {};
                                    rmColl.push({ row: i, col: j });
                                    if (isDelWrapRow)
                                        delete sheet._wrapColl[i][j];
                                }
                            if (!ej.isNullOrUndefined(container[i + value.rowCount])) {
                                if (!ej.isNullOrUndefined(container[i + value.rowCount][j])) {
                                    if (ej.isNullOrUndefined(container[i]))
                                        container[i] = {};
                                    container[i][j] = $.extend(true, {}, container[i + value.rowCount][j]);
                                    if (isWrapRow) {
                                        this._wrapCollection(i, j, sheet._wrapColl[i + value.rowCount][j], sIdx);
                                        delete sheet._wrapColl[i + value.rowCount][j];
                                    }
                                    currCell = this.getCell(i + value.rowCount, j);
                                    remCell = this.getCell(i, j);
                                    if (currCell) {
                                        currText = currCell[0].outerHTML;
                                        this.clearTextNode(currCell);
                                    }
                                    if (remCell) {
                                        remText = remCell[0].outerHTML;
                                        this.clearTextNode(remCell, this.XLEdit.getPropertyValue(i, j, "value2"));
                                    }
                                    this._clearFormula(i + value.rowCount, j);
                                    container[i + value.rowCount][j] = {};
                                    rmColl.push({ row: i + value.rowCount, col: j });
                                    isFormula = this._refreshFormula(i, j, value.rowCount, "delete", "row", value.startRow, true);
                                    currCell && (currCell[0].outerHTML = currText);
                                    remCell && (remCell[0].outerHTML = remText);
									if(this.model.allowSparkline)
										this.XLSparkline._refreshSparklineForInsDel(i, j, value.colCount, "column", "delete", sIdx );
                                }
                            }
                            else
                                rowHtColl[i + value.rowCount] = this.model.rowHeight;
                            !isFormula && this.XLEdit._refreshCalcEngine(i, j);
                        }
                        if (isDelWrapRow) {
                            if (this.getObjectLength(sheet._wrapColl[i]) < 1)
                                delete this._dataContainer.sheets[sIdx][i][0]["wrapRow"];
                        }
                        if (isWrapRow) {
                            this.XLEdit._updateDataContainer({ rowIndex: i, colIndex: 0 }, { dataObj: { wrapRow: true } });
                            rowHtColl[i + value.rowCount] = ej.max(this._getObjectValues(sheet._wrapColl[i + value.rowCount]));
                            !rowHtColl[i + value.rowCount] && (rowHtColl[i + value.rowCount] = this.model.rowHeight);
                            if (!this.getObjectLength(sheet._wrapColl[i + value.rowCount]))
                                delete this._dataContainer.sheets[sIdx][i + value.rowCount][0]["wrapRow"];
                        }
                        if (isDelWrapRow || isWrapRow) {
                            rowHtColl[i] = ej.max(this._getObjectValues(sheet._wrapColl[i]));
                            !rowHtColl[i] && (rowHtColl[i] = this.model.rowHeight);
                        }
                    }
                    for (k = 0, len = rmColl.length; k < len; k++) {
                        if (this.getObjectLength(container[rmColl[k].row][rmColl[k].col]) === 0) {
                            this._clearFormula(rmColl[k].row, rmColl[k].col);
                            delete container[rmColl[k].row][rmColl[k].col];
                        }
                        (this.getObjectLength(container[rmColl[k].row]) === 0) && delete container[rmColl[k].row];
                    }
                    break;
            }
            if (value.status.indexOf("insert") > -1) {
                usedRange.rowIndex = usedRange.rowIndex + value.rowCount;
                usedRange.colIndex = usedRange.colIndex + value.colCount;
                this.getSheet(sIdx).usedRange = usedRange;
            }
        },

        _undoInsDelMerge: function () {
            if (this._isUndo) {
                this._dupDetails = true;
                for (var k = 0, kLen = this._removeMergeColl.length; k < kLen; k++) {
                    this.mergeCenter = this._removeMergeColl[k].merge.isCenterAlign;
                    this.mergeCells(this._removeMergeColl[k].merge.mRange, true);
                }
                this._dupDetails = false;
            }
        },
        _updateCommentColl: function (sheetIdx) {
            this.getSheet(sheetIdx)._commentColl = {};
            this._isInsdel = true;
            this.XLComment._updateCmntArrowPos();
            this._isInsdel = false;
        },
        insertShiftRight: function (startCell, endCell) {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            var status, isInsert = false, iTd, len, sheetIdx = this.getActiveSheetIndex(), value;
            if (this._isUndo) {
                status = "shiftLeft";
                this._insDelStatus = "delete";
            }
            else {
                status = "shiftRight";
                this._insDelStatus = "insert";
            }
            value = { startCol: startCell.colIndex, colCount: (endCell.colIndex - startCell.colIndex) + 1, startRow: startCell.rowIndex, rowCount: (endCell.rowIndex - startCell.rowIndex) + 1, status: status };
            if (this.model.allowFiltering)
                this.XLFilter._checkFilterApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
            this._checkTableApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			if (this._isFilterApplied || this._isTableApplied)
                this._showAlertDlg("Alert", "InsertDeleteAlert", "InsertDeleteAlert", 630);
            else {
                isInsert = this._clearAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
                if (!isInsert.isAlert) {
                    this._insData = { sheetIdx: sheetIdx, startCell: startCell, endCell: endCell, value: value };
                    if (!this._isUndoRedo)
                        this._showAlertDlg("Alert", "MergeInsertAlert", "MergeInsertDelete", 498);
                    else
                        this._refreshMergeCells();
                }
                else
                    this._insertShiftRight(sheetIdx, startCell, endCell, value);
                this._undoInsDelMerge();
            }
        },

        _insertShiftRight: function (sheetIdx, startCell, endCell, value) {
            var iTd, count = endCell.colIndex - startCell.colIndex + 1, rows = this.getRows(sheetIdx)[1], hdrcolgrp = this._getJSSheetHeader(sheetIdx).find("col"), colgrp = this._getContent(sheetIdx).find("col"), len;
			this._updateWrapCol("insertShiftRight", this._getSelectedCells(sheetIdx, [startCell.rowIndex, startCell.colIndex,endCell.rowIndex, endCell.colIndex]).selCells,this.getSheet(sheetIdx), sheetIdx);
            if (this._isUndo) {
                for (var i = startCell.rowIndex; i <= endCell.rowIndex; i++) {
                    iTd = $(rows[this._getRowIdx(i)]).find('td');
                    len = iTd.length - 1;
                    for (var j = startCell.colIndex; j <= len - count; j++)
                        iTd[j].outerHTML = iTd[j + count].outerHTML;
                }
                for (var k = len; k > len - count; k--) {
                    hdrcolgrp.eq(k).remove();
                    colgrp.eq(k).remove();
                    for (var m = 0; m < rows.length; m++)
                        $(rows[this._getRowIdx(m)]).find('td:eq(' + k + ')').remove();
                }
            }
            else
                this.XLScroll._createNewColumn(sheetIdx, startCell, endCell, "shift");
            this.performSelection(startCell, endCell);
            this._refreshDataContainer(sheetIdx, value);
            !this._isUndo ? this._refreshAllMergeCells(sheetIdx, -1, 0, startCell.colIndex, value.colCount, "insert") : this._refreshAllMergeCells(sheetIdx, -1, 0, startCell.colIndex, value.colCount, "delete");
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            if (this.model.allowComments)
                this.XLComment._curCommentHCell = null;
            if (!this._isUndoRedo)
                this._undoredoDetails(sheetIdx, startCell, endCell, "insert", "insertShiftRight");
            this._refreshRows(sheetIdx);
        },

        insertShiftBottom: function (startCell, endCell) {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            var isInsert = false, sheetIdx = this.getActiveSheetIndex(), status, value;
            status = (!this._isUndo) ? "shiftBottom" : "shiftUp";
            value = { startCol: startCell.colIndex, colCount: (endCell.colIndex - startCell.colIndex) + 1, startRow: startCell.rowIndex, rowCount: (endCell.rowIndex - startCell.rowIndex) + 1, status: status };
            if (this.model.allowFiltering)
                this.XLFilter._checkFilterApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			this._checkTableApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			if (this._isFilterApplied || this._isTableApplied) {
                if (this._isTotalRow)
                    if (!this._isUndoRedo) {
                        this._showAlertDlg("", "TotalRowAlert", "TotalRow", 630);
                        return true;
                    }
                    else {
                        this._isUndoRedo = this._dupDetails = true;
                        !this._isUndo && this.insertEntireRow(this._insRows.startRow, this._insRows.endRow);
                        this._isUndoRedo = false;
                    }
                else
                    this._showAlertDlg("Alert", "InsertDeleteAlert", "InsertDeleteAlert", 630);
            }
            else {
                isInsert = this._clearAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
                if (!isInsert.isAlert) {
                    this._insData = { sheetIdx: sheetIdx, startCell: startCell, endCell: endCell, value: value };
                    if(!this._isUndoRedo)
                        this._showAlertDlg("Alert", "MergeInsertAlert", "MergeInsertDelete", 498);
                    else
                        this._refreshMergeCells();
                }
                else
                    this._insertShiftBottom(sheetIdx, startCell, endCell, value);
                this._undoInsDelMerge();
            }
        },

        _insertShiftBottom: function (sheetIdx, startCell, endCell, value) {
            var isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, i, j, k, len;
			this._updateWrapCol("insertShiftBottom", this._getSelectedCells(sheetIdx, [startCell.rowIndex, startCell.colIndex,endCell.rowIndex, endCell.colIndex]).selCells,this.getSheet(sheetIdx), sheetIdx);
            this._refreshDataContainer(sheetIdx, value);
            if (isVirtualScroll)
                this._refreshViewport(this.getSheet(sheetIdx)._scrollTop, sheetIdx);
            else {
                var x, xTd, iTd, rowHtColl = this.getSheet(sheetIdx).rowsHeightCollection, rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowHdrs = rowColl[0];
                if (!this._isUndo) {
                    for (i = startCell.rowIndex; i <= endCell.rowIndex; i++)
                        this.XLScroll._createNewRow(sheetIdx, -1, -1, "insert");
                    for (i = rows.length - 1; i >= startCell.rowIndex  ; i--) {
                        x = i - ((endCell.rowIndex - startCell.rowIndex) + 1);
                        iTd = $(rows[i]).find('td');
                        if (x >= startCell.rowIndex) {
                            xTd = $(rows[x]).find('td')
                            for (j = startCell.colIndex; j <= endCell.colIndex; j++) {
                                iTd[j].outerHTML = xTd[j].outerHTML;
                                xTd[j].innerHTML = "";
                                iTd[j].className = xTd[j].className;
                                xTd[j].className = "e-rowcell e-wrapword";
                            }
                        }
                        rows[i].style.height = rowHtColl[i] + "px";
                        rowHdrs[i].style.height = rowHtColl[i] + "px";
                    }
                }
                else {
                    rows = this._getContent(sheetIdx).find("tbody").get(0).rows;
                    for (i = startCell.rowIndex, len = rows.length; i < len ; i++) {
                        x = i + ((endCell.rowIndex - startCell.rowIndex) + 1);
                        iTd = $(rows[i]).find('td');
                        if (x < rows.length) {
                            xTd = $(rows[x]).find('td')
                            for (j = startCell.colIndex; j <= endCell.colIndex; j++) {
                                iTd[j].outerHTML = xTd[j].outerHTML;
                                xTd[j].innerHTML = "";
                            }
                        }
                        rows[i].style.height = rowHtColl[i] + "px";
                        rowHdrs[i].style.height = rowHtColl[i] + "px";
                    }
                    for (j = startCell.colIndex; j <= endCell.colIndex; j++) {
                        for (k = len - 1, length = (len - 1) - ((endCell.rowIndex - startCell.rowIndex) + 1) ; k > length; k--) {
                            $(rows[k]).remove();
                            $(rowHdrs[k]).remove();
                            this.model.sheets[sheetIdx].rowCount = this.model.sheets[sheetIdx].rowCount - 1;
                        }
                    }
                    this.XLScroll._refreshScroller(1, { rowIndex: -1, colIndex: -1 }, { rowIndex: -1, colIndex: -1 }, "all");
                }
                this._refreshRows(sheetIdx);
            }
            this.XLScroll._getRowHeights(sheetIdx, startCell.rowIndex);
            this.performSelection(startCell, endCell);
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            if (this.model.allowComments)
                this.XLComment._curCommentHCell = null;
            (!this._isUndo) ? this._refreshAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, -1, 0, "insert") : this._refreshAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, -1, 0, "delete");
            if (!this._isUndoRedo && !this._dupDetails)
                this._undoredoDetails(sheetIdx, startCell, endCell, "insert", "insertShiftBottom");
        },

        insertEntireRow: function (startRow, endRow) {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            var isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, i, sRange, len, status, value, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), rowHtColl = sheet.rowsHeightCollection, rowhdrSel = sheet._isRowSelected,
                selCell = sheet._selectedCells, stCol = selCell[0].colIndex, endCol = selCell[selCell.length - 1].colIndex;
			this._updateWrapCol("insertEntireRow", selCell ,sheet, sheetIdx);
            if (!this._isUndo) {
                status = "insertRow";
                this._insDelStatus = "insert";
            }
            else {
                status = "deleteRow";
                this._insDelStatus = "delete";
            }
            value = { startCol: 0, colCount: sheet.colCount, startRow: startRow, rowCount: (endRow - startRow) + 1, status: status };
            if (this.XLRibbon._isDirtySelect || (this.model.allowFiltering && this.XLFilter._checkFilterApplied(sheetIdx, startRow, value.rowCount, 0, sheet.colCount, status))) {
                this._showAlertDlg("Alert", "InsertDeleteAlert", 440);
                return;
            }
            this._clearAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, status);
            this._isUndo && this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx, false);
            this._refreshDataContainer(sheetIdx, value);
            if (this._isUndo)
                this._batchDeleteRow(startRow, endRow, sheetIdx, true);
            else
                this._batchAddRow(startRow, endRow, sheetIdx);
            if (isVirtualScroll) {
                this.model.allowFiltering && this.XLFilter._updateFilterCollection(sheetIdx, startRow, endRow - startRow, "row", this._insDelStatus);
                sheet.rowCount = this._isUndo ? (sheet.rowCount - value.rowCount) : (sheet.rowCount + value.rowCount);
                this.refreshContent(sheetIdx);
            }
            else {
                var rowColl, rows, rowHdrs, tbodyRowHdr;
                if (!this._isUndo) {
                    for (i = startRow; i <= endRow; i++)
                        this.XLScroll._createNewRow(sheetIdx, i, 0, "insert");
                }
                else {
                    rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowHdrs = rowColl[0];
                    for (i = endRow; i >= startRow; i--) {
                        $(rows[i]).remove();
                        $(rowHdrs[i]).remove();
                        sheet.rowCount = sheet.rowCount - 1;
                    }
                    var thdr = rowHdrs.find('td');
                    for (i = 0, len = thdr.length; i < len; i++)
                        $(thdr[i]).text(i + 1);
                }
                this.model.allowFiltering && this.XLFilter._updateFilterCollection(sheetIdx, startRow, endRow - startRow, "row", this._insDelStatus);
                this.XLScroll._getRowHeights(sheetIdx, startRow);
                this._refreshRows(sheetIdx);
            }
            if (this._isFrozen(sheet.frozenRows)) {
                if (startRow < sheet._frozenRows || endRow < sheet._frozenRows)
                    this.XLFreeze._refreshFreezeRowDiv();
            }
            if (this._isUndo)
                this._refreshAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, "delete");
            else
                this._refreshAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, "insert");
            rowhdrSel ? this.XLSelection.selectRows(startRow, endRow) : this.performSelection({ rowIndex: startRow, colIndex: stCol }, { rowIndex: endRow, colIndex: endCol });
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            if (!this._isUndoRedo && !this._dupDetails)
                this._undoredoDetails(sheetIdx, { rowIndex: startRow, colIndex: 0 }, { rowIndex: endRow, colIndex: sheet.colCount - 1 }, "insert", "insertRow");
            if (this.XLShape)
                this._isUndo ? this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx, true) : this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx);
        },

        insertEntireColumn: function (startCol, endCol) {
            if (!this.model.allowInsert || this.model.isReadOnly)
                return;
            var j, isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, status, sheetIdx = this.getActiveSheetIndex(), value, sheet = this.getSheet(sheetIdx), colHdrSel = sheet._isColSelected, startCell, endCell,
                selCell = sheet._selectedCells, stRow = selCell[0].rowIndex, endRow = selCell[selCell.length - 1].rowIndex, colWtColl = sheet.columnsWidthCollection, colWt, newWidthColl = [];
			this._updateWrapCol("insertEntireColumn", selCell ,sheet, sheetIdx);
            if (this._isUndo) {
                this._insDelStatus = "delete";
                status = "deleteColumn";
            }
            else {
                status = "insertColumn";
                this._insDelStatus = "insert";
            }
            if (sheet._isTemplate && (startCol < sheet._templateColCount || endCol < sheet._templateColCount))
                return;
            value = { startCol: startCol, colCount: (endCol - startCol) + 1, startRow: 0, rowCount: sheet.rowCount, status: status };
            if (this.XLRibbon._isDirtySelect || (this.model.allowFiltering && this.XLFilter._checkFilterApplied(sheetIdx, value.startRow, sheet.rowCount, startCol, value.colCount, status))) {
                this._showAlertDlg("Alert", "InsertDeleteAlert", 440);
                return;
            }
            this._clearAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, status);
            this._isUndo && this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx, false);
            if (status === "deleteColumn" && isVirtualScroll) {
                for (j = endCol; j >= startCol; j--) {
                    colWtColl.splice(j, 1);
                    colWtColl.push(sheet.columnWidth);
                }
            }
            startCell = { rowIndex: stRow, colIndex: startCol };
            endCell = { rowIndex: endRow, colIndex: endCol };
            if (isVirtualScroll) {
	            this._refreshDataContainer(sheetIdx, value);
                this.refreshContent(sheetIdx);
			}
            else {
                this.XLScroll._createNewColumn(sheetIdx, startCell, endCell, "insert");
				this._refreshDataContainer(sheetIdx, value);
			}
            (!this._isUndo) ? this._refreshAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, "insert") : this._refreshAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, "delete");
            this.model.allowFiltering && this.XLFilter._updateFilterCollection(sheetIdx, startCol, endCol - startCol, "column", this._insDelStatus);
            if (this._isFrozen(sheet.frozenColumns)) {
                if (startCol < sheet._frozenColumns || endCol < sheet._frozenColumns)
                    this.XLFreeze._refreshFreezeColDiv();
            }
            if (!this._isUndoRedo)
                this._undoredoDetails(sheetIdx, startCell, endCell, "insert", "insertColumn");
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            colHdrSel ? this.XLSelection.selectColumns(startCol, endCol) : this.performSelection(startCell, endCell);
            this._refreshRows(sheetIdx);
			if((this._isFrozen(sheet.frozenRows) || this._isFrozen(sheet.frozenColumns)) && this.model.allowAutoFill)
			   this.XLDragFill.positionAutoFillElement();
            if (this._isAutoWHMode)
                this._autoSSWidthHeight(sheetIdx);
            if (this.XLShape)
                this._isUndo ? this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx, true) : this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx);
        },

        deleteShiftLeft: function (startCell, endCell) {
            if (!this.model.allowDelete || this.model.isReadOnly)
                return;
            var isDelete = false, sheetIdx = this.getActiveSheetIndex(), status, value;
            if (!this._isUndo) {
                this._insDelStatus = "delete";
                status = "shiftLeft";
            }
            else {
                this._insDelStatus = "insert";
                status = "shiftRight";
            }
            value = { startCol: startCell.colIndex, colCount: (endCell.colIndex - startCell.colIndex) + 1, startRow: startCell.rowIndex, rowCount: (endCell.rowIndex - startCell.rowIndex) + 1, status: status };
            if (this.model.allowFiltering)
                this.XLFilter._checkFilterApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
            this._checkTableApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			if (this._isFilterApplied || this._isTableApplied)
                this._showAlertDlg("Alert", "InsertDeleteAlert", "InsertDeleteAlert", 630);
            else {
                isDelete = this._clearAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
                if (!isDelete.isAlert) {
                    this._insData = { sheetIdx: sheetIdx, startCell: startCell, endCell: endCell, value: value };
                    if (!this._isUndoRedo)
                        this._showAlertDlg("Alert", "MergeInsertAlert", "MergeInsertDelete", 498);
                    else
                        this._refreshMergeCells();
                }
                else
                    !isDelete.isCancel && this._deleteShiftLeft(sheetIdx, startCell, endCell, value);
                this._undoInsDelMerge();
            }
        },

        _deleteShiftLeft: function (sheetIdx, startCell, endCell, value) {
            var i, j, tds, k, rowElemIdx, colCount = endCell.colIndex - startCell.colIndex + 1, rows = this.getRows(sheetIdx)[1], text = [], uLength;
			this._updateWrapCol("deleteShiftLeft", this._getSelectedCells(sheetIdx, [startCell.rowIndex, startCell.colIndex,endCell.rowIndex, endCell.colIndex]).selCells ,this.getSheet(sheetIdx), sheetIdx);
            if (!this._isUndo) {
                this._insDelStatus = "delete";
                for (i = startCell.rowIndex; i <= endCell.rowIndex; i++) {
                    rowElemIdx = this._getRowIdx(i);
                    tds = $(rows[rowElemIdx]).find('td');
                    for (j = startCell.colIndex; j <= endCell.colIndex; j++)
                        text.push(tds[j].outerHTML);
                    for (k = startCell.colIndex, length = tds.length; k < length - colCount; k++)
                        tds[k].outerHTML = tds[k + colCount].outerHTML;
                }
            }
            else {
                $.extend(true, text, this._deletedText);
                for (i = startCell.rowIndex; i <= endCell.rowIndex; i++) {
                    rowElemIdx = this._getRowIdx(i);
                    tds = $(rows[rowElemIdx]).find('td');
                    uLength = tds.length - 1;
                    for (k = uLength - colCount; k > startCell.colIndex - 1; k--)
                        tds[k + colCount].outerHTML = tds[k].outerHTML;
                    for (j = startCell.colIndex; j <= endCell.colIndex; j++)
                        tds[j].outerHTML = text.shift();
                }
            }
            this.performSelection(startCell, endCell);
            this._refreshDataContainer(sheetIdx, value);
            if (this.model.allowComments) this.XLComment._curCommentHCell = null;
            this._deletedText = text;
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            (!this._isUndo) ? this._refreshAllMergeCells(sheetIdx, -1, 0, startCell.colIndex, value.colCount, "delete") : this._refreshAllMergeCells(sheetIdx, -1, 0, startCell.colIndex, value.colCount, "insert");
            (!this._isUndoRedo) && this._undoredoDetails(sheetIdx, startCell, endCell, "delete", "deleteShiftLeft");
            this._refreshRows(sheetIdx);
        },
        deleteShiftUp: function (startCell, endCell) {
            if (!this.model.allowDelete || this.model.isReadOnly)
                return;
            var isDelete = false, sheetIdx = this.getActiveSheetIndex(), status, value;
            status = (!this._isUndo) ? "shiftUp" : "shiftBottom";
            value = { startCol: startCell.colIndex, colCount: (endCell.colIndex - startCell.colIndex) + 1, startRow: startCell.rowIndex, rowCount: (endCell.rowIndex - startCell.rowIndex) + 1, status: status };
            if (this.model.allowFiltering)
                this.XLFilter._checkFilterApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			this._checkTableApplied(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
			if (this._isFilterApplied || this._isTableApplied) {
                if (this._isTotalRow)
                    return;
                this._showAlertDlg("Alert", "InsertDeleteAlert", "InsertDeleteAlert", 630);
            }
            else {
                isDelete = this._clearAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, startCell.colIndex, value.colCount, status);
                if (!isDelete.isAlert) {
                    this._insData = { sheetIdx: sheetIdx, startCell: startCell, endCell: endCell, value: value };
                    if (!this._isUndoRedo)
                        this._showAlertDlg("Alert", "MergeInsertAlert", "MergeInsertDelete", 498);
                    else
                        this._refreshMergeCells();
                }
                else
                    !isDelete.isCancel && this._deleteShiftUp(sheetIdx, startCell, endCell, value);
                this._undoInsDelMerge();
            }
        },

        _deleteShiftUp: function (sheetIdx, startCell, endCell, value) {
            var isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, i, j, len, text = [], x, rowElemIdx, sheet = this.getSheet(sheetIdx);
            this._refreshDataContainer(sheetIdx, value);
			this._updateWrapCol("deleteShiftUp", this._getSelectedCells(sheetIdx, [startCell.rowIndex, startCell.colIndex,endCell.rowIndex, endCell.colIndex]).selCells ,sheet, sheetIdx);
            if (isVirtualScroll)
                this._refreshViewport(sheet._scrollTop, sheetIdx);
            else {
                var itds, xtds, rowHtColl = sheet.rowsHeightCollection, rowsColl = this.getRows(sheetIdx), rows = rowsColl[1], rowHdrs = rowsColl[0];
                if (!this._isUndo || this._isTotalRow) {
                    for (i = startCell.rowIndex, len = rows.length; i < len ; i++) {
                        x = i + ((endCell.rowIndex - startCell.rowIndex) + 1);
                        rowElemIdx = this._getRowIdx(i);
                        itds = $(rows[rowElemIdx]).find('td');
                        if (x < rows.length) {
                            xtds = $(rows[this._getRowIdx(x)]).find('td');
                            for (j = startCell.colIndex; j <= endCell.colIndex; j++) {
                                text.push(itds[j].outerHTML);
                                itds[j].outerHTML = xtds[j].outerHTML;
                                xtds[j].innerHTML = "";
                            }
                        }
                        rows[rowElemIdx].style.height = rowHtColl[i] + "px";
                        rowHdrs[rowElemIdx].style.height = rowHtColl[i] + "px";
                    }
                }
                else {
                    $.extend(true, text, this._deletedText);
                    for (i = rows.length - 1; i >= startCell.rowIndex  ; i--) {
                        x = i - ((endCell.rowIndex - startCell.rowIndex) + 1);
                        rowElemIdx = this._getRowIdx(i);
                        itds = $(rows[rowElemIdx]).find('td');
                        if (x >= startCell.rowIndex) {
                            xtds = $(rows[this._getRowIdx(x)]).find('td');
                            for (j = startCell.colIndex; j <= endCell.colIndex; j++) {
                                itds[j].outerHTML = xtds[j].outerHTML;
                                xtds[j].innerHTML = "";
                            }
                        }
                        rows[rowElemIdx].style.height = rowHtColl[i] + "px";
                        rowHdrs[rowElemIdx].style.height = rowHtColl[i] + "px";
                    }
                    for (i = startCell.rowIndex; i <= endCell.rowIndex; i++) {
                        itds = $(rows[this._getRowIdx(i)]).find('td');
                        for (j = startCell.colIndex; j <= endCell.colIndex; j++)
                            itds[j].outerHTML = text.shift();
                    }
                }
                this._refreshRows(sheetIdx);
            }
            this.XLScroll._getRowHeights(sheetIdx, startCell.rowIndex);
            this.performSelection(startCell, endCell);
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            if (this.model.allowComments) this.XLComment._curCommentHCell = null;
            this._deletedText = text;
            (!this._isUndo) ? this._refreshAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, -1, 0, "delete") : this._refreshAllMergeCells(sheetIdx, startCell.rowIndex, value.rowCount, -1, 0, "insert");
            if (!this._isUndoRedo && !this._dupDetails)
                this._undoredoDetails(sheetIdx, startCell, endCell, "delete", "deleteShiftUp");
        },

        deleteEntireRow: function (startRow, endRow) {
            if (!this.model.allowDelete || this.model.isReadOnly)
                return;
            var isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, i, len, status, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx),
                selCell = sheet._selectedCells, stCol = selCell[0].colIndex, endCol = selCell[selCell.length - 1].colIndex, rowHeightColl = sheet.rowsHeightCollection;
			this._updateWrapCol("deleteEntireRow", selCell ,sheet, sheetIdx);
            if (!this._isUndo) {
                status = "deleteRow";
                this._insDelStatus = "delete";
            }
            else {
                this._insDelStatus = "insert";
                status = "insertRow";
            }
            value = { startCol: 0, colCount: sheet.colCount, startRow: startRow, rowCount: (endRow - startRow) + 1, status: status };
            if (!this._isUndoRedo && (this.XLRibbon._isDirtySelect || (this.model.allowFiltering && this.XLFilter._checkFilterApplied(sheetIdx, startRow, value.rowCount, 0, sheet.colCount, status)))) {
                this._showAlertDlg("Alert", "InsertDeleteAlert", 440);
                return;
            }
            !this._isUndo && this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx, false);
            this._clearAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, status);
            this._refreshDataContainer(sheetIdx, value);
            if (this._isUndo)
                this._batchAddRow(startRow, endRow, sheetIdx, true);
            else
                this._batchDeleteRow(startRow, endRow, sheetIdx);
            if (isVirtualScroll) {
                if (this.model.scrollSettings.scrollMode === "normal")
                    sheet.rowCount = this._isUndo ? (sheet.rowCount + value.rowCount) : (sheet.rowCount - value.rowCount);
                this.refreshContent(sheetIdx);
            }
            else {
                var thdr, rowElemIdx, tdHdr, text = [], dimension = [], rowHt, tr, value, rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowHdrs = rowColl[0];
                if (!this._isUndo) {
                    for (i = endRow; i >= startRow; i--) {
                        rowElemIdx = this._getRowIdx(i);
                        text.push(rows[rowElemIdx].outerHTML);
                        $(rows[rowElemIdx]).remove();
                        $(rowHdrs[rowElemIdx]).remove();
                        sheet.rowCount = sheet.rowCount - 1;
                        this.XLScroll._createNewRow(sheetIdx, -1, -1, "insert");
                    }
                }
                else {
                    $.extend(true, text, this._deletedText);
                    for (i = startRow; i <= endRow; i++) {
                        rowElemIdx = this._getRowIdx(i);
                        tr = text.pop();
                        $(rows[rowElemIdx]).before(tr);
                        tdHdr = this.XLScroll._rowHeaderTemplate(1, rowHeightColl[i]);
                        $(rowHdrs[rowElemIdx]).before(tdHdr);
                        sheet.rowCount = sheet.rowCount + 1;
                    }
                    this._refreshRows(sheetIdx);
                }
                thdr = $(this.getRows(sheetIdx)[0]).find('td');
                for (i = 0, len = thdr.length; i < len; i++)
                    $(thdr[i]).text(i + 1);
                this._refreshRows(sheetIdx);
            }
            if (this._isFrozen(sheet.frozenRows)) {
                if (startRow < sheet._frozenRows || endRow < sheet._frozenRows)
                    this.XLFreeze._refreshFreezeRowDiv();
            }
            (sheet._isRowSelected) ? this.XLSelection.selectRows(startRow, endRow) : this.performSelection({ rowIndex: startRow, colIndex: stCol }, { rowIndex: endRow, colIndex: endCol });
            this._deletedText = text;
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            if (this._isUndo)
                this._refreshAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, "insert");
            else
                this._refreshAllMergeCells(sheetIdx, startRow, value.rowCount, -1, 0, "delete");
            this.model.allowFiltering && this.XLFilter._updateFilterCollection(sheetIdx, startRow, endRow - startRow, "row", this._insDelStatus);
            this.XLScroll._getRowHeights(sheetIdx, startRow);
            (!this._isUndoRedo && !this._dupDetails) && this._undoredoDetails(sheetIdx, { rowIndex: startRow, colIndex: 0 }, { rowIndex: endRow, colIndex: sheet.colCount - 1 }, "delete", "deleteRow");
            if (this.XLShape)
                this._isUndo ? this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx) : this.XLShape._refreshChartdataInsDel(value.status, value.rowCount, value.startRow, sheetIdx, true);
        },

        deleteEntireColumn: function (startCol, endCol) {
            if (!this.model.allowDelete || this.model.isReadOnly)
                return;
            var i, j, len, tds, hiddenWth = 0, sheetIdx = this.getActiveSheetIndex(), fColIdx = this.getFrozenColumns(), sheet = this.getSheet(sheetIdx), rows = this.getRows(sheetIdx)[1], colgrp = this._getContent(sheetIdx).find("col"),
                hdrcolgrp = this._getJSSheetHeader(sheetIdx).find("col"), colHdr = this._getJSSheetHeader(sheetIdx).find("th"), selCell = sheet._selectedCells, stRow = selCell[0].rowIndex, endRow = selCell[selCell.length - 1].rowIndex,
                tdColgrp, status, text = [], value, tdRowData, colWt, tdColgrp = this.XLScroll._colGroupTemplate(1), colWidthColl = sheet.columnsWidthCollection, isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling,
                tbody = isVirtualScroll ? this._getContent(sheetIdx).find("tbody").get(1) : this._getContent(sheetIdx).find("tbody").get(0);
			this._updateWrapCol("deleteEntireRow", selCell ,sheet, sheetIdx);
            if (!this._isUndo) {
                status = "deleteColumn";
                this._insDelStatus = "delete";
            }
            else {
                status = "insertColumn";
                this._insDelStatus = "insert";
            }
            if (sheet._isTemplate && (startCol < sheet._templateColCount || endCol < sheet._templateColCount))
                return;
            value = { startCol: startCol, colCount: (endCol - startCol) + 1, startRow: 0, rowCount: sheet.rowCount, status: status };
            if (!this._isUndoRedo && (this.XLRibbon._isDirtySelect || (this.model.allowFiltering && this.XLFilter._checkFilterApplied(sheetIdx, value.startRow, value.rowCount, 0, sheet.colCount, status)))) {
                this._showAlertDlg("Alert", "InsertDeleteAlert", 440);
                return;
            }
            this._clearAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, status);
            if (!this._isUndo) {
                this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx, false);
                this._deletedDimension = [];
                if (this._isFrozen(fColIdx) && fColIdx >= startCol) {
                    for (i = sheet._frozenColumns - 1; i < sheet._fleftColIdx; i++)
                        hiddenWth += sheet.columnsWidthCollection[i];
                    this._scrollContent({ x: -hiddenWth });
                }
                for (j = endCol; j >= startCol; j--) {
                    text.push(hdrcolgrp[j].outerHTML);
                    text.push(colgrp[j].outerHTML);
                    this._deletedDimension.push(colWidthColl.splice(j, 1)[0]);
                    hdrcolgrp.eq(j).remove();
                    colgrp.eq(j).remove();
                    hdrcolgrp.parent().append(tdColgrp);
                    colgrp.parent().append(tdColgrp);
                    colWidthColl.push(sheet.columnWidth);
                }
                for (i = 0, len = rows.length; i < len; i++) {
                    tds = $(rows[i]).find('td');
                    for (j = endCol; j >= startCol; j--) {
                        tdRowData = this.XLScroll._columnTemplate();
                        $(rows[i]).append(tdRowData);
                        text.push(tds[j].outerHTML);
                        $(tbody.rows[i]).find('td:eq(' + j + ')').remove();
                    }
                }
            }
            else {
                text = $.extend(true, text, this._deletedText);
                var diff = 0;
                for (i = rows.length - 1; i >= 0; i--) {
                    tds = $(rows[i]).find('td');
                    for (j = startCol; j <= endCol; j++) {
                        tds.eq(j - diff).before(text.pop());
                        diff++;
                    }
                    diff = 0;
                }
                for (j = startCol; j <= endCol; j++) {
                    colgrp.eq(j - diff).before(text.pop());
                    colHdr.eq(j - diff).before("<th class='e-headercell'><div class='e-headercelldiv'></div></th>");
                    hdrcolgrp.eq(j - diff).before(text.pop());
                    diff++;
                }
                colWt = colWidthColl.splice(0, startCol);
                ej.merge(colWt, this._deletedDimension.reverse());
                ej.merge(colWt, colWidthColl);
                sheet.columnsWidthCollection = colWt;
                this._deletedDimension = [];
                this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx, false);
            }
            this.XLScroll._getColWidths(sheetIdx, startCol);
            if (this._isFrozen(sheet.frozenColumns)) {
                if (startCol < sheet._frozenColumns || endCol < sheet._frozenColumns)
                    this.XLFreeze._refreshFreezeColDiv();
            }
            this.model.allowFiltering && this.XLFilter._updateFilterCollection(sheetIdx, startCol, endCol - startCol, "column", this._insDelStatus);
            sheet.colCount = colgrp.length;
            colHdr = this._getJSSheetHeader(sheetIdx).find('th');
            this._refreshDataContainer(sheetIdx, value);
            var cls;
            for (i = 0, len = colHdr.length; i < len; i++) {
                if (this._checkIndicesInContainer(sheetIdx, 0, i, "hCol"))
                    cls = "e-hcol";
                if(this._checkIndicesInContainer(sheetIdx, 0, i, "isCHide"))
                    cls += "e-hide";
                this._removeClass(colHdr[i], "e-hcol");
                this._removeClass(colHdr[i], "e-hide");
                this.addClass(colHdr[i], cls);
                cls = "";
                $(colHdr[i]).find('div').text(this._generateHeaderText(i + 1));
            }
            if (isVirtualScroll)
                this.refreshContent(sheetIdx);
            (!this._isUndo) ? this._refreshAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, "delete") : this._refreshAllMergeCells(sheetIdx, -1, 0, startCol, value.colCount, "insert");
            sheet._isColSelected ? this.XLSelection.selectColumns(startCol, endCol) : this.performSelection({ rowIndex: stRow, colIndex: startCol }, { rowIndex: endRow, colIndex: endCol });
            this._deletedText = text;
            if (this.model.allowComments)
                this._updateCommentColl(sheetIdx);
            (!this._isUndoRedo) && this._undoredoDetails(sheetIdx, { rowIndex: 0, colIndex: startCol }, { rowIndex: sheet.rowCount - 1, colIndex: endCol }, "delete", "deleteColumn");
            this._refreshRows(sheetIdx);
            this.XLShape && this.XLShape._refreshChartdataInsDel(value.status, value.colCount, value.startCol, sheetIdx, true);
        },

        _getSelectedRange: function (startcell, endcell) {
            var i, j, k, l, arr = [],
                range = this.swapRange([startcell.rowIndex, startcell.colIndex, endcell.rowIndex, endcell.colIndex]);
            i = range[0], j = range[2];
            while (i <= j) {
                k = range[1];
                l = range[3];
                while (k <= l) {
                    arr.push({ rowIndex: i, colIndex: k });
                    k++;
                }
                i++;
            }
            return arr;
        },

        performSelection: function (startCell, endCell) {
            var sheetIdx = this.getActiveSheetIndex(), range, sheet = this.getSheet(sheetIdx), selCells = sheet._selectedCells, tname, tid, stMerge, endMerge, stRange, endRange;           
			if (typeof startCell === "string" || !this.getObjectLength(startCell)) {
                range = this._getRangeArgs(startCell, "object");
                startCell = { rowIndex: range[0], colIndex: range[1] };
                endCell = { rowIndex: range[2], colIndex: range[3] };
            }
			if(JSON.stringify(startCell) === JSON.stringify(selCells[0]) && (JSON.stringify(endCell) == JSON.stringify(selCells[selCells.length - 1]))) {
				sheet._startCell = startCell;
				sheet._endCell = endCell;
				this.model.allowSelection && this.XLSelection._refreshBorder();
				this._updateContextualTab(sheetIdx);
				return;
			}
            this.setActiveCell(startCell.rowIndex, startCell.colIndex);
            if (this.model.allowSelection) {
                stMerge = this.XLEdit.getPropertyValue(startCell.rowIndex, startCell.colIndex, "merge");
                endMerge = this.XLEdit.getPropertyValue(endCell.rowIndex, endCell.colIndex, "merge");
                if (stMerge) {
                    stRange = this.getRangeIndices(stMerge.mRange);
                    startCell = { rowIndex: stRange[0], colIndex: stRange[1] }
                }
                if (endMerge) {
                    endRange = this.getRangeIndices(endMerge.mRange);
                    endCell = { rowIndex: endRange[2], colIndex: endRange[3] }
                }
                this.XLSelection.selectRange(startCell, endCell);
            }
            if (this.model.allowAutoFill)
                this.XLDragFill.positionAutoFillElement();
            sheet._startCell = startCell;
            sheet._endCell = endCell;
			this._updateContextualTab(sheetIdx);
        },
		
		_updateContextualTab: function(sheetIdx) {
			var startCell = this.getSheet(sheetIdx)._startCell;
			if (this.model.showRibbon && !this._isScrolling) {
                this.XLRibbon._updateRibbonIcons();
                tname = this.XLEdit.getPropertyValue(startCell.rowIndex, startCell.colIndex, "tableName", sheetIdx);
                var rObj = $("#" + this._id + "_Ribbon").data("ejRibbon");
                if (tname) {
                    tid = this._getTableID(tname);
                    if (this.isNumber(tid))
                        this.XLRibbon._designTabUpdate(tid, startCell);
                }
                else if (this.model.showRibbon) {
                    if (rObj.model.selectedItemIndex === this.XLRibbon._getTabIndex("design") || rObj.isVisible(this._getLocStr("Design")))
                        this.XLRibbon._toggleDesignTab(startCell);
                    if (rObj.model.selectedItemIndex === this.XLRibbon._getTabIndex("format") || rObj.isVisible(this._getLocStr("FORMAT")))
                        this.XLRibbon._toggleFormatTab(startCell);
                    if (rObj.model.selectedItemIndex === this.XLRibbon._getTabIndex("chartdesign") || rObj.isVisible(this._getLocStr("CHARTDESIGN")))
                        this.XLRibbon._toggleChartDesignTab(startCell);
                    if (rObj.model.selectedItemIndex === this.XLRibbon._getTabIndex("analyze") || rObj.isVisible(this._getLocStr("ANALYZE")))
                        this.XLRibbon._toggleAnalyzeTab(startCell);
                    if (this.model.allowSparkline && rObj.model.selectedItemIndex === this.XLRibbon._getTabIndex("sparklinedesign") || rObj.isVisible(this._getLocStr("SPARKLINEDESIGN")))
                        this.XLSparkline._toggleSparklineDesignTab(startCell);
                }
            }
        },

        _checkRowCol: function (start, end) {
            if (start === 0 || end === 0)
                return;
            if (ej.isNullOrUndefined(end))
                end = start;
            return { start: start, end: end };
        },

        hideRow: function (startRow, endRow) {
            var rowColl = this._checkRowCol(startRow, endRow);
            this._hideRow(rowColl.start - 1, rowColl.end - 1, "isRHide");
        },

        showRow: function (startRow, endRow) {
            var rowColl = this._checkRowCol(startRow, endRow);
            this._showRow(rowColl.start, rowColl.end, "isRHide");
        },

        hideColumn: function (startCol, endCol) {
            var hideCol = this._checkRowCol(startCol, endCol);
            this._hideColumn(hideCol.start - 1, hideCol.end - 1);
        },

        showColumn: function (startCol, endCol) {
            var showCol = this._checkRowCol(startCol, endCol);
            this._showColumn(showCol.start, showCol.end);
        },

        _hideRow: function (startRow, endRow, type, isFrz) {
            var sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), rowColl = this.getRows(sheetIdx), rows = rowColl[1], hdrRows = rowColl[0], scrollSettings = this.model.scrollSettings, isVirtualScroll = scrollSettings.allowVirtualScrolling,
                hideRowsColl = sheet.hideRowsCollection, hRows = [], rowHtColl = sheet.rowsHeightCollection;
            if (!this._isUndoRedo && !isFrz) {
                this.XLEdit._updateDataContainer({ rowIndex: (startRow ? startRow - 1 : startRow), colIndex: 0 }, { dataObj: { hRow: true } });
                if (!isVirtualScroll)
                    this.addClass(this._getJSSheetRowHeaderContent(sheetIdx).find('.e-rowheader')[startRow ? startRow - 1 : startRow], "e-hrow");
            }
            for (var i = startRow; i <= endRow; i++) {
                if (type === "isRHide")
                    this.XLEdit._updateDataContainer({ rowIndex: i, colIndex: 0 }, { dataObj: { "isRHide": true } });
                hRows.push(i);
                if (hideRowsColl.indexOf(i) === -1) {
                    hideRowsColl.push(i);
                    if (!isVirtualScroll) {
                        if (this._isRowViewable(sheetIdx, i)) {
                            this.addClass(rows[i], "e-r-hide");
                            this.addClass(hdrRows[i], "e-r-hide");
                        }
                        if (scrollSettings.allowScrolling && (scrollSettings.scrollMode === ej.Spreadsheet.scrollMode.Infinite) && (!sheet._isImported || sheet._isLoaded))
                            if(!this._isFilter)
                                this.XLScroll._createNewRow(sheetIdx, -1, -1, "insert");
                            else {
                                sheet.rowsHeightCollection.push(this.model.rowHeight);
                                this._hideRowColl.push(sheet.rowCount++);
                            }
                    }
                    this.XLShape && this.XLShape._refreshShapePosOnResize(i, 0, false, sheetIdx);
                }
            }
            if (this.model.allowCellFormatting)
                this.XLFormat._refreshHiddenBorder(startRow, endRow, true, true);
            (!this._isFilter) && this.XLScroll._getRowHeights(sheetIdx, startRow);
            this._showHideRows(sheetIdx, sheet, hRows, startRow, endRow, isVirtualScroll, "hide");
            if ((!sheet._isImported || sheet._isLoaded) && !this._isFilter && !this._isExport) {
                this.model.allowComments && this.XLComment._updateCmntArrowPos();
                if (this._isFrozen(sheet.frozenRows)) {
                    if (startRow < sheet._frozenRows || endRow < sheet._frozenRows)
                        this.XLFreeze._refreshFreezeRowDiv();
                }
                if (this.model.scrollSettings.allowScrolling && !isVirtualScroll)
                    this.XLScroll._refreshScroller(sheetIdx, "refresh", "vertical");
                if (!this._isUndoRedo && !isFrz) {
                    sheet._activeCell.rowIndex = endRow + 1;
                    var details = { sheetIndex: sheetIdx, reqType: "show-hide", action: "hide", operation: "row", bSelect: { startRow: startRow, endRow: endRow }, aSelect: { startRow: endRow + 1, endRow: endRow + 1 }, addBRows: startRow ? [startRow - 1] : [startRow], remBRows: [], hideRows: hRows };
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
            }
            if (!isFrz && !this._isFilter) {
                this.XLSelection.selectRow(endRow + 1, sheetIdx);
                if (this.model.allowAutoFill)
                    this.XLDragFill.hideAutoFillElement();
            }
        },

        _showRow: function (startRow, endRow, type, isFrz, colHdr, colgrp, rowHdrTd) {
            var index, aSelect, sheetIdx = this.getActiveSheetIndex(), needActn = false, strtIdx = this._isUndoRedo ? startRow : (startRow - 1 > 0) ? startRow - 1 : 0, j = strtIdx, sheet = this.getSheet(sheetIdx), rowColl = this.getRows(sheetIdx), rows = rowColl[1], rowHeaders = rowColl[0], idx,
                hRows = [], addBRow = [], remBRow = [], rowHtColl = sheet.rowsHeightCollection, hideRowsColl = sheet.hideRowsCollection,
				emptyTable = ej.buildTag("table#wrapTable.e-table", {}), dataContainer = this._dataContainer.sheets[sheetIdx],
                isVirtualScroll = this.model.scrollSettings.allowVirtualScrolling, colWtColl = sheet.columnsWidthCollection;
            while (j <= endRow) {
                if (hideRowsColl.indexOf(j) > -1) {
                    needActn = true;
                    break;
                }
                j++;
            }
            if (!needActn)
                return false;
            colHdr = colHdr || this.getSheetElement(sheetIdx)[0].querySelectorAll('.e-spreadsheetcolumnheader');
            colgrp = colgrp || $(this._getJSSheetHeader(sheetIdx)[0].querySelectorAll('colgroup')[0].outerHTML).attr("id", "ss");
            rowHdrTd = rowHdrTd || this.getSheetElement(sheetIdx)[0].querySelectorAll(".e-rowheadercontent td");
            if (!isVirtualScroll) {
                emptyTable.append(colgrp);
                this.element[0].insertBefore(emptyTable[0], this.element[0].childNodes[0]);
            }
            if (this.model.allowCellFormatting)
                this.XLFormat._refreshHiddenBorder(startRow, endRow, true);
            for (j = strtIdx; j <= endRow; j++) {
                index = hideRowsColl.indexOf(j);
                if (index > -1) {
                    if (type === "isRHide")
                        delete dataContainer[j][0]["isRHide"];
                    hRows.push(j);
                    hideRowsColl.splice(index, 1);
                    if (!isVirtualScroll) {
                        this._removeClass(rows[j], "e-r-hide");
                        this._removeClass(rowHeaders[j], "e-r-hide");
                    }
                    if (!this._isUndoRedo && (j > 0) && !isFrz) {
                        remBRow.push(j - 1);
                        delete dataContainer[j - 1][0].hRow;
                        if (!isVirtualScroll)
                            this._removeClass(rowHdrTd[j - 1], "e-hrow");
                    }
                    else if (j === 0 && !isFrz) {
                        delete dataContainer[0][0].hRow;
                        if (!isVirtualScroll) {
                            colHdr.height(20.5);
                            this._removeClass(colHdr[0], "e-hrow");
                        }
                    }
                    this.XLShape && this.XLShape._refreshShapePosOnResize(j, rowHtColl[j] * 2, false, sheetIdx);
                }
                if (!isVirtualScroll) {
                    this._setWrapHeight(sheetIdx, j, rows, rowHeaders, emptyTable, "visible");
                    emptyTable.remove();
                }
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
            }
            if (!this._isFilter)
                this.XLScroll._getRowHeights(sheetIdx, strtIdx);
            this._showHideRows(sheetIdx, sheet, hRows, startRow, endRow, isVirtualScroll, "show");
            if (!isFrz)
                if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && !this._isFilter) {
                    if (startRow < endRow) {
                        this.setActiveCell(startRow, 0);
                        this.XLSelection.selectRows(startRow, endRow, sheetIdx);
                        aSelect = { startRow: startRow, endRow: endRow };
                    }
                    else {
                        if (startRow > 0) {
                            this.setActiveCell(startRow - 1, 0);
                            this.XLSelection.selectRow(startRow - 1, sheetIdx);
                            aSelect = { startRow: startRow - 1, endRow: startRow - 1 };
                        }
                    }
                    this.XLDragFill.positionAutoFillElement();
                    var details = { sheetIndex: sheetIdx, reqType: "show-hide", action: "show", operation: "row", bSelect: { startRow: startRow, endRow: endRow }, aSelect: aSelect, addBRows: addBRow, remBRows: remBRow, hideRows: hRows };
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
            if (this._isFrozen(sheet.frozenRows)) {
                if (startRow < sheet._frozenRows || endRow < sheet._frozenRows)
                    this.XLFreeze._refreshFreezeRowDiv();
            }
            if (!this._isFilter) {
                if ((!sheet._isImported || sheet._isLoaded) && this.model.allowComments)
                    this.XLComment._updateCmntArrowPos();
                if (this.model.scrollSettings.allowScrolling)
                    this.XLScroll._refreshScroller(sheetIdx, "refresh", "vertical");
            }
        },

        _showHideRows: function (sheetIdx, sheet, hRows, startRow, endRow, isVScroll, operation) {
            if (isVScroll) {
				(operation === "show") && this.refreshContent(sheetIdx);
				this._refreshViewport(this._isFrozen(sheet.frozenRows) ? sheet._contScrollTop : sheet._scrollTop, sheetIdx);
			}
            this._refreshSHMergeCells(sheetIdx, hRows, (endRow - startRow) + 1, "row", operation);
			if (isVScroll)
				(operation === "hide") && this.refreshContent(sheetIdx);            
			if (sheet.selectedRange[0] < startRow && sheet.selectedRange[2] > endRow) {
                this.model.allowSelection && this.XLSelection.selectRange(sheet._activeCell, sheet._activeCell);
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();
            }
        },

        _colgroupRefresh: function (sheetIdx) {
            if (this.model.allowResizing) {
                var headerCol = this._getJSSheetHeader(sheetIdx).find('colgroup');
                var contentCol = this._getContent(sheetIdx).find('colgroup');
            }
            var headerColClone = $(headerCol).clone();
            var contentColClone = $(contentCol).clone();
            $(contentCol).remove();
            $(headerCol).remove();
            $(headerColClone).prependTo(this._getJSSheetHeader(sheetIdx).find('.e-table'));
            $(contentColClone).prependTo(this._getContent(sheetIdx).find('.e-table'));
        },

        _updateFilterIcon: function (colIdx, status, sheetIdx) {
            ej.isNullOrUndefined(sheetIdx) && (sheetIdx = this.getActiveSheetIndex());
            var tableRange = this.getSheet(sheetIdx).filterSettings.tableRange, stRow, colIdxes, i, iLen;
            for (i = 0, iLen = tableRange.length; i < iLen; i++) {
                colIdxes = tableRange[i].multifilterIdx;
                if (colIdx >= colIdxes[0] && colIdx <= colIdxes[colIdxes.length - 1]) {
                    stRow = tableRange[i].startRow - 1;
                    if (this._isRowViewable(sheetIdx, stRow)) {
                        if (status === "hide")
                            this.addClass(this.getCell(stRow, colIdx).find(".e-filterspan")[0], "e-hide");
                        else
                            this._removeClass(this.getCell(stRow, colIdx).find(".e-filterspan")[0], "e-hide");
                    }
                    this.XLEdit._updateDataContainer({ rowIndex: stRow, colIndex: colIdx }, { dataObj: { isFilterVisible: (status != "hide") } });
                }
            }
        },

        _hideColumn: function (startCol, endCol) {
            var i, j, len, aSelect, fltrKeys, isViewed = false, sheetIdx = this.getActiveSheetIndex(), hdr = this._getJSSheetHeader(sheetIdx).find("th"), hdrcolgrp = this._getJSSheetHeader(sheetIdx).find("col"),
                filterSpan, isCHide, sheet = this.getSheet(sheetIdx), hideColsColl = sheet.hideColsCollection, hCols = [], addBCol = [], range, colgrp = this._getContent(sheetIdx).find("col"),
                filterColl = sheet._filterColl, fRowIdx, filterKeys, colWidthColl = sheet.columnsWidthCollection, colHdr = this.element.find('.e-spreadsheetcolumnheader');
            for (j = startCol; j <= endCol; j++) {
                this._getContent(sheetIdx).find(".e-rowcell:nth-child(" + (j + 1) + ")").addClass('e-soverflow');
                isCHide = this.XLEdit.getPropertyValue(0, j, "isCHide");
                if (this._isColumnViewable(sheetIdx, j))
                    isViewed = true;
                if (ej.isNullOrUndefined(isCHide)) {
                    this.XLShape && this.XLShape._refreshShapePosOnResize(j, 0, true, sheetIdx);
                    this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: j }, { dataObj: { isCHide: true } });
                    this._writeRule(j, sheetIdx);
                    if (isViewed) {
                        this.addClass(hdr[j], "e-hide");
                        this.addClass(hdrcolgrp[j], "e-hide");
                        this.addClass(colgrp[j], "e-hide");
                    }
                    hCols.push(j);
                    hideColsColl[j] = colWidthColl[j];
                    colWidthColl[j] = 0;
                    fltrKeys = this.getObjectKeys(filterColl);
                    for (i = 0, len = fltrKeys.length; i < len; i++) {
                        if (!ej.isNullOrUndefined(filterColl[fltrKeys[i]])) {
                            fRowIdx = fltrKeys[i];
                            if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(fltrKeys[i], j, "isSpanHide")))
                                this.XLEdit._updateDataContainer({ rowIndex: fltrKeys[i], colIndex: j }, { dataObj: { isSpanHide: true } });
                        }
                    }
                }
            }
            if (this.model.allowCellFormatting)
                this.XLFormat._refreshHiddenBorder(startCol, endCol, false, true);
            if (!this._isUndoRedo) {
                if (startCol)
                    addBCol.push(startCol - 1);
                else
                    addBCol.push(startCol);
                if (this._isColumnViewable(sheetIdx, startCol)) {
                    if (startCol === 0) {
                        colHdr.width(28);
                        this.addClass(colHdr[0], "e-hfcol");
                        this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: 0 }, { dataObj: { hCol: true } });
                    }
                    else {
                        this.XLEdit._updateDataContainer({ rowIndex: 0, colIndex: startCol - 1 }, { dataObj: { hCol: true } });
                        this.addClass(this._getJSSheetHeader(sheetIdx).find('th:eq(' + (startCol - 1) + ')')[0], "e-hcol");
                    }
                }
            }
            this._refreshSHMergeCells(sheetIdx, hCols, (endCol - startCol) + 1, "column", "hide");
            this.XLScroll._getColWidths(sheetIdx, startCol);
            if (this._isFrozen(sheet.frozenColumns)) {
				this.XLScroll._refreshContHgt(sheetIdx);
                if (startCol < sheet._frozenColumns || endCol < sheet._frozenColumns)
                    this.XLFreeze._refreshFreezeColDiv();
            }
            if (this.model.scrollSettings.allowScrolling)
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "horizontal");
            if (!sheet._isImported || sheet._isLoaded) {
                if (colWidthColl.length - 1 === endCol) {
                    this.XLSelection.selectColumn(endCol - 1, sheetIdx);
                    this.setActiveCell(0, endCol - 1);
                    aSelect = { startCol: endCol - 1, endCol: endCol - 1 };
                }
                else {
                    aSelect = { startCol: endCol + 1, endCol: endCol + 1 };
                    this.setActiveCell(0, endCol + 1);
                    this.XLSelection.selectColumn(endCol + 1, sheetIdx);
                }
                this.XLDragFill.positionAutoFillElement();
                if (!this._isUndoRedo) {
                    var details = { sheetIndex: sheetIdx, reqType: "show-hide", action: "hide", operation: "column", bSelect: { startCol: startCol, endCol: endCol }, aSelect: aSelect, hideCols: hCols, addBCols: addBCol, remBCols: [] };
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
                if (this.model.allowComments)
                    this.XLComment._updateCmntArrowPos();
            }
            else
                this.setActiveCell(0, 0);
            if (this._browserDetails.name.indexOf("msie") > -1)
                this._colgroupRefresh(sheetIdx);
        },

        _showColumn: function (startCol, endCol) {
            var j, aSelect, sheetIdx = this.getActiveSheetIndex(), colIdx = this._isUndoRedo ? startCol : (startCol - 1 > 0) ? startCol - 1 : 0, sheet = this.getSheet(sheetIdx), hideColsColl = sheet.hideColsCollection,
				hCols = [], addBCol = [], isViewed = false, remBCol = [], hdr = this._getJSSheetHeader(sheetIdx).find("th"), colgrp = this._getContent(sheetIdx).find("col"),
                hdrcolgrp = this._getJSSheetHeader(sheetIdx).find('col'), range, colWtColl = sheet.columnsWidthCollection, colHdr = this.element.find('.e-spreadsheetcolumnheader');
            if (this.model.allowCellFormatting)
                this.XLFormat._refreshHiddenBorder(startCol, endCol);
            for (j = colIdx; j <= endCol; j++) {
                this._getContent(sheetIdx).find(".e-rowcell:nth-child(" + (j + 1) + ")").removeClass('e-soverflow');
                if (j in hideColsColl) {
                    this._deleteRule(j, sheetIdx);
                    this._isColumnViewable(sheetIdx, j) && (isViewed = true);
                    if (isViewed) {
                        this._removeClass(hdr[j], "e-hide");
                        this._removeClass(hdrcolgrp[j], "e-hide");
                        this._removeClass(colgrp[j], "e-hide");
                        colgrp[j].style["width"] = hideColsColl[j] + "px";
                        hdrcolgrp[j].style["width"] = hideColsColl[j] + "px";
                    }
                    colWtColl[j] = hideColsColl[j];
                    delete hideColsColl[j];
                    delete this._dataContainer.sheets[sheetIdx][0][j]["isCHide"];
                    if (this.model.allowFiltering)
                        this._updateFilterIcon(j, "show", sheetIdx)
                    hCols.push(j);
                    if (!this._isUndoRedo && (j > 0)) {
                        isViewed && this._removeClass(hdr.get(j - 1), "e-hcol");
                        delete this._dataContainer.sheets[sheetIdx][0][j - 1]["hCol"];
                        remBCol.push(j - 1);
                    }
                    else if (j === 0) {
                        colHdr.width(29);
                        this._removeClass(colHdr[0], "e-hfcol");
                        delete this._dataContainer.sheets[sheetIdx][0][0]["hCol"];
                    }
                    this.XLShape && this.XLShape._refreshShapePosOnResize(j, colWtColl[j] * 2, true, sheetIdx);
                }
            }
            this._refreshSHMergeCells(sheetIdx, hCols, (endCol - startCol) + 1, "column", "show");
            this.XLScroll._getColWidths(sheetIdx, colIdx);
            if (!this._isUndoRedo && (!sheet._isImported || sheet._isLoaded)) {
                if (startCol < endCol) {
                    this.XLSelection.selectColumns(startCol, endCol, sheetIdx);
                    aSelect = { startCol: startCol, endCol: endCol };
                }
                else {
                    this.XLSelection.selectColumn(colIdx, sheetIdx);
                    aSelect = { startCol: colIdx, endCol: colIdx };
                }
                this.XLDragFill.positionAutoFillElement();
                var details = { sheetIndex: sheetIdx, reqType: "show-hide", action: "show", operation: "column", bSelect: { startCol: startCol, endCol: endCol }, aSelect: aSelect, addBCols: addBCol, remBCols: remBCol, hideCols: hCols };
                this._completeAction(details);
                this._trigActionComplete(details);
            }
            if (this._browserDetails.name.indexOf("msie") > -1)
                this._colgroupRefresh(sheetIdx);
            if ((!sheet._isImported || sheet._isLoaded) && this.model.allowComments)
                this.XLComment._updateCmntArrowPos();
            if (this._isFrozen(sheet.frozenColumns)) {
                if (startCol < sheet._frozenColumns || endCol < sheet._frozenColumns)
                    this.XLFreeze._refreshFreezeColDiv();
            }
            if (this.model.scrollSettings.allowScrolling)
                this.XLScroll._refreshScroller(sheetIdx, "refresh", "horizontal");
        },

        _refreshHideRowColCollection: function (collection, idx, count, type, action) {
            var coll;
            if (type === "row") {
                for (var i = 0; i < collection.length; i++) {
                    if (collection[i] >= (idx + count)) {
                        if(action === "insert")
                            collection[i] += count;
                        else
                            collection[i] -= count;
                        break;
                    }
                }
            }
            else {
                coll = this.getObjectKeys(collection);
                for (var i = coll.length - 1; i >= 0; i--) {
                    if (coll[i] >= (idx + count)) {
                        if (action === "insert") {
                            collection[parseInt(coll[i]) + count] = collection[coll[i]];
                            delete collection[coll[i]];
                        }
                        else {
                            collection[parseInt(coll[i]) - count] = collection[coll[i]];
                            delete collection[coll[i]];
                        }
                        break;
                    }
                }
            }
        },

        _destroySheet: function (index) {
            this.element.find("#" + this._id + "_" + this.model.sheets[index].sheetInfo.value).empty();
        },
        _destroy: function () {
            var name, i = 1, calcObj;
            if (this.isImport || this._isNew) {
                while (i <= this.model.sheetCount) {
                    delete $.templates[this._id + "JSONTemplate" + i];
                    delete $.templates[this._id + "JSONRowHdrTemplate" + i];
                    name = this.getSheet(i).sheetInfo.value;
                    CalcEngine.unregisterGridAsSheet(name, name);
                    i++;
                }
                this.model.sheets = [];
                this.model.nameManager = [];
                this._sheets = [];
                this.getActivationPanel().empty();
                if (this.model.enablePivotTable)
                    this.XLPivot._hasPvtField = false;
                this.isDirty = false;
                if (this.isImport) {
                    this._detachTable = null;
                    this._updateFormulaCollection();
                    if (this.XLFormat._isHeaderAdded) {
                        for (var i = 0; i < 2 ; i++)
                            $("#" + this._id + "_cellstyles").children().eq(0).remove();
                        this.XLFormat._isHeaderAdded = false;
                    }
                }
                else {
                    document.getElementById(this._id + "_nmgrid") && $("#" + this._id + "_nmgrid").ejGrid("option", { dataSource: [] });
                    this._dataContainer = { sheets: {}, hashCode: [], sharedData: [], cellType: [], valData: [], cFormatData: [], customCellStyle: {} };
                    this.XLRibbon._updateUseInFormulaTrgt();
                    this.XLEdit._refreshAutoComplete();
                }
                this.element.append([this.getFocusTopElem(), this.getFocusRightElem(), this.getFocusBottomElem(), this.getFocusLeftElem(), this.getAutoFillElem(), this._getAutoFillOptElem()]);
                this.element.find(".e-spreadsheet-list .e-sheet").remove();
                document.getElementById($("#" + this._id + "ddl")) && $("#" + this._id + "ddl").data('ejDropDownList').destroy();
                $("#" + this._id + "ddl").remove();
                this._tableCnt = this._newSIndex = 1;
                if (this.XLChart)
                    this.XLChart._shapeCnt = 1;
                CalcEngine._tokenCount = 0;
                this._isVPRendered = false;
            }
            else {
                this._wireEvents("_off");
                this._destroySubControls();
                this.element.empty();
                this.element.css({ "height": "", "width": "", "min-height": "", "min-width": "" });
                this.element.removeAttr("tabindex");
                this.element.removeEleEmptyAttrs();
                this._removeClass(this.element[0], "e-spreadsheet e-js");
                this.model.cssClass.length && this._removeClass(this.element[0], this.model.cssClass);
                $("#" + this._id + " _formatastable").parent().remove();
                $("#" + this._id + " _cellstyles").parent().remove();
                $("#" + this._id + "_Ribbon_Home_Font_BorderColor_popup").remove();
            }
			if(!this._isRefresh) {
				$("#" + this._id + "_sscustomformat").remove();
				document.getElementById(this._id + "_sshide") && (document.getElementById(this._id + "_sshide").outerHTML ='');
				calcObj = this.getCalcEngine();
				calcObj.getFormulaInfoTable().clear();
				calcObj.getDependentCells().clear();
				calcObj.getDependentFormulaCells().clear();
				calcObj.getNamedRanges().clear();
				calcObj.getDependentNamedRangeCells().clear();
			}
			this._isRibbonDestroyed = true;
        },

        _destroySubControls: function () {
            var dlgs, id = this._id, ddl, ddlItem;
            //destroying dropdown list
            ddl = $("span.e-" + id + "-ddl input.e-dropdownlist");
            if (ddl.length)
                for (var i = 0, len = ddl.length; i < len; i++) {
                    ddlItem = $(ddl[i]).data("ejDropDownList")
                    if (ddlItem)
                        ddlItem.destroy();
                }
            if (this.model.allowFiltering) {
                var custddl = $(".e-" + this._id + "_customddl");
                custddl.length && custddl.ejDropDownList("destroy").remove();
                var strip = $("#" + this._id + "_filter_custom_string_acString"), numip = $("#" + this._id + "_filter_custom_number_acString"), dateip = $("#" + this._id + "_filter_custom_date_acString");
                strip.length && strip.ejAutocomplete("destroy").remove();
                numip.length && numip.ejNumericTextbox("destroy").remove();
                dateip.length && dateip.ejDatePicker("destroy").remove();
            }
            $("#" + this._id + "_colordlg_cpicker").ejColorPicker("destroy").remove();
            if (this.model.showRibbon) {
                this.XLRibbon && this.XLRibbon._rbnDestroy({ destroy: true });
                $(".e-" + this._id + "-spltbtn").ejSplitButton("destroy");
                $("#" + this._id + "_Ribbon").ejRibbon("destroy");
            }
            document.getElementById(this._id + "_nmgrid") && $("#" + this._id + "_nmgrid").ejGrid("destroy");
            //Removing dialogs appended in body
            dlgs = $(".e-" + id + "-dlg");
            if (dlgs.length)
                dlgs.remove();
            if (this.model.allowFormulaBar)
                $("#" + this._id + "_inputbox").ejAutocomplete("destroy");
            $("#" + this._id + "_AutoComplete").ejAutocomplete("destroy");
            if (this.model.allowAutoFill)
                $("#" + this._id + "_dragfilloptionbtn").ejSplitButton("destroy")
            if (this.model.enableContextMenu) {
                $("#" + this._id + "_contextMenuCell").ejMenu("destroy").remove();
                $("#" + this._id + "_contextMenuColumnHeader").ejMenu("destroy").remove();
                $("#" + this._id + "_contextMenuRowHeader").ejMenu("destroy").remove();
                $("#" + this._id + "_contextMenuFooter").ejMenu("destroy").remove();
                $(".e-" + id + "-cmenu").remove();
            }
            if (this.model.allowFiltering) { //destroy filter
                this._excelFilter && this._excelFilter.resetExcelFilter();
                $("#" + this._id + "number_excelDlg").remove();
                $("#" + this._id + "string_excelDlg").remove();
                $("#" + this._id + "date_excelDlg").remove();
            }
            $("#" + this._id + "_copyPaste").remove();
            $("#" + this._id + "_wait").ejWaitingPopup("destroy");
            $("#" + this._id + "_wait").remove();
			this.XLRibbon._isAppTabCreate = false,
			this.XLRibbon._isHomeTabCreate = false,
			this.XLRibbon._isInsertTabCreate = false,
			this.XLRibbon._isDataTabCreate = false,
			this.XLRibbon._isPageLayoutTabCreate = false,
			this.XLRibbon._isReviewTabCreate = false,
			this.XLRibbon._isOthersTabCreate = false,
			this.XLRibbon._isDesignTabCreate = false,
			this.XLRibbon._isFormatTabCreate = false,
			this.XLRibbon._isChartTabCreate = false,
			this.XLRibbon._analyzeTabCreate = false,
			this.XLRibbon._isHomeTabTrgt = false;
			this.XLRibbon._isInsertTabTrgt = false;
            this.XLRibbon._isDataTabTrgt = false;
            this.XLRibbon._isPageLayoutTabTrgt = false;
            this.XLRibbon._isOthersTabTrgt = false;
            this.XLRibbon._isChartTabTrgt = false;
            this.XLRibbon._analyzeTabTrgt = false;
            this.XLRibbon._isFormatTabTrgt = false;
            this.XLRibbon._isDesignTabTrgt = false;
			this._focusTopElem = null;
            this._focusRightElem = null;
            this._focusBottomElem = null;
            this._focusLeftElem = null;
			this._autoFillElem = null;
            this._autoFillOptElem = null;
        },

        _getXYPos: function ($target, $element, diffHt, diffWt) {
            var elemTop = this.element.offset().top, elemLeft = this.element.offset().left, dlgHeight = $element.height(), dlgWidth = $element.width(), xPos = $target.offset().left - elemLeft, yPos = $target.offset().top - elemTop;
            if ((yPos + diffHt + dlgHeight) > this._responsiveHeight)
                yPos = yPos - ((yPos + diffHt + dlgHeight) - this._responsiveHeight) + (elemTop - 6); //6 for borders
            else
                yPos += elemTop;
            if (yPos < elemTop)
                yPos += elemTop - yPos;
            if ((xPos + diffWt + dlgWidth) > this._responsiveWidth)
                xPos = xPos - ((xPos + diffWt + dlgWidth) - this._responsiveWidth) + (elemLeft - 6); //6 for borders
            else
                xPos += elemLeft + diffWt;
            if (xPos < elemLeft)
                xPos += elemLeft - xPos;
            return { xPos: xPos, yPos: yPos };
        },

        getValueRowCol: function (sheetIdx, rowIdx, colIdx) {
            var sheetIdx = this._getSheetIdxFromSheetValue(this._getLocStr("Sheet") + sheetIdx), sheet = this.getSheet(sheetIdx), val;
            if (sheetIdx == -1)
                return "#REF!";
            if (sheet._isImported && !sheet._isRequested) {
                this._intrnlReq = true;
                this._importSheet(sheetIdx, false);
            }
            val = this.XLEdit.getPropertyValue(rowIdx - 1, colIdx - 1, "value", sheetIdx);
            if (this.isFormula(val)) {
                val = this.XLEdit.getPropertyValue(rowIdx - 1, colIdx - 1, "value2", sheetIdx);
				val = val.replace(this._currencySymbol, "");
				if (val[0] == "%" || val[val.length - 1] == "%") {
					val = val.split("%").join("");
					var per = parseFloat(val);
					(!isNaN(per)) && (val = (per / 100).toString());
				}
				val = val.replace(this._percentSymbol, "");	
			}
            return val;
        },

        setValueRowCol: function (sheetIdx, value, rowIdx, colIdx) {
            rowIdx--, colIdx--;
            if ((rowIdx === -2) && (colIdx === -2))
                return;
            var cellInfo, value2, cellIdx = { rowIndex: rowIdx, colIndex: colIdx }, skipCell = false, obj, args, formulaStr, temp, j, flen, fObj, isFrmtNeeded = true;
            if (typeof value === "string")
                value = value.replace(/^\"|\"$/g, "");
            if (typeof value == "object")
                value = value.toString();
            sheetIdx = this._getSheetIdxFromSheetValue(this._getLocStr("Sheet") + sheetIdx);
            cellInfo = this.getRangeData({ range: [rowIdx, colIdx, rowIdx, colIdx], property: ["value", "formatStr", "type", "thousandSeparator", "decimalPlaces"], sheetIdx: sheetIdx })[0];
            if(!ej.isNullOrUndefined(cellInfo.value)) {
				formulaStr = this.XLDragFill._parseFormula(cellInfo.value);
				for (j = 0, flen = formulaStr.length; j < flen; j++) {
					temp = formulaStr[j];
					if (temp.indexOf(":") > -1)
						temp = temp.split(":")[0];
					if (this._isCellReference(temp)) {
						temp = temp.replace(/\$/g, "");
						fObj = this.getRangeData({ range: this.getRangeIndices(temp), property: ["type"] })[0];
						if (fObj.type == "text") {
							isFrmtNeeded = false;
						}
						break;
					}
				}
			}
            if (isFrmtNeeded && cellInfo.formatStr && !this._isFormulaError(value)) {
                if (isNaN(parseInt(value)) && !isNaN(Date.parse(value)))
                    value = new Date(value);
                value2 = this.XLFormat._format(value, { formatStr: cellInfo.formatStr, type: cellInfo.type, thousandSeparator: cellInfo.thousandSeparator, decimalPlaces: cellInfo.decimalPlaces });
            }
            if (isFrmtNeeded && cellInfo.type == "fraction")
                value2 = this.XLFormat._format(value, { type: cellInfo.type });
            value2 = ej.isNullOrUndefined(value2) ? value : value2;
            if (this._isInitLoad && !this.isImport)
                skipCell = true;
            if (this.model.locale !== "en-US" && this.isNumber(value2))
                value2 = this._getlocaleNumVal(value2, true);
            obj = { value2: value2, calcValue: this.XLEdit._parseValue(value, { rowIndex: rowIdx, colIndex: colIdx }).value };
            cellInfo.type && (obj.type = cellInfo.type);
            args = {
                isRefCells: true,
                calcValue: obj.calcValue,
                value: cellInfo.value,
                rowIndex: rowIdx,
                colIndex: colIdx
            };
            if (!this._isInitLoad && !this.isImport && (this.XLEdit._EditCellDetails.rowIndex !== rowIdx || this.XLEdit._EditCellDetails.columnIndex !== colIdx) && this._trigger("cellSave", args))
                return;
            this.XLEdit._updateDataContainer(cellIdx, { dataObj: obj, sheetIdx: sheetIdx, skipCell: skipCell });
            this.XLEdit._refreshCellAlignment({ cellIdx: cellIdx, value: value, type: cellInfo.type });
        },

        getActiveCellElem: function (sheetIdx) {
            sheetIdx = this._getSheetIndex(sheetIdx);
            var sheet = this.getSheet(sheetIdx);
            return this.getCell(sheet._activeCell.rowIndex, sheet._activeCell.colIndex, sheetIdx);
        },

        //HyperLink 
        _hlDlgOpen: function () {
            var sheetIdx = this.getActiveSheetIndex(), selected = this.getActiveCellElem(sheetIdx), propValue;
            if (!selected.length || !this.model.allowEditing)
                return false;
            if (this.XLEdit._rangeHasProperty(this.getSheet(sheetIdx).selectedRange, "cellType")) {
                this._showAlertDlg("Alert", "CellTypeAlert", "CellTypeAlert", 372);
                return;
            }
            var xlId = this._id, hlTabObj, webAddrElem = $("#" + xlId + "_Ribbon_webAddress"), cellAddrElem = $("#" + xlId + "_Ribbon_cellAddress"), webValElem = $("#" + xlId + "_Ribbon_findText"), value;
            var data = this.XLEdit.getPropertyValue(selected.parent("tr").index(), selected[0].cellIndex, "hyperlink", sheetIdx), node, treeObj, cellValElem = $("#" + xlId + "_Ribbon_cellText");
            $("#" + xlId + "_HLDialog").ejDialog("open");
            (this._responsiveHeight < 365) && $("#" + this._id + "_HLDialog_wrapper").css('top', '0px');
            treeObj = $("#" + xlId + "_Ribbon_sheentName").data("ejTreeView");
            treeObj.option("fields", { dataSource: this.XLRibbon._sheetData() });
            hlTabObj = $("#" + xlId + "_HLDialogTab").data("ejTab");
            cellValElem.attr("disabled", false);
            webValElem.attr("disabled", false);
            if (!this.isUndefined(data)) {
                this.isUndefined(data.webAddr) ? hlTabObj.option({ selectedItemIndex: 1 }) : hlTabObj.option({ selectedItemIndex: 0 });
                if (!this.isUndefined(data.cellAddr)) {
                    cellAddrElem.val(data.cellAddr.split("_")[0]);
                    node = parseInt(data.cellAddr.split("_")[1]) + 1;
                    treeObj.selectNode(node);
                    webAddrElem.val("http://");
                }
                else {
                    webAddrElem.val(data.webAddr);
                    cellAddrElem.val("A1");
                }
            }
            else {
                if (hlTabObj.model.selectedItemIndex === 0) {
                    webAddrElem.val("http://");
                    cellValElem.val("");
                }
                else {
                    treeObj.selectNode(sheetIdx + 1);
                    cellValElem.val(treeObj.getText(sheetIdx + 1) + "!A1");
                    cellAddrElem.val("A1");
                }
            }
            if ($.validator) {
                $("#" + xlId + "_Form_Ribbon_cellAddress").validate().resetForm();
                $("#" + xlId + "_Form_Ribbon_webAddress").validate().resetForm();
            }
            webValElem.val("");
            value = this.XLEdit.getPropertyValueByElem(selected);
            if (!this.isUndefined(value)) {
			    propValue = this.XLEdit.getPropertyValueByElem(selected, "type");
                if (this.isFormula(value) || (propValue && propValue.indexOf("date") > -1) || $.isNumeric(value) || (propValue && propValue.indexOf("time") > -1)) {
                    cellValElem.val(this._getLocStr("HyperLinkHide"));
                    webValElem.val(this._getLocStr("HyperLinkHide"));
                    cellValElem.attr("disabled", true);
                    webValElem.attr("disabled", true);
                }
                else {
                    cellValElem.val(value);
                    webValElem.val(value);
                }
            }
        },


        _setLink: function (selCells) {
            var cellText, cellAddr, webText, webAddr, range, sheetIdx, treeObj, actShtIdx = this.getActiveSheetIndex(), linkAdr, value, cell = this.getActiveCell(actShtIdx), cellVal, tabIdx;
            range = this.getSheet(actShtIdx).selectedRange;
            !$("#" + this._id + "_HLDialog").length && this.XLRibbon._initHLDialog();
            tabIdx = $("#" + this._id + "_HLDialogTab").ejTab("option", "selectedItemIndex");
            cellText = $("#" + this._id + "_Ribbon_cellText").val();
            cellAddr = $("#" + this._id + "_Ribbon_cellAddress").val();
            webText = $("#" + this._id + "_Ribbon_findText").val();
            webAddr = $("#" + this._id + "_Ribbon_webAddress").val();
            treeObj = $("#" + this._id + "_Ribbon_sheentName").data("ejTreeView"), sheetIdx = this._getSheetIndexByName(treeObj.getSelectedNode().text() || this._getSheetNames()[this.getActiveSheetIndex() - 1].text);
            if (!cellText.length && !webText.length) {
                cellText = treeObj.getSelectedNode().text() + "!" + cellAddr;
                webText = webAddr;
            }
            cellVal = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex);
            this._prevText = ej.isNullOrUndefined(cellVal) ? "" : this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "value2");
            this._prevVal = ej.isNullOrUndefined(cellVal) ? "" : this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "value");
            if (this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "type") && (this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "type").indexOf("date") > -1 || this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "type").indexOf("time") > -1))
                value = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "value2");
            else if ($.isNumeric(cellVal) || this.isFormula(cellVal))
                value = cellVal;
            else
                value = (tabIdx === 0) ? webText : cellText;
            if (this._isUndoRedo)
                value = selCells[0].prevText;
            this.XLEdit._updateCellValue(cell, value);
            (this.isFormula(value) || $.isNumeric(value)) && (value = this.XLEdit.getPropertyValue(cell.rowIndex, cell.colIndex, "value2"));
            linkAdr = (tabIdx === 0) ? { webAddr: webAddr, text: value } : { cellAddr: cellAddr, text: value };
            this.setHyperlink(this._getAlphaRange(actShtIdx, range[0], range[1], range[2], range[3]), linkAdr, sheetIdx, selCells);
            this._dlgHLClick = false;
        },

        _getRangeArgs: function (range, type, sheetIdx) {
            if (ej.isNullOrUndefined(range))
                range = this.getSheet(sheetIdx).selectedRange;
            if (type === typeof (range))
                return range;
            else {
                if (typeof (range) === "object")
                    return this._getAlphaRange(this.getActiveSheetIndex(), range[0], range[1], range[2], range[3]);
                else
                    return this.getRangeIndices(range);
            }
        },

        setHyperlink: function (range, linkRefer, sheetIdx, selCells) {
            range = this._getRangeArgs(range, "string");
            if (this.model.allowHyperlink && !this.model.isReadOnly) {
                var args = {
                    range: range,
                    address: linkRefer.webAddr,
                    text: linkRefer.text,
                    sheetIndex: sheetIdx,
                    reqType: "hyperlink",
                    action: "add"
                };
                if (this.XLEdit._rangeHasProperty(range, "cellType")) {
                    this._showAlertDlg("Alert", "CellTypeAlert", "CellTypeAlert", 372);
                    return;
                }
                if (this._trigActionBegin(args))
                    return;
                range = args.range, linkRefer.webAddr = args.address, linkRefer.text = args.text, sheetIdx = args.sheetIndex;
                var cellText, cellAddr, evtArgs, webText, webAddr, isViewed, rng, selCellObj, actSheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(actSheetIdx), splitStr, value, selCell = [], data, val, i, len, selected = this._getAlphaRangeCells(range);
                var details = { sheetIndex: this.getActiveSheetIndex(), reqType: "hyperlink" }, cValue, cellVal;
                rng = this._getRangeArgs(range, "object");
                selCellObj = this._getSelectedCells(details.sheetIndex, rng).selCells;
                details.action = ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCellObj[0].rowIndex, selCellObj[0].colIndex, "hyperlink")) ? "add" : "edit";
                if (!this._isUndoRedo) {
                    if (!ej.isNullOrUndefined(linkRefer.webAddr)) {
                        webAddr = linkRefer.webAddr;
                        webText = !ej.isNullOrUndefined(linkRefer.text) ? linkRefer.text : this.XLEdit.getPropertyValue(selCellObj[0].rowIndex, selCellObj[0].colIndex, "value2");
                        value = ej.isNullOrUndefined(webText) ? webAddr : webText;
                    }
                    else {
                        cellAddr = linkRefer.cellAddr;
                        cellText = !ej.isNullOrUndefined(linkRefer.text) ? linkRefer.text : this.XLEdit.getPropertyValue(selCellObj[0].rowIndex, selCellObj[0].colIndex, "value2");
                        if (cellAddr.indexOf("!") > -1) {
                            splitStr = cellAddr.split("!");
                            sheetIdx = splitStr[0].indexOf("=") > -1 ? this._getSheetIndexByName(splitStr[0].split("=")[1]) : this._getSheetIndexByName(splitStr[0]);
                            cellAddr = splitStr[1];
                        }
                        cellAddr.indexOf("$") > -1 && (cellAdr = cellAddr.split("$").join(""));
                        value = ej.isNullOrUndefined(cellText) ? cellAddr : cellText;
                    }
					this._dupDetails = true;
                    if (!this._dlgHLClick) {
                        cellVal = this.XLEdit.getPropertyValue(selCellObj[0].rowIndex, selCellObj[0].colIndex, "value2");
                        this._prevText = ej.isNullOrUndefined(cellVal) ? "" : cellVal;
						this._prevVal = ej.isNullOrUndefined(cellVal) ? "" : this.XLEdit.getPropertyValue(selCellObj[0].rowIndex, selCellObj[0].colIndex, "value");
                        this.XLEdit._updateCellValue({ rowIndex: selCellObj[0].rowIndex, colIndex: selCellObj[0].colIndex }, value);
                    }
                    for (i = 0, len = selCellObj.length; i < len; i++)
                        selCell.push({ rowIndex: selCellObj[i].rowIndex, colIndex: selCellObj[i].colIndex, prevLink: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink"), prevColor: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "formats") });
                    !this.isUndefined(args.text) && this.XLEdit._updateCellValue(selCellObj[0], args.text);
                    (this.isUndefined(cellAddr)) ? this.updateUniqueData({ hyperlink: { "webAddr": webAddr } }, rng) : this.updateUniqueData({ hyperlink: { "cellAddr": cellAddr + "_" + (sheetIdx) } }, rng);
                    for (i = 0, len = selCellObj.length; i < len; i++) {
                        val = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "value2");
                        selCell[i].prevText = (i === 0) ? this._prevText : val;
                        selCell[i].prevVal = (i === 0) ? this._prevVal : this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "value");
                        if (this._isRowViewable(actSheetIdx, selCellObj[i].rowIndex)) {
                            $(selected.eq(i).find("a")).remove();
                            this.XLEdit._refreshTextNode(selected[i]);
                            isViewed = true;
                        }
                        data = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink", actSheetIdx);
                        if (data.cellAddr) {
                            val = (i === 0) ? cellText : val;
                            isViewed && selected.eq(i).append(ej.buildTag("a", val, ""));
                            selCell[i].curText = cellText;
                        }
                        else {
                            val = (i === 0) ? webText : val;
                            isViewed && selected.eq(i).append(ej.buildTag("a", val, "", { href: data.webAddr, target: "_blank" }));
                            selCell[i].curText = webText;
                        }
                        selCell[i].curLink = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink");
                        if (isViewed)
                            $(selected[i]).find("a").addClass("e-hyperlinks");
                    }
                    this.XLFormat.format({ "style": { "color": this._hlColor } }, range);
                    this._dupDetails = false;
                    details.selectedCell = selCell;
                    evtArgs = { sheetIndex: this.getActiveSheetIndex(), range: range, linkData: linkRefer, reqType: "hyperlink", selectedCell: details.selectedCell, action: details.action };
                    if (!sheet._isImported || sheet._isLoaded && !this._isExport) {
                        this._completeAction(details);
                        this._trigActionComplete(evtArgs)
                    }
                }
                else {
                    for (i = 0, len = selCellObj.length; i < len; i++) {
                        if (selCells && !ej.isNullOrUndefined(selCells[i]) && !ej.isNullOrUndefined(selCells[i].prevLink)) {
                            this.XLEdit._updateDataContainer({ rowIndex: selCellObj[i].rowIndex, colIndex: selCellObj[i].colIndex }, { dataObj: { "hyperlink": selCells[i].prevLink } });
                            if (this._isRowViewable(sheetIdx, selCellObj[i].rowIndex)) {
                                cValue = $(selected[i]).text();
                                $(selected[i]).find("a").remove();
                                (selected[i].lastChild) ? selected[i].lastChild.textContent = "" : $(selected[i]).text("");
                                if (i === 0) {
                                    if (!(ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink").cellAddr)))
                                        $(selected[i]).append(ej.buildTag("a", selCells[i].prevText, ""));
                                    else
                                        $(selected[i]).append(ej.buildTag("a", selCells[i].prevText, "", { href: this.XLEdit.getPropertyValueByElem($(selected[i]), "hyperlink").webAddr, target: "_blank" }));
                                }
                                else {
                                    if (!(ej.isNullOrUndefined(this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink").cellAddr)))
                                        $(selected[i]).append(ej.buildTag("a", cValue, ""))
                                    else
                                        $(selected[i]).append(ej.buildTag("a", cValue, "", { href: this.XLEdit.getPropertyValueByElem($(selected[i]), "hyperlink").webAddr, target: "_blank" }));
                                }
                                $(selected[i]).find("a").addClass("e-hyperlinks");
                            }
                            this._dupDetails = true;
                            this.XLFormat.format({ style: { color: this._hlColor } });
                            this._dupDetails = false;
                        }
                    }
                }
            }
        },

        removeHyperlink: function (range, isClearHLink, status, cells, skipHiddenRow) {
            if (!this.model.allowHyperlink || this.model.isReadOnly)
                return false;
            var i, len, obj, color, rLink = [], temp = this._dupDetails, selCellObj, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), selCell = [], cell;
            var details = { sheetIndex: sheetIdx, reqType: "hyperlink", action: "delete", range: range };
            selCellObj = this._getMultiRangeCells(range);
            for (i = 0, len = selCellObj.length; i < len; i++) {
                if (!skipHiddenRow || !this._isHiddenRow(selCellObj[i].rowIndex)) {
                    obj = { rowIndex: selCellObj[i].rowIndex, colIndex: selCellObj[i].colIndex, prevLink: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink"), prevText: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "value2"), prevVal: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "value"), prevColor: this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "formats") };
                    this._dupDetails = true;
                    if (obj.prevLink) {
                        if (isClearHLink)
                            this.XLFormat.format({ style: { "text-decoration": "underline" } }, this._getAlphaRange(sheetIdx, selCellObj[i].rowIndex, selCellObj[i].colIndex, selCellObj[i].rowIndex, selCellObj[i].colIndex));
                        else {
                            if (!ej.isNullOrUndefined(cells) && !this.isUndefined(cells[i].prevColor))
                                color = cells[i].prevColor.color;
                            this.XLFormat.format({ style: { color: this.isUndefined(color) ? "#444445" : color, "text-decoration": "none" } }, this._getAlphaRange(sheetIdx, selCellObj[i].rowIndex, selCellObj[i].colIndex, selCellObj[i].rowIndex, selCellObj[i].colIndex));
                        }
                        obj.curColor = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "formats");
                    }
                    this._dupDetails = temp;
                    this.clearRangeData([selCellObj[i].rowIndex, selCellObj[i].colIndex, selCellObj[i].rowIndex, selCellObj[i].colIndex], ["hyperlink"]);
                    !this._isUndoRedo && (obj.curLink = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "hyperlink"));
                    if (this._isUndoRedo && !this._dupDetails)
                        !ej.isNullOrUndefined(cells[i].prevText) && this.XLEdit._updateDataContainer({ rowIndex: selCellObj[i].rowIndex, colIndex: selCellObj[i].colIndex }, { dataObj: { "value2": cells[i].prevText, "value": cells[i].prevVal }, sheetIdx: sheetIdx });
                    !this._isUndoRedo && (obj.curText = this.XLEdit.getPropertyValue(selCellObj[i].rowIndex, selCellObj[i].colIndex, "value2"));
                    if ((this._isUndoRedo && !this._dupDetails) && !ej.isNullOrUndefined(cells[i].prevLink)) {
                        this.XLEdit._updateDataContainer({ rowIndex: selCellObj[i].rowIndex, colIndex: selCellObj[i].colIndex }, { dataObj: { "hyperlink": cells[i].prevLink } });
                        cell = { rowIndex: cells[i].rowIndex, colIndex: cells[i].colIndex };
                        this.XLSelection.selectRange(cell, cell);
                        this._setLink([cells[i]]);
                        rLink.push(i);
                    }
                    selCell.push(obj);
                }
            }
            for (i = 0, len = rLink.length; i < len; i++)
                selCellObj.splice(rLink[i], 1);
            details.selectedCell = selCell;
            details.reqType = (ej.isNullOrUndefined(status)) ? "hyperlink" : "clear-link";
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && !this._dupDetails && !this._isExport) {
                this._completeAction(details);
                this._trigActionComplete(details);
            }
        },

        _removeHyperlink: function (status, cells, skipHiddenRow, range) {
            var sheetIdx = this.getActiveSheetIndex(), range = range ? range : this.getSheet(sheetIdx).selectedRange;
            this.removeHyperlink(this._getAlphaRange(sheetIdx, range[0], range[1], range[2], range[3]), status === "clear", status, cells, skipHiddenRow);
        },

        _openLink: function () {
            var sheetIdx = this.getActiveSheetIndex(), selected = this.getSheetElement(sheetIdx).find(".e-activecell");
            this._hlClick(this.XLEdit.getPropertyValue(selected.closest("tr").index(), selected[0].cellIndex, "hyperlink", sheetIdx));
        },

        _hlClick: function (data) {
            var range, sheetIdx, startCell, endCell, urlregex, actSheetIdx = this.getActiveSheetIndex(), alertText, alertMsg = this._getLocStr("HyperLinkAlert").split("-"), value, splitStr;
            var sheet = this.getSheet(actSheetIdx);
            this.model.enableContextMenu && this.XLCMenu.hideCMenu();
            if (data.cellAddr) {
                splitStr = data.cellAddr.split("_");
                if (splitStr[0].indexOf("$") > -1)
                    value = splitStr[0].split("$").join("");
                else
                    value = splitStr[0];
                range = this.getRangeIndices(value);
                startCell = { rowIndex: range[0], colIndex: range[1] };
                endCell = { rowIndex: range[2], colIndex: range[3] };
                sheetIdx = Number(splitStr[1]);
                this.gotoPage(sheetIdx, false);
                sheet._activeCell = startCell;
                this.XLSelection.selectRange(startCell, endCell, sheetIdx);
                sheet._startCell = startCell;
                sheet._endCell = endCell;
                this.XLScroll._scrollSelectedPosition(sheetIdx, startCell);
                this.model.allowAutoFill && this.XLDragFill.positionAutoFillElement();

            }
            else {
                startCell = { rowIndex: sheet._activeCell.rowIndex, colIndex: sheet._activeCell.colIndex };
                sheet._startCell = startCell;
                sheet._endCell = startCell;
                if (this._isValidUrl(data.webAddr))
                    window.open(data.webAddr, "_blank");
                else
                    this._showAlertDlg("Alert", "HyperLinkAlert");
            }
        },

        _isValidUrl: function (url) {
            return /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/.test(url);
        },

        showWaitingPopUp: function () {
            $("#" + this._id + "_wait").data("ejWaitingPopup").show();
        },

        hideWaitingPopUp: function () {
            $("#" + this._id + "_wait").data("ejWaitingPopup").hide();
        },

        _getSelRange: function (selCells) {
            var sCell, eCell, sheetIdx = this.getActiveSheetIndex();
            sCell = selCells[0], eCell = selCells[selCells.length - 1];
            return (this._generateHeaderText(sCell.colIndex + 1) + (sCell.rowIndex + 1) + ":" + this._generateHeaderText(eCell.colIndex + 1) + (eCell.rowIndex + 1));
        },

        _getSelectedCells: function (sheetIdx, range) {
            var selCells, rng, sheet = this.getSheet(sheetIdx ? sheetIdx : this.getActiveSheetIndex());
            if (ej.isNullOrUndefined(range)) {
                selCells = sheet._selectedCells;
                if (selCells.length > 0) {
                    range = this._getSelRange(selCells);
                    rng = this.getRangeIndices(range);
                }
                else {
                    rng = [0, 0, 0, 0];
                    selCells = [{ rowIndex: 0, colIndex: 0 }];
                }
            }
            else {
                rng = this._getRangeArgs(range, "object");
                selCells = this._getSelectedRange({ rowIndex: rng[0], colIndex: rng[1] }, { rowIndex: rng[2], colIndex: rng[3] });
            }
            return { range: rng, selCells: selCells };
        },

        _getHiddenCells: function (sheetIdx, altCells, selectedCell, hideCells) {
            var container = this._dataContainer.sheets[sheetIdx], value, wrap, wrapRow, objDetails;
            (ej.isNullOrUndefined(hideCells[selectedCell.rowIndex])) && (hideCells[selectedCell.rowIndex] = {});
            (ej.isNullOrUndefined(hideCells[selectedCell.rowIndex][selectedCell.colIndex])) && (hideCells[selectedCell.rowIndex][selectedCell.colIndex] = { value: {}, text: "" });
            if (!ej.isNullOrUndefined(container[selectedCell.rowIndex])) {
                hideCells[selectedCell.rowIndex][selectedCell.colIndex]["value"] = $.extend(true, {}, container[selectedCell.rowIndex][selectedCell.colIndex]);
                value = this.XLEdit.getPropertyValue(altCells.rowIndex, altCells.colIndex, "value2", sheetIdx);
				wrap = this.XLEdit.getPropertyValue(altCells.rowIndex, altCells.colIndex, "wrap", sheetIdx);
				wrapRow = this.XLEdit.getPropertyValue(altCells.rowIndex, altCells.colIndex, "wrapRow", sheetIdx);
				if(this.isUndefined(this.XLEdit.getPropertyValue(selectedCell.rowIndex, selectedCell.colIndex, "border", sheetIdx)) && this.isUndefined(this.XLEdit.getPropertyValue(selectedCell.rowIndex, selectedCell.colIndex, "format", sheetIdx)))
                   delete container[selectedCell.rowIndex][selectedCell.colIndex];
			    else {
					objDetails = this.getObjectKeys(this._dataContainer.sheets[sheetIdx][selectedCell.rowIndex][selectedCell.colIndex]);
					objDetails.splice(objDetails.indexOf("border"),1);
					objDetails.splice(objDetails.indexOf("format"),1);
					this.XLEdit._clearDataContainer({ cellIdx: {rowIndex:selectedCell.rowIndex,colIndex:selectedCell.colIndex}, property: objDetails });
				   }
                hideCells[selectedCell.rowIndex][selectedCell.colIndex]["text"] = (ej.isNullOrUndefined(value) ? "" : value); //Checking for empty td cell
				if(wrap || wrapRow){
					if(ej.isNullOrUndefined(container[selectedCell.rowIndex]))
						container[selectedCell.rowIndex] = {};
					if(ej.isNullOrUndefined(container[selectedCell.rowIndex][selectedCell.colIndex]))
						container[selectedCell.rowIndex][selectedCell.colIndex] = {};
					wrap && (container[selectedCell.rowIndex][selectedCell.colIndex]["wrap"] = wrap);
					wrapRow && (container[selectedCell.rowIndex][selectedCell.colIndex]["wrapRow"] = wrapRow);
				}
            }
            if (this._isRowViewable(sheetIdx, altCells.rowIndex))
                altCells = this.getCell(altCells.rowIndex, altCells.colIndex, sheetIdx).empty();
            return hideCells;
        },

        _getRowSpan: function (sheetIdx, selectedCells) {
            var rowSpan = 0, isVscroll = this.model.scrollSettings.allowVirtualScrolling;
            for (var i = selectedCells[0].rowIndex, len = selectedCells[selectedCells.length - 1].rowIndex; i <= len; i++) {
                if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, 0, "isRHide", sheetIdx)) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, 0, "isFHide", sheetIdx)) && ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, 0, "isFilterHide", sheetIdx)) && this.getSheet(sheetIdx)._fHMergeRows.indexOf(i) === -1)
                    rowSpan = rowSpan + 1;
            }
            return rowSpan;
        },

        _getColSpan: function (sheetIdx, selectedCells) {
            var colSpan = 0, isVscroll = this.model.scrollSettings.allowVirtualScrolling, colgrp;
            !isVscroll && (colgrp = this._getJSSheetHeader(sheetIdx).find("col"))
            for (var i = selectedCells[0].colIndex, len = selectedCells[selectedCells.length - 1].colIndex; i <= len; i++) {
                if (ej.isNullOrUndefined(this.XLEdit.getPropertyValue(0, i, "isCHide", sheetIdx)) && this.getSheet(sheetIdx)._fHMergeCols.indexOf(i.toString()) === -1)
                    colSpan = colSpan + 1;
            }
            return colSpan;
        },

        _getHiddenRowColumnCount: function (sheetIdx, range) {
            var rng = this.getRangeIndices(range), hr = 0, hc = 0, i, j, isVscroll = this.model.scrollSettings.allowVirtualScrolling, colgrp;
            !isVscroll && (colgrp = this._getJSSheetHeader(sheetIdx).find("col"))
            for (i = rng[0]; i <= rng[2]; i++) {
                if (!ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, 0, "isRHide", sheetIdx)) || !ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, 0, "isFHide", sheetIdx)))
                    hr = hr + 1;
            }
            for (j = rng[1]; j <= rng[3]; j++) {
                if ((isVscroll || (!isVscroll && this._hasClass(colgrp[j], "e-hide"))) || !ej.isNullOrUndefined(this.XLEdit.getPropertyValue(0, j, "isCHide", sheetIdx)))
                    hc = hc + 1;
            }
            return { hRow: hr, hCol: hc };
        },

        _updateMergeColl: function (sheetIdx, rowIdx, colIdx, type, isSamePosn, range, isCenterAlign, mType) {
            var sheet = this.getSheet(sheetIdx), mergeColl = sheet._mergeColl;
            if (ej.isNullOrUndefined(mergeColl[rowIdx])) {
                mergeColl[rowIdx] = {};
                mergeColl[rowIdx][colIdx] = {};
            }
            else if (ej.isNullOrUndefined(mergeColl[rowIdx][colIdx])) 
                mergeColl[rowIdx][colIdx] = {};
            mergeColl[rowIdx][colIdx]["type"] = type;
			mType && (mergeColl[rowIdx][colIdx]["mergeType"] = mType);
            isSamePosn && (mergeColl[rowIdx][colIdx]["isSamePosn"] = isSamePosn);
            sheet.mergedCells.push({ isCenterAlign: isCenterAlign, range: range });
        },

        mergeCells: function (range, alertStatus) {
            if (this.model.isReadOnly)
                return;
            var i, mergeObj, details, rSpan = 1, cSpan = 1, len, cells = [], sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), alertdlg = $("#" + this._id + "_alertdlg"), selectedCells, isMerged = false, actCell, hiddenCount,
            rng = this._getRangeArgs(range, "object", sheetIdx), isMultiCell = (rng[2] - rng[0]) || (rng[3] - rng[1])
            if (!this.model.allowMerging || (!this.model.allowSelection || !isMultiCell) || this.getSheetElement(sheetIdx).find(".e-ss-activeimg").length > 0 || this.model.isReadOnly)
                return;
            selectedCells = this._getSelectedCells(sheetIdx, rng).selCells;
            this._selMergeCells = [];
            this._mergeType = "merge-cells";
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo) {
                this.performSelection(rng);
                if (this.mergeCenter) {
                    isMerged = false;
                    for (i = 0, len = selectedCells.length; i < len; i++) {
                        mergeObj = this.XLEdit.getPropertyValue(selectedCells[i].rowIndex, selectedCells[i].colIndex, "merge", sheetIdx);
                        if (!ej.isNullOrUndefined(mergeObj)) {
                            rSpan = mergeObj.mSpan.rowSpan;
                            cSpan = mergeObj.mSpan.colSpan;
                            if (rSpan > 1 || cSpan > 1) {
                                hiddenCount = this._getHiddenRowColumnCount(sheetIdx, this.XLEdit.getPropertyValue(selectedCells[i].rowIndex, selectedCells[i].colIndex, 'merge').mRange);
                                this._unMergeAllCells(sheetIdx, i, selectedCells, cells, hiddenCount.hRow, hiddenCount.hCol);
                                isMerged = true;
                            }
                        }
                    }
                    if (isMerged && !this._dupDetails && !this._isUndoRedo) {
                        ej.isNullOrUndefined(range) && (range = this._getSelRange(selectedCells));
                        details = { sheetIndex: sheetIdx, cells: selectedCells, range: range, reqType: "merge-cells", action: "un-merge", operation: "un-merge", mCells: cells };
                        this._completeAction(details);
                        this._trigActionComplete(details);
						if (this.model.showRibbon)
							this.XLRibbon._updateRibbonIcons();
	                    this.performSelection(rng);
                    }
                }
                else {
                    for (i = 0, len = selectedCells.length; i < len; i++) {
                        mergeObj = this.XLEdit.getPropertyValue(selectedCells[i].rowIndex, selectedCells[i].colIndex, "merge", sheetIdx);
                        if (!ej.isNullOrUndefined(mergeObj)) {
                            rSpan = mergeObj.mSpan.rowSpan;
                            cSpan = mergeObj.mSpan.colSpan;
                        }
                        if (rSpan === 1 && cSpan === 1) {
                            isMerged = false;
                            break;
                        }
                    }
                }
            }
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && this._rangeHasData(rng) && !alertStatus && !isMerged && isMultiCell)
                this._showAlertDlg("", "MergeCellsAlert", "MergeCells", 498);
            else if (!isMerged)
                this._mergeCells(sheetIdx, selectedCells, {}, []);
        },

        _mergeCells: function (sheetIdx, selectedCells, hideCells, mCells) {
            var mSpan, tRIdx, xCellsHght = 0, container = this._dataContainer.sheets[sheetIdx], details, range, startrowIdx, startcolIdx, prevObj = {},
                activeCell, altCells, cols, sheet = this.getSheet(sheetIdx), xlEdit = this.XLEdit, rHgt, colWtColl = sheet.columnsWidthCollection, mergewrap, bdrCol;
            tRIdx = startrowIdx = selectedCells[0].rowIndex; startcolIdx = selectedCells[0].colIndex, getFormat = this.XLEdit.getPropertyValue(startrowIdx, startcolIdx, "format");
            !this.model.scrollSettings.allowVirtualScrolling && (cols = this._getJSSheetHeader(sheetIdx).find('col'));
            if ((ej.isNullOrUndefined(xlEdit.getPropertyValue(startrowIdx, 0, "isFRHide")) || ej.isNullOrUndefined(xlEdit.getPropertyValue(startrowIdx, 0, "isRHide"))) && (cols && cols.eq(startcolIdx).hasClass("e-fc-hide")))
                return { hideCell: [], mCells: [] };
            mSpan = { rowSpan: this._getRowSpan(sheetIdx, selectedCells), colSpan: this._getColSpan(sheetIdx, selectedCells) };
            if (!ej.isNullOrUndefined(container[startrowIdx]) && !ej.isNullOrUndefined(container[startrowIdx][startcolIdx])) {
                delete container[startrowIdx][startcolIdx]["isMHide"];
                delete container[startrowIdx][startcolIdx]["mergeIdx"];
            }
            if (this._isRowViewable(sheetIdx, startrowIdx)) {
                activeCell = this.getCell(startrowIdx, startcolIdx);
                activeCell[0].colSpan = mSpan.colSpan;
                activeCell[0].rowSpan = mSpan.rowSpan;
                activeCell[0].className = activeCell[0].className.replace("e-mc-hide", "");
                this.mergeCenter && activeCell.addClass("e-calign ");
                if (activeCell.hasClass("e-commentcell"))
                    this.model.allowComments && this.XLComment._updateCmntArrowPos(activeCell);
            }
            this._selMergeCells.push(selectedCells[0]);
            this._textClip(selectedCells[0].rowIndex, selectedCells[0].colIndex, 'add');
            this._textClip(selectedCells[0].rowIndex, selectedCells[0].colIndex, 'delete', '', true);
            if (this._isRowViewable(sheetIdx, selectedCells[0].rowIndex))
                this.addClass(this.getCell(selectedCells[0].rowIndex, selectedCells[0].colIndex)[0], "e-moverflow");
            xCellsHght = this._getRowHeight(selectedCells[0].rowIndex, sheetIdx);
            for (var i = 1, len = selectedCells.length; i < len; i++) {
                if (this._isRowViewable(sheetIdx, selectedCells[i].rowIndex)) {
                    altCells = this.getCell(selectedCells[i].rowIndex, selectedCells[i].colIndex);
                    if (!this._hasClass(altCells[0], "e-mc-hide"))
                        this.addClass(altCells[0], "e-mc-hide");
                    this.addClass(altCells[0], "e-moverflow");
                }
                if ((tRIdx !== selectedCells[i].rowIndex) && sheet.hideRowsCollection.indexOf(selectedCells[i].rowIndex) == -1) {
                    xCellsHght += this._getRowHeight(selectedCells[i].rowIndex, sheetIdx);
                    tRIdx = selectedCells[i].rowIndex;
                }
                this._textClip(selectedCells[i].rowIndex, selectedCells[i].colIndex, 'add');
                this._textClip(selectedCells[i].rowIndex, selectedCells[i].colIndex, 'delete', '', true);
                hideCells = this._getHiddenCells(sheetIdx, { rowIndex: selectedCells[i].rowIndex, colIndex: selectedCells[i].colIndex }, selectedCells[i], hideCells);
				if(this.isUndefined(getFormat))
                   this.XLEdit._updateDataContainer({ rowIndex: selectedCells[i].rowIndex, colIndex: selectedCells[i].colIndex }, { dataObj: { isMHide: true, mergeIdx: { rowIndex: startrowIdx, colIndex: startcolIdx }}, sheetIdx: sheetIdx });
			    else
				   this.XLEdit._updateDataContainer({ rowIndex: selectedCells[i].rowIndex, colIndex: selectedCells[i].colIndex }, { dataObj: { isMHide: true, mergeIdx: { rowIndex: startrowIdx, colIndex: startcolIdx }, format: getFormat}, sheetIdx: sheetIdx });
                this._selMergeCells.push(selectedCells[i]);
            }
			  range = this._getSelRange(selectedCells);
            if (!ej.isNullOrUndefined(container[startrowIdx]))
                $.extend(true, prevObj, container[startrowIdx][startcolIdx]);
            sheet._activeCell = selectedCells[0];
            if (!sheet._isImported || sheet._isLoaded)
                this.performSelection(selectedCells[0], selectedCells[selectedCells.length - 1]);
            this.XLEdit._updateDataContainer({ rowIndex: startrowIdx, colIndex: startcolIdx }, { dataObj: { merge: { mSpan: mSpan, isMerge: true, mRange: range, isCenterAlign: this.mergeCenter } } }); // mRange denones Merged Range
            bdrCol = this._getMCellBorderProps(this.getRangeIndices(range));
            this.getObjectLength(bdrCol) && this.XLFormat._applyBorderCss(bdrCol, this.getRangeIndices(range));
            this._updateMergeColl(sheetIdx, startrowIdx, startcolIdx, this.mergeCenter ? "center" : "merge",null, range, this.mergeCenter, this._mergeType);
            mCells.push({ rowIndex: startrowIdx, colIndex: startcolIdx, prevObj: prevObj, curObj: $.extend(true, {}, container[startrowIdx][startcolIdx]) });
            if (xlEdit.getPropertyValue(startrowIdx, startcolIdx, "wrap")) {
                rHgt = this._getWrapCellHeight(sheetIdx, startrowIdx, startcolIdx).rowHt;
                if (this._getRowHeight(startrowIdx, sheetIdx) <= rHgt || sheet._isImported || !sheet._isLoaded) {
                    this.setHeightToRows([{ rowIndex: startrowIdx, height: rHgt }]);
                    this._wrapCollection(startrowIdx, startcolIdx, rHgt.cellHt, sheetIdx);
				}
            }
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && !this._dupDetails && !this._paste && this._mergeType === "merge-cells") {
                details = { sheetIndex: sheetIdx, cells: [{ rowIndex: startrowIdx, colIndex: startcolIdx }], range: range, reqType: "merge-cells", action: "merge-all", hideCells: hideCells, mCells: mCells };
                details.operation = (this.mergeCenter) ? "merge-center" : "merge-all";
                if(!this._paste) {
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
            }
            if (this.model.showRibbon && !this._isScrolling)
                this.XLRibbon._updateRibbonIcons();
            this.mergeCenter = false;
            this._paste = false;
            this.XLEdit._updateUsedRange(startrowIdx + mSpan.rowSpan, startcolIdx + mSpan.colSpan, sheetIdx);
            return { hideCells: hideCells, mCells: mCells };
        },

        mergeAcrossCells: function (range, alertStatus) {
            if (this.model.isReadOnly)
                return;
            var sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), alertdlg = $("#" + this._id + "_alertdlg"), selRange, 
            rng = this._getRangeArgs(range, "object", sheetIdx), isMultiCell = (rng[2] - rng[0]) || (rng[3] - rng[1]), isMultiCol = rng[3] - rng[1];
            if (!this.model.allowMerging || this.getSheetElement(sheetIdx).find(".e-ss-activeimg").length > 0 || !isMultiCell || this.model.isReadOnly)
                return;
            this._selMergeCells = [];
            selRange = this._getSelectedCells(sheetIdx, rng);
            !this.isUndefined(range) && this.performSelection(rng);
            if (!this._isUndoRedo && this._rangeHasData(rng) && (!sheet._isImported || sheet._isLoaded) && !alertStatus && isMultiCol)
                this._showAlertDlg("", "MergeCellsAlert", "MergeAcrossCells", 498);
            else if (isMultiCol)
                this._mergeAcrossCells(sheetIdx, selRange.selCells);
            this.performSelection(rng);
            this.model.showRibbon && this.XLRibbon._updateRibbonIcons();
        },

        _mergeAcrossCells: function (sheetIdx, selectedCells) {
            var i, j, len, mergeObj, rSpan = 1, cSpan = 1, isMerged = true, details, sCol, eCol, sRow, eRow, selCell = [],
                mValue = { mCells: [], hideCells: {} }, sheet = this.getSheet(sheetIdx);
            this._mergeType = "merge-across";
            for (i = 0, len = selectedCells.length; i < len ; i++) {
                mergeObj = this.XLEdit.getPropertyValue(selectedCells[i].rowIndex, selectedCells[i].colIndex, "merge", sheetIdx);
                if (!ej.isNullOrUndefined(mergeObj)) {
                    rSpan = mergeObj.mSpan.rowSpan;
                    cSpan = mergeObj.mSpan.colSpan;
                }
                if (rSpan === 1 && cSpan === 1) {
                    isMerged = false;
                    break;
                }
                else if (rSpan > 1)
                    isMerged = false;
            }
            if (!isMerged) {
                sRow = selectedCells[0].rowIndex, eRow = selectedCells[selectedCells.length - 1].rowIndex;
                sCol = selectedCells[0].colIndex, eCol = selectedCells[selectedCells.length - 1].colIndex;
                for (i = sRow; i <= eRow; i++) {
                    selCell = [];
                    for (j = sCol; j <= eCol; j++)
                        selCell.push({ rowIndex: i, colIndex: j });
                    mValue = this._mergeCells(sheetIdx, selCell, mValue.hideCells, mValue.mCells);
                }
            }
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && !this._dupDetails) {
                details = { sheetIndex: sheetIdx, cells: $.extend(true, [], this._selMergeCells), range: this._getSelRange(this._selMergeCells), reqType: "merge-cells", action: "merge-across", operation: "merge-across", hideCells: mValue.hideCells, mCells: mValue.mCells };
                if (!this._paste) {
                    this._completeAction(details);
                    this._trigActionComplete(details);
                }
                this._paste = false;
            }
			this._mergeType = "merge-cells";
            this.performSelection(selectedCells[0], selectedCells[selectedCells.length - 1]);
        },

        _getMCellBorderProps: function (range) {
            var i, j, prop, bProp, tRange, foundProp = {}, rangeData, props = ["bottom", "right"];

            for (i = 0; i < props.length; i++) {
                prop = props[i];
                tRange = prop == props[0] ? [range[2], range[1], range[2], range[3]] : [range[0], range[3], range[2], range[3]];
                rangeData = this.getRangeData({ range: tRange, property: ["border"] });
                for (j = 0; j < rangeData.length; j++) {
                    if (rangeData[j]["border"]) {
                        bProp = this.XLFormat.getBorderFromHashCode(rangeData[0]["border"]);
                        if (bProp[prop]) {
                            if (foundProp[prop] && foundProp[prop] != bProp[prop]) {
                                delete foundProp[prop];
                                break;
                            }
                            foundProp[prop] = bProp[prop];
                        }
                        else {
                            delete foundProp[prop];
                            break;
                        }
                    }
                    else {
                        delete foundProp[prop];
                        break;
                    }
                }
            }
            rangeData = this.XLEdit.getPropertyValue(range[0], range[1], "borders");
            if (rangeData) {
                if (rangeData["top"])
                    foundProp["top"] = rangeData["top"];
                if (rangeData["left"])
                    foundProp["left"] = rangeData["left"];
            }
            return foundProp;
        },

        unmergeCells: function (range) {
            if (this.model.isReadOnly)
                return;
            var sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), cells = [], selectedCells, details, hiddenCount, mergeObj, clrMerge = sheet._clrMergeColl,
                rng = this._getRangeArgs(range, "object", sheetIdx);
            if (!this.model.allowMerging || this.getSheetElement(sheetIdx).find(".e-ss-activeimg").length > 0 || this.model.isReadOnly)
                return;
            this._selMergeCells = [];
            selectedCells = this._getSelectedCells(sheetIdx, rng).selCells;
            for (var k = 0, len = selectedCells.length; k < len; k++) {
                mergeObj = this.XLEdit.getPropertyValue(selectedCells[k].rowIndex, selectedCells[k].colIndex, "merge", sheetIdx);
                if (!this.isUndefined(mergeObj)) {
                    hiddenCount = this._getHiddenRowColumnCount(sheetIdx, mergeObj.mRange);
                    cells = this._unMergeAllCells(sheetIdx, k, selectedCells, cells, hiddenCount.hRow, hiddenCount.hCol);
                    clrMerge.push({ rowIdx: selectedCells[k].rowIndex, colIdx: selectedCells[k].colIndex, mergeObj: mergeObj });
                }
            }
            ej.isNullOrUndefined(range) && (range = this._getSelRange(selectedCells));
            sheet._isLoaded && this.performSelection(rng);
            if ((!sheet._isImported || sheet._isLoaded) && !this._isUndoRedo && !this._dupDetails && !this._isExport) {
                details = { sheetIndex: sheetIdx, cells: selectedCells, range: range, reqType: "merge-cells", action: "un-merge", operation: "un-merge", mCells: cells };
                this._completeAction(details);
                this._trigActionComplete(details);
            }
            if (this.model.showRibbon && !this._isScrolling)
                this.XLRibbon._updateRibbonIcons();
        },
 
        _unMergeAllCells: function (sheetIdx, rowIdx, selectedCells, cells, hr, hc) {
            var i, j, k, hr, hc, mergeObj, mergeWrap, mergeIdx, rSpan = 1, cSpan = 1, mSpanObj, isViewable = false, container = this._dataContainer.sheets[sheetIdx], prevObj = {},
                activeCell, overflow, cell, startrowIdx, startcolIdx, rowhdrrows, mCells, mergeContainer, sheet = this.getSheet(sheetIdx), aCellHgt, isWrap, hasBdrProp = false; // mCells denotes merged cells
            startrowIdx = selectedCells[rowIdx].rowIndex; startcolIdx = selectedCells[rowIdx].colIndex, rowhdrrows = this.getRows(sheetIdx)[0], mergedCells = this.model.sheets[sheetIdx].mergedCells;
            activeCell = this.getCell(startrowIdx, startcolIdx);
			isWrap = this.XLEdit.getPropertyValue(startrowIdx, startcolIdx, "wrap", sheetIdx)
            mergeObj = this.XLEdit.getPropertyValue(startrowIdx, startcolIdx, "merge", sheetIdx);
            if (!ej.isNullOrUndefined(mergeObj)) {
                rSpan = mergeObj.mSpan.rowSpan;
                cSpan = mergeObj.mSpan.colSpan;
                hasBdrProp = this.XLEdit.getPropertyValue(startrowIdx, startcolIdx, "borders", sheetIdx)
                if (!hasBdrProp || (hasBdrProp && (!hasBdrProp["right"] || !hasBdrProp["bottom"])))
                   this.XLEdit._clearDataContainer({ cellIdx: { rowIndex: startrowIdx, colIndex: startcolIdx }, property: ["border"] });
			   if(hasBdrProp && hasBdrProp["bottom"]&& rSpan === 1)
				  this.XLFormat._updateFormatClass({ rowIndex: startrowIdx, colIndex: startcolIdx },this.XLFormat._getBorderHashCode(hasBdrProp), true);
                for (var k = 0; k < mergedCells.length; k++) {
                    if (mergedCells[k].range == mergeObj.mRange) {
                        mergedCells.splice(k, 1);
                    }
                }
            }
            if (cSpan > 1 || rSpan > 1) {
                mergeContainer = container[startrowIdx][startcolIdx];
                $.extend(true, prevObj, mergeContainer);
				delete mergeContainer["merge"];
				this._clearMergeColl(sheet._mergeColl, startrowIdx, startcolIdx);
                if (this._isRowViewable(sheetIdx, startrowIdx)) {
                    activeCell = this.getCell(startrowIdx, startcolIdx);
                    if (!this.XLEdit.getPropertyValue(startrowIdx, startcolIdx, "cellType", sheetIdx)) {
                        mergeWrap = activeCell.find('#' + this._id + '_Merge');
                        if (mergeWrap.length) {
                            activeCell[0].innerHTML = mergeWrap[0].innerHTML;
                            mergeWrap.remove();
                        }
                    }
                    if (!ej.isNullOrUndefined(mergeObj.isCenterAlign))
                        activeCell.removeClass("e-calign");
                    activeCell[0].colSpan = activeCell[0].rowSpan = 1;
                    if (sheet._isLoaded) {
                        aCellHgt = activeCell[0].offsetHeight;
                        if ($(rowhdrrows[startrowIdx]).height() < aCellHgt) {
                            this.setHeightToRows([{ rowIndex: startrowIdx, height: aCellHgt }]);
                            this._updateFormatColl(sheetIdx, startrowIdx, startcolIdx, aCellHgt);
                        }
                        this.XLScroll._getRowHeights(sheetIdx, startrowIdx);
                    }
                }
                cells.push({ rowIndex: startrowIdx, colIndex: startcolIdx, prevObj: prevObj, curObj: $.extend(true, {}, container[startrowIdx][startcolIdx]) });
                mCells = [];
                for (i = startrowIdx ; i < (startrowIdx + rSpan + hr) ; i++) {
                    for (j = startcolIdx ; j < (startcolIdx + cSpan + hc) ; j++) {
                        this._selMergeCells.push({ rowIndex: i, colIndex: j });
                        isViewable = false;
                        if (this._isRowViewable(sheetIdx, i)) {
                            cell = this.getCell(i, j, sheetIdx);
                            isViewable = true;
                        }
                        if (!ej.isNullOrUndefined(this.XLEdit.getPropertyValue(i, j, "isMHide", sheetIdx))) {
                            if (this._isUndoRedo) {
                                mSpanObj = this.XLEdit.getPropertyValue(i, j, "merge", sheetIdx);
                                if (!ej.isNullOrUndefined(mSpanObj)) {
                                    if (mSpanObj.mergeSpan.rowSpan > 1 || mSpanObj.mergeSpan.colSpan > 1) {
                                        mCells.push({ rowIndex: i, colIndex: j, rowSpan: mSpanObj.mergeSpan.rowSpan, colSpan: mSpanObj.mergeSpan.colSpan });
                                        container[i][j].merge.mSpan = { rowSpan: 1, colSpan: 1 };
                                        cell[0].rowSpan = 1; cell[0].colSpan = 1;
                                    }
                                }
                            }
                            mergeIdx = this.XLEdit.getPropertyValue(i, j, "mergeIdx", sheetIdx);
                            if (!ej.isNullOrUndefined(mergeIdx))
                                if (mergeIdx.rowIndex === startrowIdx && mergeIdx.colIndex === startcolIdx) {
                                    if (isViewable) {
                                        cell.removeClass("e-mc-hide");
                                        cell[0].rowSpan = 1; cell[0].colSpan = 1;
                                    }
                                    delete container[i][j]["isMHide"];
                                    delete container[i][j]["mergeIdx"];
                                }
                        }
                        if (this._isUndoRedo && !ej.isNullOrUndefined(this._delCells)) {
                            if (!ej.isNullOrUndefined(this._delCells[i]) && !ej.isNullOrUndefined(this._delCells[i][j])) {
                                if (!ej.isNullOrUndefined(container[i])) {
                                    overflow = !ej.isNullOrUndefined(container[i][j]) && container[i][j]['overflow'];
                                    container[i][j] = this._delCells[i][j]['value'];
                                    (overflow) && (container[i][j]['overflow'] = overflow);
                                    isViewable && cell.text(this._delCells[i][j]["text"]);
                                    mergeObj = this.XLEdit.getPropertyValue(i, j, "merge");
                                    if (!ej.isNullOrUndefined(mergeObj) && mergeObj.isMerge)
                                        this.mergeCells(mergeObj.mRange, true);
                                }
                            }
                        }
                        if (isViewable && cell.hasClass("e-commentcell"))
                            this.model.allowComments && this.XLComment._updateCmntArrowPos(cell);
                        if (isViewable) {
                            this._removeClass(cell[0], "e-moverflow");
                            if (cell.text().length > 0)
                                this._textClip(i, j, 'add');
                            else
                                this._textClip(i, j, 'delete');
                        }
                        if (!ej.isNullOrUndefined(container[i])) {
                            if (this.getObjectLength(container[i][j]) < 1)
                                delete container[i][j];
                            if (this.getObjectLength(container[i]) < 1)
                                delete container[i];
                        }
                    }
                }
            }
            return cells;
        },

        _refreshMergeCells: function() {
            this._dupDetails = true;
            var mCells = this._removeMergeColl;
            for (var i = 0, len = mCells.length; i < len; i++)
                this.unmergeCells(mCells[i].merge.mRange, true);
            this._dupDetails = false;
            var data = this._insData;
            switch (data.value.status) {
                case "shiftRight":
                    this._insertShiftRight(data.sheetIdx, data.startCell, data.endCell, data.value);
                    break;
                case "shiftBottom":
                    this._insertShiftBottom(data.sheetIdx, data.startCell, data.endCell, data.value);
                    break;
                case "shiftUp":
                    this._deleteShiftUp(data.sheetIdx, data.startCell, data.endCell, data.value);
                    break;
                case "shiftLeft":
                    this._deleteShiftLeft(data.sheetIdx, data.startCell, data.endCell, data.value);
                    break;
            }
        },

        _showHeadings: function (status, sheetIdx) {
            if (this.model.isReadOnly)
                return;
            var checkObj, args, sheetIdx = sheetIdx ? sheetIdx : this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), shdr = this._getJSSheetHeader(sheetIdx),
                cont = this._getContent(sheetIdx).find('.e-content'), rhdr = this._getJSSheetRowHeader(sheetIdx), fRowIdx = this.getFrozenRows(), fColIdx = this.getFrozenColumns();
            sheet.showHeadings = status;
            this._isDisplayHeader = true;
            if (sheet.showHeadings) {
                rhdr.show();
                shdr.show();
                cont.removeClass('e-viewbrdr');
            }
            else {
                rhdr.hide();
                shdr.hide();
                cont.addClass('e-viewbrdr');
            }
            this._heightWidthCalculation(sheetIdx, { action: sheet._isLoaded ? "" : "initial" });
            if (this.model.showRibbon) {
                checkObj = this.element.find("#" + this._id + "_Ribbon_PageLayout_Show_Headings").data("ejCheckBox");
                if (checkObj)
                    status ? checkObj._checked() : checkObj._unChecked();
            }
            if (this.model.allowFreezing && sheet._isFreezed) {
                this.XLFreeze.unfreezePanes();
                if (this._isFrozen(fRowIdx) && this._isFrozen(fColIdx))
                    this.XLFreeze.freezePanes(fRowIdx, fColIdx);
                else if (this._isFrozen(fRowIdx))
                    this.XLFreeze.freezeRows(fRowIdx);
                else if (this._isFrozen(fColIdx))
                    this.XLFreeze.freezeColumns(fColIdx);
            }
            args = { reqType: "headings", showHeadings: status, sheetIndex: sheetIdx};
            this._trigActionComplete(args);
        },

        showHeadings: function (status) {
            this._showHeadings(status);
        },

        showGridlines: function (status) {
            this._showGridlines(status);
        },

        _showGridlines: function (status, sheetIdx) {
            if (this.model.isReadOnly)
                return;
            var checkObj, args, sheetIdx = sheetIdx ? sheetIdx : this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), cells = this._getContent(sheetIdx).find(".e-rowcell");
            if (this.model.showRibbon) {
                checkObj = this.element.find("#" + this._id + "_Ribbon_PageLayout_Show_Gridlines").data("ejCheckBox");
                if (checkObj)
                    (status) ? checkObj._checked() : checkObj._unChecked();
            }
            sheet.showGridlines = status;
            sheet.showGridlines ? cells.removeClass('e-hborder') : cells.addClass("e-hborder");
            args = { reqType: "gridlines", showGridlines: status, sheetIndex: sheetIdx};
            this._trigActionComplete(args);
        },

        //Spreadsheet Common Prop
        setSheetFocus: function () {
            if (!this._hasClass(document.activeElement, "e-datepicker"))
                if (ej.browserInfo().name == "msie") {
					try { this.element[0].setActive(); } catch (e) { }
				}
                else
                    this.element.focus();
            if (!this._isInitLoad)
                window.scrollTo(window.pageXOffset, window.pageYOffset);
        },

        _diffNumbers: function (a, b) {
            return a - b;
        },

        _isValidDate: function (date) {
            var dateFormat = /^\d{1,4}[\.|\/|-]\d{1,2}[\.|\/|-]\d{1,4}$/;
            if (dateFormat.test(date)) {
                date = date.replace(/0*(\d*)/gi, "$1");
                var dateArray = date.split(/[\.|\/|-]/);
                // correct month value
                dateArray[0] = dateArray[0] - 1;
                // correct year value
                if (dateArray[2].length < 4) {
                    // correct year value
                    dateArray[2] = (parseInt(dateArray[2]) < 50) ? 2000 + parseInt(dateArray[2]) : 1900 + parseInt(dateArray[2]);
                }
                var testDate = new Date(dateArray[2], dateArray[0], dateArray[1]);
                if (testDate.getDate() != dateArray[1] || testDate.getMonth() != dateArray[0] || testDate.getFullYear() != dateArray[2]) {
                    return false;
                } else {
                    return true;
                }
            } else {
                return false;
            }
        },

        _isValidTime: function (value) {
            var colonCount = 0, status = false, mm, ss;
            for (var i = 0, len = value.length; i < len; i++) {
                var ch = value.substring(i, i + 1);
                if ((ch < "0") || (ch > "9")) {
                    if ((ch != ":") && (ch != " ") && (ch != "a") && (ch != "A") && (ch != "p") && (ch != "P") && (ch != "m") && (ch != "M")) {
                        return false;
                    }
                }
                if (ch == ":") { colonCount++; }
                if ((ch == "p") || (ch == "P") || (ch == "a") || (ch == "A")) { status = true; }
            }
            if ((colonCount < 1) || (colonCount > 2)) { return false; }
            var hh = value.substring(0, value.indexOf(":"));
            if ((parseFloat(hh) < 0) || (parseFloat(hh) > 23)) { return false; }
            if (status) {
                if ((parseFloat(hh) < 1) || (parseFloat(hh) > 12)) { return false; }
            }
            if (colonCount == 2) {
                mm = value.substring(value.indexOf(":") + 1, value.lastIndexOf(":"));
            } else {
                mm = value.substring(value.indexOf(":") + 1, value.length);
            }
            if ((parseFloat(mm) < 0) || (parseFloat(mm) > 59)) { return false; }
            if (colonCount == 2) {
                ss = value.substring(value.lastIndexOf(":") + 1, value.length);
            } else {
                ss = "00";
            }
            if ((parseFloat(ss) < 0) || (parseFloat(ss) > 59)) { return false; }
            return true;
        },

        _setXY: function (e, isPage) {
            var x = 0, y = 0;
            isPage = isPage ? "page" : "client";
            if (e.type === "mousemove" || e.type === "mousedown" || e.type === "mouseup") {
                x = e[isPage + "X"];
                y = e[isPage + "Y"];
            }
            else if (e.type === "touchmove" || e.type === "touchstart" || e.type === "touchend") {
                x = e.originalEvent.changedTouches[0][isPage + "X"];
                y = e.originalEvent.changedTouches[0][isPage + "Y"];
            }
            else if (e.type === "MSPointerMove" || e.type === "pointermove" || e.type === "MSPointerUp" || e.type === "pointerup" || e.type === "MSPointerDown" || e.type === "pointerdown") {
                x = e.originalEvent[isPage + "X"];
                y = e.originalEvent[isPage + "Y"];
            }
            return [x, y];
        },

        _getSelectedItems: function (sheetIdx, range, addr) {
            var selected, sCIdx, eCIdx, actSheet;
            sheetIdx = sheetIdx ? sheetIdx : this.getActiveSheetIndex(), actSheet = this.getSheet(sheetIdx);
            if (ej.isNullOrUndefined(addr) && ej.isNullOrUndefined(range)) {
                selected = actSheet._selectedCells;
                sCIdx = actSheet._startCell, eCIdx = actSheet._endCell;
                addr = this._generateHeaderText(sCIdx.colIndex + 1) + (sCIdx.rowIndex + 1) + ":" + this._generateHeaderText(eCIdx.colIndex + 1) + (eCIdx.rowIndex + 1);
            }
            else {
                range = this.isUndefined(range) ? this.getRangeIndices(addr) : range;
                selected = this.getRange(range, sheetIdx);
                addr = this._generateHeaderText(range[1] + 1) + (range[0] + 1) + ":" + this._generateHeaderText(range[3] + 1) + (range[2] + 1);
            }
            return [selected, addr];
        },

        setBorder: function (property, range) {
            if (!this.model.allowCellFormatting || this.model.isReadOnly)
                return;
			range = this._getRangeArgs(range);
			if(range[0] === range[2] && range[1] === range[3]){
				var mergeInf = this.XLEdit.getPropertyValue(range[0],range[1],"merge");
				if(mergeInf)
				  range = mergeInf.mRange;
			}
            var i, str = "", isGridBdr = false, borderStyle = property.style, borderType = property.type, hexcode = property.color, arr1, arr2, arr3, border1, border2, prop, sprop, sheetCont = this._getContent(this.getActiveSheetIndex()).find("div:first-child");
            if (!this.model.allowSelection && (borderType === "drawborder" || borderType === "drawbordergrid"))
                return;
            arr1 = ["bottom", "top", "left", "right", "outside", "allborder"];
            arr2 = ["thickbox", "thickbottom", "doublebottom", "topandbottom", "topandthickbottom", "topanddoublebottom"];
            border1 = {
                top: { top: "" },
                right: { right: "" },
                bottom: { bottom: "" },
                left: { left: "" },
                outside: { top: "", right: "", bottom: "", left: "" },
                thickbox: { top: "2px solid", right: "2px solid", bottom: "2px solid", left: "2px solid" },
                thickbottom: { bottom: "2px solid" },
                doublebottom:{ bottom: "3px double"},
                topandbottom: { top: "1px solid", bottom: "1px solid" },
                topandthickbottom: { top: "1px solid", bottom: "2px solid" },
                topanddoublebottom: { top: "1px solid", bottom: "3px double"}
            };
            border2 = { solid: "1px solid", dashed: "1px dashed", dotted: "1px dotted", double:"3px double"};
            if (this.model.allowSelection)
                this.XLSelection._isGridBordering = this.XLSelection._isOutsideBordering = false;
            switch (true) {
                case arr1.indexOf(borderType) > -1:
                    isGridBdr = borderType === arr1[5];
                    prop = border1[isGridBdr ? arr1[4] : borderType];
                    for (i in prop)
                        prop[i] = border2[borderStyle] + " " + hexcode;
                    if (isGridBdr)
                        prop.isGridBorder = isGridBdr;
                    prop['property'] = property;
                    this.XLFormat.applyBorder(prop, range);
                    break;
                case arr2.indexOf(borderType) > -1:
                    prop = border1[borderType];
                    for (i in prop) {
                        str = "";
                        sprop = prop[i].split(" ");
                        str = sprop.length === 2 ? str + prop[i] + " " + hexcode : str + prop[i] + " " + borderStyle + " " + hexcode; // consider
                        prop[i] = str;
                    }
                    prop['property'] = property;
                    this.XLFormat.applyBorder(prop, range);
                    break;
                case borderType === "noborder":
                    this.XLFormat.applyBorder("noborder", range);
                    break;
                case borderType === "drawborder":
                    this.XLSelection._isOutsideBordering = true;
                    sheetCont.removeClass("e-ss-cursor");
                    sheetCont.addClass("e-ss-drwbrdrcursor");
                    this.XLSelection._cleanUp(true);
                    break;
                case borderType === "drawbordergrid":
                    this.XLSelection._isGridBordering = true;
                    sheetCont.removeClass("e-ss-cursor");
                    sheetCont.addClass("e-ss-drwbrdrgridcursor");
                    this.XLSelection._cleanUp(true);
                    break;
            }
        },

        clearBorder: function (range) {
            if (this.model.isReadOnly)
                return;
            range = this._getRangeArgs(range, "object");
            this.XLFormat.removeStyle(range, { cellStyle: true, tableStyle: true, border: true });
        },

        clearHyperlinks: function () {
            if (this.model.allowClear && !this.model.isReadOnly)
                this._removeHyperlink("clear");
        },

        clearComments: function (sheetIdx) {
            if (this.model.allowClear && !this.model.isReadOnly)
                this.model.allowComments && this.XLComment.deleteComment(undefined, sheetIdx, false, "clear");
        },

        clearAllFormat: function (aRange) {
            if (!this.model.allowClear || this.model.isReadOnly)
                return;
            var evtArgs, sheetIdx = this.getActiveSheetIndex(), container = this._dataContainer.sheets[sheetIdx], nRange = [], rKeys, cKeys, sheet = this.getSheet(sheetIdx),
                range = this._getRangeArgs(aRange, "object"), isTable,
                details = { sheetIndex: sheetIdx, reqType: "clear-format", range: range };
            details.bData = $.extend(true, [], this.getRangeData({ range: range, property: ["format", "tformats", "type", "formatStr", "decimalPlaces", "thousandSeparator", "formats", "hyperlink", "cFormatRule"] }));
            this._dupDetails = true;
            rKeys = this.getObjectKeys(container);
            nRange[0] = (range[0] > parseInt(rKeys[0])) ? range[0] : parseInt(rKeys[0]);
            nRange[2] = (range[2] < parseInt(rKeys[rKeys.length - 1])) ? range[2] : parseInt(rKeys[rKeys.length - 1]);
            cKeys = this.getObjectKeys(container[nRange[2]]);
            nRange[1] = (range[1] > parseInt(cKeys[0])) ? range[1] : parseInt(cKeys[0]);
            nRange[3] = (range[3] < parseInt(cKeys[cKeys.length - 1])) ? range[3] : parseInt(cKeys[cKeys.length - 1]);
            if (ej.isNullOrUndefined(rKeys))
                return;
            isTable = this._checkTableRange(this._getAlphaRange(sheetIdx, nRange[0], nRange[1], nRange[2], nRange[3]));
            if (isTable.status === 'partial')
                return;
            this.clearRangeData(range, ["format", "formatStr", "decimalPlaces", "thousandSeparator", "formats", "hyperlink", "cFormatRule", "border"], "", false, details.reqType);
            this.clearBorder(aRange);
            this.model.allowConditionalFormats && this.XLCFormat.refreshCFormat(range);
            sheet._clrWrapColl = [];
            sheet._clrMergeColl = [];
            this._isPaste = true;
            this.setWrapText("unwrap", range);
            this._isPaste = false;
            this.unmergeCells(range);
            details.wrapColl = $.extend(true, [], sheet._clrWrapColl);
            details.mergeColl = $.extend(true, [], sheet._clrMergeColl);
            (this.model.showRibbon) && this.XLRibbon._updateRibbonIcons();
            this._dupDetails = false;
            if (!this._isUndoRedo) {
                this._completeAction(details);
                evtArgs = { sheetIndex: details.sheetIndex, reqType: details.reqType, range: details.range, prevData: details.bData, prevMergeColl: details.mergeColl, prevWrapColl: details.wrapColl };
                this._trigActionComplete(evtArgs);
            }
        },

        clearContents: function (range) {
            if (this.model.isReadOnly)
                return;
            range = this._getRangeArgs(range, "object");
            var sheetIdx = this.getActiveSheetIndex(), evtArgs, rangeData = this.getRangeData({ range: range, property: ["value", "value2", "type", "hyperlink"] }), details = { sheetIndex: sheetIdx, reqType: "clear-content", range: range, bData: $.extend(true, [], rangeData) };
            if (!this.model.allowClear || this._isPropExists([range], "isReadOnly", sheetIdx))
                return;
            this.clearRangeData(range, ["value", "value2", "hyperlink"], "", false, details.reqType);
            (this.model.allowConditionalFormats) && this.XLCFormat.refreshCFormat(range); {
                this._completeAction(details);
                evtArgs = { sheetIndex: details.sheetIndex, reqType: details.reqType, range: details.range, prevData: details.bData };
                this._trigActionComplete(evtArgs);
            }
            this.setSheetFocus();
            if (this.model.allowFormulaBar)
                this.updateFormulaBar();
        },

        clearAll: function (aRange) {
            if (this.model.isReadOnly)
                return;
            var rKeys, cKeys, evtArgs, alpRange, isTable, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), nRange = [], range = this._getRangeArgs(aRange, "object"), rangeData,
                details = { sheetIndex: sheetIdx, reqType: "clear-all", range: range }, container = this._dataContainer.sheets[sheetIdx];
            if (!this.model.allowClear || this._isPropExists([range], "isReadOnly", sheetIdx))
                return;
            this._dupDetails = true;
            rKeys = this.getObjectKeys(container);
            nRange[0] = (range[0] > parseInt(rKeys[0])) ? range[0] : parseInt(rKeys[0]);
            nRange[2] = (range[2] < parseInt(rKeys[rKeys.length - 1])) ? range[2] : parseInt(rKeys[rKeys.length - 1]);
            cKeys = this.getObjectKeys(container[nRange[2]]);
            nRange[1] = (range[1] > parseInt(cKeys[0])) ? range[1] : parseInt(cKeys[0]);
            nRange[3] = (range[3] < parseInt(cKeys[cKeys.length - 1])) ? range[3] : parseInt(cKeys[cKeys.length - 1]);
            alpRange = this._getAlphaRange(sheetIdx, nRange[0], nRange[1], nRange[2], nRange[3]);
            if ((ej.isNullOrUndefined(rKeys)) || (ej.isNullOrUndefined(cKeys)))
                return;
            details.bData = $.extend(true, [], this.getRangeData({ range: range, property: ["value", "value2", "hyperlink", "merge", "rule", "cFormatRule", "comment", "format", "formatStr", "formats", "tformat", "decimalPlaces", "thousandSeparator", "type", "borders", "tborders"], sheetIdx: sheetIdx }));
            details.bBorder = this.XLFormat.getHashCodeClassAsArray(range);
            isTable = this._checkTableRange(alpRange);
            if (isTable.status === 'full') {
                details.tblObj = isTable.tableObj;
                details.tblObj.tblId = isTable.tblId;
                details.tblObj.header = true;
                this.XLFormat.removeTable(details.tblObj.tblId);
            }
            else if (isTable.status === 'partial')
                return;
            this.clearRangeData(range, ["value", "value2", "hyperlink", "cFormatRule", "comment", "format", "formats", "formatStr", "decimalPlaces", "thousandSeparator", "border"], "", false);
            this.clearBorder(alpRange);
            this.model.allowFiltering && this.XLFilter.clearFilter('remove');
            sheet._clrMergeColl = [];
            sheet._clrWrapColl = [];
            (this.model.allowConditionalFormats) && this.XLCFormat.refreshCFormat(range);
            (this.model.allowDataValidation) && this.XLValidate.clearDV();
            this._isPaste = true;
            this.setWrapText("unwrap", range);
            this._isPaste = false;
            this.unmergeCells(range);
            details.mergeColl = $.extend(true, [], sheet._clrMergeColl);
            details.wrapColl = $.extend(true, [], sheet._clrWrapColl);
            this._dupDetails = false;
            if (this.model.showRibbon) {
                this.XLRibbon._updateRibbonIcons();
                this.XLRibbon._toggleDesignTab(this.getActiveCell());
            }
            this._completeAction(details);
            evtArgs = { sheetIndex: details.sheetIndex, reqType: details.reqType, range: details.range, prevData: details.bData, prevBorder: details.bBorder, tblObj: details.tblObj, mergeColl: details.mergeColl, wrapColl: details.wrapColl };
            this._trigActionComplete(evtArgs);
        },

        _checkTableRange: function (aRange, cellIdx) {
            var tAlphaRange, sheetIdx = this.getActiveSheetIndex(), sheet = this.model.sheets[sheetIdx], tId, tblObj, tRange,
                range = this.getRangeIndices(aRange), tName, prop;
            if (cellIdx)
                tName = this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex, "tableName");
            else {
                prop = this.XLEdit._getPropWithCellIdx(range, 'tableName');
                prop.length && (tName = prop[0].value);
            }
            if (tName) {
                tId = this._getTableID(tName);
                tblObj = sheet.tableManager[tId];
                tRange = tblObj.range;
                tAlphaRange = this._getAlphaRange(sheetIdx, tRange[0], tRange[1], tRange[2], tRange[3])
                return (aRange === tAlphaRange) ? { status: 'full', tableObj: tblObj, tblId: tId } : { status: 'partial' };
            }
            else
                return { status: 'no-table' };
        },

        _checkFilterRange: function (aRange, cellIdx) {
            var tAlphaRange, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), tId, tblObj,
                range = this.getRangeIndices(aRange), isHdr, prop, tableRange = sheet.filterSettings.tableRange;
            if (cellIdx)
                isHdr = this.XLEdit.getPropertyValue(cellIdx.rowIndex, cellIdx.colIndex, "isFilterHeader");
            else {
                prop = this.XLEdit._getPropWithCellIdx(range, 'isFilterHeader');
                prop.length && (isHdr = prop[0].value);
            }
            if (isHdr) {
                for (var i = 0; i < tableRange.length; i++) {
                    if (tableRange[i].tableID === -1) {
                        tblObj = tableRange[i];
                        tAlphaRange = this._getAlphaRange(sheetIdx, tblObj.startRow - 1, tblObj.multifilterIdx[0], tblObj.endRow, tblObj.multifilterIdx[tblObj.multifilterIdx.length - 1]);
                        return (aRange === tAlphaRange) ? { status: 'full', tRange: tAlphaRange, tblId: -1 } : { status: 'partial' };
                    }
                }
				return { status: 'no-table' };
            }
            else
                return { status: 'no-table' };
        },

        clearTextNode: function (td, text) {
            if (ej.isNullOrUndefined(td) || this.model.isReadOnly)
                return;
            var sheetIdx = this.getActiveSheetIndex(), rowIndex = td[0].parentNode.rowIndex, colIndex = td[0].cellIndex, container = this._dataContainer.sheets[sheetIdx], node = td[0].childNodes[td[0].childNodes.length - 1];
            text = text || "";
            if (this._checkIndicesInContainer(sheetIdx, rowIndex, colIndex, "rule"))
                if (container[rowIndex][colIndex].rule.type === "list")
                    return;
            if (ej.isNullOrUndefined(node) || node.hasChildNodes("a"))
                return;
            else
                td[0].lastChild.textContent = text;
        },

        _isClassHasProperty: function (cls, property, value) {
            var format = this.XLFormat.getFormatFromHashCode(cls);
            if (format[property] && format[property].toLowerCase() === value)
                return true;
            else
                return false;
        },

        _changeTargetWithOffset: function (e) {                       //get a cell by position of mouse pointer
            var trgt, $trgt =  $(e.target), offset = e.offsetX || e.pageX - $trgt.offset().left;
            if (this._hasClass(document.activeElement, 'e-datepicker') && e.type === "mouseup")
                $('#' + this._id).focus();
            if ($trgt.is('a')) {
                trgt = e.target;
                e.target = e.target.parentNode;
            }
            if ($trgt.is('#' + this._id + '_Merge'))
                return $trgt.parents().closest('td')[0];
            if (this._hasClass($trgt.parents().closest('td'), 'e-cellreadonly')) {
                if (this._hasClass($trgt, 'e-datepicker') && e.type === 'mouseup') {
                    $trgt.focus();
                }
                return $trgt.parents().closest('td')[0];
            }
            if ($trgt.is('td') && this._hasClass($trgt, 'e-cellreadonly'))
                if ($trgt.find('.e-chk-image').length > 0 && e.type === "mouseup") {
                    $('#' + $trgt.find('.e-checkbox')[0].id).ejCheckBox('instance')._checkedHandler();
                    return e.target;
                }
            if ((offset > e.target.offsetWidth || offset < 0) && ($trgt.is('td') && $trgt.parents(".e-spreadsheetmainpanel").length && this._hasClass($trgt, "e-rowcell"))) {
                var sheet = this.getSheet(this.getActiveSheetIndex()), cell = this._getCellIdx(e.target),
                 left = sheet._colWidthCollection[cell.colIndex] + offset,
                 top = sheet._rowHeightCollection[cell.rowIndex];
                trgt && this.addClass(trgt, 'e-rmanchor');
                return this.getCell(this.XLShape._getCellIndexFromOffset(top, left).rowIndex, this.XLShape._getCellIndexFromOffset(top, left).colIndex)[0];
            }
            else {
                if (trgt) {
                    this._removeClass(trgt, 'e-rmanchor');
                    return trgt;
                }
                else {
                    this._removeClass($trgt.find('a')[0], 'e-rmanchor');
                    return e.target;
                }
            }
        },

        _textClip: function (rowIndex, colIndex, action, width, isOnlyRemoval) {
            if (!this._canOverflow || this.XLEdit.getPropertyValue(rowIndex, colIndex, 'merge') || this.XLEdit.getPropertyValue(rowIndex, colIndex, 'wrap'))
                return;
            var keys, parseCell, val, cell, elem, rIdx, cIdx, prop, ofObj, endCell, tempCell, rowsColl, colsColl, overflow, container, cellStyle, span, chngd = false, isText = false, isFormat = false,
               isPrevOverflow = false, xlEdit = this.XLEdit, sheetIndex = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIndex),
			 load = (sheet._isLoaded || this.isImport), $cell = this.getCell(rowIndex, colIndex), format = xlEdit.getPropertyValue(rowIndex, colIndex, 'format', sheetIndex);
            if ($cell)
                cell = $cell[0];
            if (this._isClassHasProperty(format, 'text-align', 'right'))
                isFormat = true;
            if (xlEdit.getPropertyValue(rowIndex, colIndex, 'cellType', sheetIndex) > -1)
                return;
            if (!this._dupDetails)
                this._dupDetails = chngd = true;
            if (action === 'add') {
                if (!this.model.allowOverflow) {
                    this.addClass(cell, 'e-overflow');
                    xlEdit._updateDataContainer({ rowIndex: rowIndex, colIndex: colIndex }, { dataObj: { isOverflow: false }, skipCell: true });
                    chngd && (this._dupDetails = false);
                    return;
                }
                if (this._hasClass(cell, 'e-overflow'))
                    this._removeClass(cell, 'e-overflow');
                this.clearRangeData([rowIndex, colIndex, rowIndex, colIndex], ['isOverflow'], '', '', '', true);
                if (xlEdit.getPropertyValue(rowIndex, colIndex + 1, 'value2', sheetIndex) && !isFormat)
                    isText = true;
                if (!isText) {
                    rowsColl = sheet._rowHeightCollection;
                    colsColl = sheet._ofColWidthColl;
                    cellStyle = cell ? this.XLFormat.getFormatFromHashCode(this.XLFormat.getFormatClass(cell.className)) : {};
                    if (!width) {
                        span = document.getElementById(this._id + '_emptySpan');
                        this.addClass(span, 'e-rowcell e-wrapword');
                        this.addClass(span, format);
                        span.textContent = xlEdit.getPropertyValue(rowIndex, colIndex, 'value2', sheetIndex);
                        if ("text-indent" in cellStyle)
                            width = Math.round((4 / 3) * Number(cellStyle[ej.Spreadsheet.SupportedStyles.TextIndent].replace("pt", "")) + this._detailsFromGlobalSpan(rowIndex, colIndex, "width", span.textContent, null, true));     //calculating offset for text + indent 
                        else
                            width = span.offsetWidth;
                    }
                    this._refreshGlobalSpan(span);
                    endCell = this.XLShape._getCellIndexFromOffset(null, (colsColl[colIndex] + width), sheetIndex, true);
                    val = endCell.colIndex - colIndex;
                }
                if (!isOnlyRemoval && xlEdit.getPropertyValue(rowIndex, colIndex, 'value2', sheetIndex)) {
                    overflow = xlEdit.getPropertyValue(rowIndex, colIndex, 'overflow', sheetIndex);
                    if (!ej.isNullOrUndefined(overflow) && overflow.rowIndex === rowIndex) {
                        tempCell = this.getCell(overflow.rowIndex, overflow.colIndex);
                        if (tempCell)
                            this.addClass(tempCell[0], 'e-overflow');
                        xlEdit._updateDataContainer({ rowIndex: overflow.rowIndex, colIndex: overflow.colIndex }, { dataObj: { isOverflow: false }, skipCell: true });
                        if (overflow.colIndex < colIndex)
                            for (var j = 0, len = overflow['cellCount']; j <= len; j++) {
                                (j !== 0) && this.clearRangeData([rowIndex, overflow.colIndex + j, rowIndex, overflow.colIndex + j], ['overflow'], '', '', '', true);
                                if (j !== len) {
                                    elem = this.getCell(rowIndex, overflow.colIndex + j);
                                    if (load && elem)
                                        this._removeClass(elem[0], 'e-ofbrdr');
                                    this.clearRangeData([rowIndex, overflow.colIndex + j, rowIndex, overflow.colIndex + j], ['isOfBrdr'], '', '', '', true);
                                }
                            }
                        else {
                            for (var j = overflow['cellCount']; j > 0; j--) {
                                this.clearRangeData([rowIndex, overflow.colIndex - j, rowIndex, overflow.colIndex - j], ['overflow'], '', '', '', true);
                                elem = this.getCell(rowIndex, overflow.colIndex - j);
                                if (load && elem)
                                    this._removeClass(elem[0], 'e-ofbrdr');
                                this.clearRangeData([rowIndex, overflow.colIndex - j, rowIndex, overflow.colIndex - j], ['isOfBrdr'], '', '', '', true);
                            }
                        }
                    }
                }
                if (!isFormat && !isText) {
                    for (var j = 1; j <= val; j++)
                        if (xlEdit.getPropertyValue(rowIndex, colIndex + j, 'value2', sheetIndex) || xlEdit.getPropertyValue(rowIndex, colIndex + j, 'merge', sheetIndex) || xlEdit.getPropertyValue(rowIndex, colIndex + j, 'isMHide', sheetIndex) || (xlEdit.getPropertyValue(rowIndex, colIndex + j, 'overflow', sheetIndex) && xlEdit.getPropertyValue(rowIndex, colIndex + j, 'overflow', sheetIndex).colIndex !== colIndex)) {
                            isText = true;
                            break;
                        }
                }
                else
                    for (var j = colIndex - 1, len = colIndex - val; j >= len; j--) {
                        ofObj = xlEdit.getPropertyValue(rowIndex, j, 'overflow', sheetIndex);
                        if (ofObj && ofObj.colIndex !== colIndex && !isPrevOverflow) {
                            isPrevOverflow = true;
                            this._textClip(ofObj.rowIndex, ofObj.colIndex, 'delete', '', true);
                            var $cell = this.getCell(ofObj.rowIndex, ofObj.colIndex);
                            if ($cell)
                                this.addClass($cell[0], 'e-overflow');
                        }
                        if (xlEdit.getPropertyValue(rowIndex, j, 'value2', sheetIndex)) {
                            isText = true;
                            break;
                        }
                    }
                if (!isText) {
                    if (val !== 0)
                        for (var j = 0; j <= val; j++) {
                            cIdx = (isFormat) ? colIndex - j : colIndex + j;
                            if (j)
                                xlEdit._updateDataContainer({ rowIndex: rowIndex, colIndex: cIdx }, { dataObj: { overflow: { rowIndex: rowIndex, colIndex: colIndex, cellCount: val } }, skipCell: true });
                            if (((!isFormat || (isFormat && j !== 0)) && j !== val) || (j === val && isFormat)) {
                                if (load && this._isRowViewable(sheetIndex, rowIndex))
                                    this.addClass(this.getCell(rowIndex, cIdx)[0], 'e-ofbrdr');
                                xlEdit._updateDataContainer({ rowIndex: rowIndex, colIndex: cIdx }, { dataObj: { isOfBrdr: true }, skipCell: true });
                            }
                        }
                }
                else {
                    this.addClass(cell, 'e-overflow');
                    xlEdit._updateDataContainer({ rowIndex: rowIndex, colIndex: colIndex }, { dataObj: { isOverflow: false }, skipCell: true });
                }
            }
            else if (action === 'delete') {
                container = this._dataContainer.sheets[sheetIndex];
                keys = this.getObjectKeys(container[rowIndex]);
                if (this._hasClass(cell, 'e-overflow')) {
                    this._removeClass(cell, 'e-overflow');
                    this.clearRangeData([rowIndex, colIndex, rowIndex, colIndex], ['isOverflow'], '', '', '', true);
                }
                else {
                    if (!isFormat) {
                        ofObj = xlEdit.getPropertyValue(rowIndex, colIndex + 1, 'overflow', sheetIndex);
                        if (!ej.isNullOrUndefined(ofObj) && ofObj.colIndex === colIndex)
                            for (var i = colIndex, len = colIndex + 1 + ofObj['cellCount']; i < len; i++) {
                                (i !== colIndex) && this.clearRangeData([rowIndex, i, rowIndex, i], ['overflow'], '', '', '', true);
                                if (i !== len) {
                                    if (load) {
                                        elem = this.getCell(rowIndex, i);
                                        if (elem)
                                            this._removeClass(elem[0], 'e-ofbrdr');
                                    }
                                    this.clearRangeData([rowIndex, i, rowIndex, i], ['isOfBrdr'], '', '', '', true);
                                }
                            }
                    }
                    else {
                        ofObj = xlEdit.getPropertyValue(rowIndex, colIndex - 1, 'overflow', sheetIndex);
                        if (!ej.isNullOrUndefined(ofObj) && ofObj.colIndex === colIndex)
                            for (var i = colIndex - 1, len = colIndex - ofObj['cellCount']; i >= len; i--) {
                                this.clearRangeData([rowIndex, i, rowIndex, i], ['overflow'], '', '', '', true);
                                if (load) {
                                    elem = this.getCell(rowIndex, i);
                                    if (elem)
                                        this._removeClass(elem[0], 'e-ofbrdr');
                                }
                                this.clearRangeData([rowIndex, i, rowIndex, i], ['isOfBrdr'], '', '', '', true);
                            }
                    }
                }
                if (!isOnlyRemoval && this.model.allowOverflow) {
                    for (var i = keys.indexOf(colIndex.toString()) - 1; i > -1; i--) {
                        if (load)
                            parseCell = this.getCell(rowIndex, keys[i]);
                        if (xlEdit.getPropertyValue(rowIndex, keys[i], 'value2', sheetIndex) || xlEdit.getPropertyValue(rowIndex, keys[i], 'isMHide', sheetIndex)) {
                            if (this._hasClass(parseCell, 'e-overflow')) {
                                if (parseCell)
                                    this._removeClass(parseCell[0], 'e-overflow');
                                this.clearRangeData([rowIndex, keys[i], rowIndex, keys[i]], ['isOverflow'], '', '', '', true);
                                this._textClip(rowIndex, parseInt(keys[i]), 'add');
                            }
                            break;
                        }
                    }
                    for (var i = keys.indexOf(colIndex.toString()) + 1; i < keys.length; i++) {
                        if (load)
                            parseCell = this.getCell(rowIndex, keys[i]);
                        if (xlEdit.getPropertyValue(rowIndex, keys[i], 'value2', sheetIndex) || xlEdit.getPropertyValue(rowIndex, keys[i], 'isMHide', sheetIndex)) {
                            format = xlEdit.getPropertyValue(rowIndex, keys[i], 'format', sheetIndex);
                            if (this._hasClass(parseCell, 'e-overflow') && this._isClassHasProperty(format, 'text-align', 'right')) {
                                if (parseCell)
                                    this._removeClass(parseCell[0], 'e-overflow');
                                this.clearRangeData([rowIndex, keys[i], rowIndex, keys[i]], ['isOverflow'], '', '', '', true);
                                this._textClip(rowIndex, parseInt(keys[i]), 'add');
                            }
                            break;
                        }
                    }
                }
            }
            chngd && (this._dupDetails = false);
        },

        selectAll: function (isbgSelect) {
            if (!this.model.allowSelection)
                return;
            var len, eColArr = [], sRowArr = [], eRowArr = [], sColArr = [], i, j, k, multiSelect = false, loopLength = 0, xlEdit = this.XLEdit, activeCell = this.getActiveCell(), rIdx = activeCell.rowIndex, cIdx = activeCell.colIndex,
            sheetIdx = this.getActiveSheetIndex(), container = this._dataContainer.sheets[sheetIdx], rows = this.getObjectKeys(container),
            startRowIdx = parseInt(rows[0]), endRowIdx = parseInt(rows[rows.length - 1]), sheet = this.getSheet(sheetIdx),
            usedRange = this._getUsedRangeFromSheet(sheetIdx, false), length = usedRange.rowCount + usedRange.colCount, rowsCount, colsCount;
            if (sheet._startCell.rowIndex !== sheet._endCell.rowIndex || sheet._startCell.colIndex !== sheet._endCell.colIndex && sheet._isMultiSelect) {
                var startCell = { rowIndex: sheet._startCell.rowIndex, colIndex: sheet._startCell.colIndex },
                    endCell = { rowIndex: sheet._endCell.rowIndex, colIndex: sheet._endCell.colIndex },
                    tempStart = { rowIndex: sheet._startCell.rowIndex, colIndex: sheet._startCell.colIndex },
                    tempEnd = { rowIndex: sheet._endCell.rowIndex, colIndex: sheet._endCell.colIndex };
                multiSelect = true;
                for (i = 1; i < length; i++) {
                    for (j = tempStart.colIndex; j < tempEnd.colIndex + 2; j++) {                            // Multiselect
                        if (xlEdit.getPropertyValue(tempStart.rowIndex - 1, j, 'value2', sheetIdx) || this._getDataObj(tempStart.rowIndex - 1, j, 'mergeIdx', sheetIdx)) {
                            startCell.colIndex = tempStart.colIndex < j ? tempStart.colIndex : j;
                            endCell.colIndex = tempEnd.colIndex > j ? tempEnd.colIndex : j;
                            startCell.rowIndex = tempStart.rowIndex < tempStart.rowIndex - 1 ? tempStart.rowIndex : tempStart.rowIndex - 1;
                        }
                    }
                    for (j = tempStart.rowIndex; j < tempEnd.rowIndex + 2; j++) {
                        if (xlEdit.getPropertyValue(j, tempEnd.colIndex + 1, 'value2', sheetIdx) || this._getDataObj(j, tempEnd.colIndex + 1, 'mergeIdx', sheetIdx)) {
                            endCell.rowIndex = tempEnd.rowIndex > j ? tempEnd.rowIndex : j;
                        }
                    }
                    for (j = tempEnd.colIndex; j > tempStart.colIndex - 2; j--) {
                        if (xlEdit.getPropertyValue(tempEnd.rowIndex + 1, j, 'value2', sheetIdx) || this._getDataObj(tempEnd.rowIndex + 1, j, 'mergeIdx', sheetIdx)) {
                            endCell.rowIndex = tempEnd.rowIndex > tempEnd.rowIndex + 1 ? tempEnd.rowIndex : tempEnd.rowIndex + 1;
                            startCell.colIndex = tempStart.colIndex < j ? tempStart.colIndex : j;
                        }
                    }
                    for (j = tempEnd.rowIndex; j > tempStart.rowIndex - 2; j--) {
                        if (xlEdit.getPropertyValue(tempEnd.rowIndex + 1, j, 'value2', sheetIdx) || this._getDataObj(tempEnd.rowIndex + 1, j, 'mergeIdx', sheetIdx)) {
                            endCell.rowIndex = tempEnd.rowIndex > tempEnd.rowIndex + 1 ? tempEnd.rowIndex : tempEnd.rowIndex + 1;
                            startCell.colIndex = tempStart.colIndex < j ? tempStart.colIndex : j;
                        }
                    }
                    if (endCell.colIndex === tempEnd.colIndex && endCell.rowIndex === tempEnd.rowIndex && startCell.rowIndex === tempStart.rowIndex && startCell.colIndex === tempStart.colIndex) {
                        if (i === 1) {
                            sheet._isRangeSelected = true;
                            break;
                        }
                        else {
                            sheet._isRangeSelected = false;
                            break;
                        }
                    }
                    tempStart = { rowIndex: startCell.rowIndex, colIndex: startCell.colIndex };
                    tempEnd = { rowIndex: endCell.rowIndex, colIndex: endCell.colIndex };
                }
            }
            if (!sheet._isRangeSelected && !multiSelect) {
                var startCell = { rowIndex: rIdx, colIndex: cIdx },
                    endCell = { rowIndex: rIdx, colIndex: cIdx },
                    tempStart = { rowIndex: rIdx, colIndex: cIdx },
                    tempEnd = { rowIndex: rIdx, colIndex: cIdx };
                for (i = 1; i < length + 1; i++) {
                    for (j = -loopLength; j < loopLength + 1; j++) {                            // start from right
                        if (xlEdit.getPropertyValue(rIdx + j, cIdx + i, 'value2', sheetIdx) || this._getDataObj(rIdx + j, cIdx + i, 'mergeIdx', sheetIdx)) {
                            endCell.rowIndex = endCell.rowIndex > rIdx + j ? endCell.rowIndex : rIdx + j;
                            endCell.colIndex = endCell.colIndex > cIdx + i ? endCell.colIndex : cIdx + i;
                        }
                    }
                    if (xlEdit.getPropertyValue(rIdx + i, cIdx + i, 'value2', sheetIdx) || this._getDataObj(rIdx + i, cIdx + i, 'mergeIdx', sheetIdx)) {
                        endCell.rowIndex = endCell.rowIndex > rIdx + i ? endCell.rowIndex : rIdx + i;
                        endCell.colIndex = endCell.colIndex > cIdx + i ? endCell.colIndex : cIdx + i;
                    }
                    for (j = -loopLength; j < loopLength + 1; j++) {
                        if (xlEdit.getPropertyValue(rIdx + i, cIdx + j, 'value2', sheetIdx) || this._getDataObj(rIdx + i, cIdx + j, 'mergeIdx', sheetIdx)) {
                            endCell.rowIndex = endCell.rowIndex > rIdx + i ? endCell.rowIndex : rIdx + i;
                            endCell.colIndex = endCell.colIndex > cIdx + j ? endCell.colIndex : cIdx + j;
                        }
                    }
                    if (!xlEdit.getPropertyValue(rIdx, cIdx, 'value2', sheetIdx)) {
                        if (endCell.colIndex === tempEnd.colIndex && endCell.rowIndex === tempEnd.rowIndex && startCell.rowIndex === tempStart.rowIndex && startCell.colIndex === tempStart.colIndex) {
                            if (loopLength === 0) {
                                sheet._isRangeSelected = true;
                                break;
                            }
                        }
                    }
                    if (xlEdit.getPropertyValue(rIdx + i, cIdx - i, 'value2', sheetIdx) || this._getDataObj(rIdx + i, cIdx - i, 'mergeIdx', sheetIdx)) {
                        endCell.rowIndex = endCell.rowIndex > rIdx + i ? endCell.rowIndex : rIdx + i;
                        startCell.colIndex = startCell.colIndex < cIdx - i ? startCell.colIndex : cIdx - i;
                    }
                    for (j = -loopLength; j < loopLength + 1; j++) {
                        if (xlEdit.getPropertyValue(rIdx + j, cIdx - i, 'value2', sheetIdx) || this._getDataObj(rIdx + j, cIdx - i, 'mergeIdx', sheetIdx)) {
                            startCell.rowIndex = startCell.rowIndex < rIdx + j ? startCell.rowIndex : rIdx + j;
                            startCell.colIndex = startCell.colIndex < cIdx - i ? startCell.colIndex : cIdx - i;
                            endCell.rowIndex = endCell.rowIndex > rIdx + j ? endCell.rowIndex : rIdx + j;
                        }
                    }
                    if (xlEdit.getPropertyValue(rIdx - i, cIdx - i, 'value2', sheetIdx) || this._getDataObj(rIdx - i, cIdx - i, 'mergeIdx', sheetIdx)) {
                        startCell.rowIndex = startCell.rowIndex < rIdx - i ? startCell.rowIndex : rIdx - i;
                        startCell.colIndex = startCell.colIndex < cIdx - i ? startCell.colIndex : cIdx - i;
                    }
                    for (j = -loopLength; j < loopLength + 1; j++) {
                        if (xlEdit.getPropertyValue(rIdx - i, cIdx + j, 'value2', sheetIdx) || this._getDataObj(rIdx - i, cIdx + j, 'mergeIdx', sheetIdx)) {
                            startCell.rowIndex = startCell.rowIndex < rIdx - i ? startCell.rowIndex : rIdx - i;
                            startCell.colIndex = startCell.colIndex < cIdx + j ? startCell.colIndex : cIdx + j;
                            endCell.colIndex = endCell.colIndex > cIdx + j ? endCell.colIndex : cIdx + j;
                        }
                    }
                    if (xlEdit.getPropertyValue(rIdx - i, cIdx + i, 'value2', sheetIdx) || this._getDataObj(rIdx - i, cIdx + i, 'mergeIdx', sheetIdx)) {
                        startCell.rowIndex = startCell.rowIndex < rIdx - i ? startCell.rowIndex : rIdx - i;
                        endCell.colIndex = endCell.colIndex > cIdx + i ? endCell.colIdx : cIdx + i;
                    }
                    if (endCell.colIndex === tempEnd.colIndex && endCell.rowIndex === tempEnd.rowIndex && startCell.rowIndex === tempStart.rowIndex && startCell.colIndex === tempStart.colIndex) {
                        if (loopLength !== 0) {
                            sheet._isRangeSelected = false;
                            break;
                        }
                        else {
                            sheet._isRangeSelected = true;
                            break;
                        }
                    }
                    tempStart = { rowIndex: startCell.rowIndex, colIndex: startCell.colIndex };
                    tempEnd = { rowIndex: endCell.rowIndex, colIndex: endCell.colIndex };
                    loopLength++;
                    eColArr.push(endCell.colIndex);
                    sRowArr.push(startCell.rowIndex);
                    eRowArr.push(endCell.rowIndex);
                    sColArr.push(startCell.colIndex);
                }
                sColArr = ej.dataUtil.mergeSort(ej.distinct(sColArr));
                startCell.colIndex = sColArr[sColArr.length - 1];
                for (k = sColArr.length - 1; k > -1; k--) {
                    if (sColArr[k - 1] === sColArr[k] - 1)
                        startCell.colIndex = sColArr[k - 1];
                    else
                        break;
                }
                eRowArr = ej.dataUtil.mergeSort(ej.distinct(eRowArr));
                endCell.rowIndex = eRowArr[0];
                for (k = 0, len = eRowArr.length - 1; k < len; k++) {
                    if (eRowArr[k + 1] === eRowArr[k] + 1)
                        endCell.rowIndex = eRowArr[k + 1];
                    else
                        break;
                }
                sRowArr = ej.dataUtil.mergeSort(ej.distinct(sRowArr));
                startCell.rowIndex = sRowArr[sRowArr.length - 1];
                for (k = sRowArr.length - 1; k > -1; k--) {
                    if (sRowArr[k - 1] === sRowArr[k] - 1)
                        startCell.rowIndex = sRowArr[k - 1];
                    else
                        break;
                }
                eColArr = ej.dataUtil.mergeSort(ej.distinct(eColArr));
                endCell.colIndex = eColArr[0];
                for (k = 0, len = eColArr.length - 1; k < len; k++) {
                    if (eColArr[k + 1] === eColArr[k] + 1)
                        endCell.colIndex = eColArr[k + 1];
                    else
                        break;
                }
                for (k = 0, len = eColArr.length - 1; k < len; k++) {
                    if (eColArr[k + 1] === eColArr[k] + 1)
                        endCell.colIndex = eColArr[k + 1];
                    else
                        break;
                }
            }
            if (!sheet._isEmptyActiveCell) {
                if (!sheet._isRangeSelected && !rows.length < 1) {
                    this.XLSelection.selectRange(startCell, endCell, sheetIdx, isbgSelect);
                    sheet._isMultiSelect = false;
                    sheet._startCell = startCell;
                    sheet._endCell = endCell;
                    sheet._isRangeSelected = true;
                    if (!xlEdit.getPropertyValue(rIdx, cIdx, 'value2', sheetIdx))
                        sheet._isEmptyActiveCell = true;
                    else
                        sheet._isEmptyActiveCell = false;
                }
                else {
                    this.XLSelection.selectSheet();
                    sheet._isRangeSelected = true;
                }
            }
        },

        _getDataObj: function (rowIdx, colIdx, property, sheetIdx) {
            var sheetData = this._dataContainer.sheets[sheetIdx ? sheetIdx : this.getActiveSheetIndex()];
            if (sheetData[rowIdx])
                if (sheetData[rowIdx][colIdx])
                    return sheetData[rowIdx][colIdx][property];
            return false;
        },

        _getUsedRangeFromSheet: function (sheetIdx, val) {
            sheetIdx = this._getSheetIndex(sheetIdx);
            var i, colKeys, sheet = this.getSheet(sheetIdx), container = this._dataContainer, value,
                rows = container.sheets[sheetIdx], rowKeys = this.getObjectKeys(rows), startCell = { rowIndex: parseInt(rowKeys[0]) || 0, colIndex: 0 }, endCell = { rowIndex: parseInt(rowKeys[rowKeys.length - 1]) || 0, colIndex: 0 };
            for (i = 0, length = rowKeys.length; i < length; i++) {
                colKeys = this.getObjectKeys(rows[parseInt(rowKeys[i])]);
                if (i === 0) {
                    startCell.colIndex = parseInt(colKeys[0]);
                    endCell.colIndex = parseInt(colKeys[colKeys.length - 1])
                }
                else {
                    startCell.colIndex = (startCell.colIndex < parseInt(colKeys[0])) ? startCell.colIndex : parseInt(colKeys[0]);
                    endCell.colIndex = (endCell.colIndex > parseInt(colKeys[colKeys.length - 1])) ? endCell.colIndex : parseInt(colKeys[colKeys.length - 1]);
                }
            }
            // compare with existing used range
            if (endCell.rowIndex < sheet.usedRange.rowIndex)
                endCell.rowIndex = sheet.usedRange.rowIndex;
            if (endCell.colIndex < sheet.usedRange.colIndex)
                endCell.colIndex = sheet.usedRange.colIndex;
            if (val)
                return this._getAlphaRange(sheetIdx, startCell.rowIndex, startCell.colIndex, endCell.rowIndex, endCell.colIndex);
            else {
                value = { startCell: startCell, endCell: endCell, rowCount: endCell.rowIndex - startCell.rowIndex + 1, colCount: endCell.colIndex - startCell.colIndex + 1 };
                return value;
            }
        },

        sheetRename: function (sheetName) {
            if (!this.model.isReadOnly)
                this._updateSheetNames(sheetName);
        },

        _isSubMenuOpen: function () {
            var arr = ["_formatastable", "_cellstyles", "_Ribbon_CElement", "_contextMenuCell", "_contextMenuColumnHeader", "_contextMenuRowHeader", "_contextMenuFooter"], i = 0, len = arr.length;
            while (i < len) {
                if ($("#" + this._id + arr[i]).is(":visible"))
                    return true;
                i++;
            }
            return false;
        },

        copySheet: function (fromIndex, toIndex, isCopySheet) {
            if (this.model.isReadOnly)
                return;
            var sheetIdx = this._getSheetIndex(sheetIdx);
            var spliceIndex, i, len, cpySheetName, isValid = false, sheetNameCount = 2, index, sheets = this.model.sheets,
                selectedItem = this.element.find(".e-numericcontainer").children().eq(fromIndex - 1), mainIndex = toIndex;
            //Check is same sheet
            if (!isCopySheet && sheets[mainIndex].sheetInfo.text === selectedItem.text()) {
                this.setSheetFocus();
                return;
            }
            //Getting splice index and sheet position index
            for (i = 1, len = sheets.length; i < len; i++) {
                if (sheets.length - 1 !== mainIndex && sheets[mainIndex].sheetInfo.text === sheets[i].sheetInfo.text)
                    spliceIndex = i;
                if (selectedItem.text() === sheets[i].sheetInfo.text)
                    index = i;
            }
            //Check is Copy sheet
            if (isCopySheet) {
                // Getting unique sheet name
                if (selectedItem.text().match('.*[ ]+[(]+[0-9]+[)]$') === null)
                    cpySheetName = selectedItem.text() + " (" + sheetNameCount + ")";
                else {
                    if (selectedItem.text().lastIndexOf(' ') > -1) {
                        sheetNameCount = parseInt(selectedItem.text().substring(selectedItem.text().lastIndexOf("(") + 1, selectedItem.text().lastIndexOf(")")));
                        cpySheetName = selectedItem.text().substring(0, selectedItem.text().lastIndexOf(" ")) + " (" + sheetNameCount + ")";
                    }
                }
                while (!isValid) {
                    cpySheetName = cpySheetName.substring(0, cpySheetName.lastIndexOf(" ")) + " (" + sheetNameCount + ")";
                    for (i = 1, len = sheets.length; i < len; i++) {
                        if (cpySheetName === sheets[i].sheetInfo.text)
                            sheetNameCount++;
                    }
                    if (sheetNameCount === parseInt(cpySheetName.substring(cpySheetName.lastIndexOf("(") + 1, cpySheetName.lastIndexOf(")"))))
                        isValid = true;
                }
                //Copy Sheet Process      
                this._copySheetProcess(index, cpySheetName);
                index = this.model.sheetCount;
                if (ej.isNullOrUndefined(spliceIndex))
                    spliceIndex = index;
            }
            else {
                if (!ej.isNullOrUndefined(spliceIndex) && spliceIndex > index)
                    spliceIndex = spliceIndex - 1;
            }
            if (ej.isNullOrUndefined(spliceIndex))
                spliceIndex = mainIndex;
            //Sheets[] updates
            if (!isCopySheet && spliceIndex === index)
                this.setSheetFocus();
            else {
                //Update DataContainer positions
                this._swapSheetDtCntr(index, spliceIndex);
                this.getPager().ejPager("option", { currentPage: mainIndex });
                this.gotoPage(mainIndex, false);
                this.setSheetFocus();
            }
        },

        getHyperlink: function (cell) {
            return this.XLEdit.getPropertyValueByElem(cell, "hyperlink", this.getActiveSheetIndex());
        },

        getComment: function (cell) {
            return this.XLEdit.getPropertyValueByElem(cell, "comment", this.getActiveSheetIndex());
        },

        saveAsJSON: function () {
            if (this.model.isReadOnly)
                return;
            var JSONData, charts, sheets, tables, tbMngr, i = 1, sheet, dtContainer, model, len, sIdx, rIdx, cIdx, sKey, chartMngr, spliceStr = [], minHashIdx, cellTypesColl, range, pictures, picMngr, key, index, sheetProp = ["_activeCell", "_endCell", "_startCell", "colCount", "rowHeight", "columnWidth", "columnsWidthCollection",
                "rowsHeightCollection", "rowCount", "frozenColumns", "frozenRows", "styleIndex", "usedRange", "sheetName", "dataAttribute", "filterSettings", "tableManager", "sheetInfo",
                "hideColsCollection", "hideRowsCollection", "mergedCells", "showGridlines", "showHeadings", "isSheetProtected", "shapeMngr", "pivotMngr", "chart", "rangeSettings",
                "cellTypes", "startCell", "primaryKey", "showHeader", "fieldAsColumnHeader", "headerStyles", "rows"],
                dtSheetProp = ["type", "value", "value2", "decimalPlaces", "format", "formats", "borders", "formatStr", "comment", "hyperlink", "rule", "cFormatRule", "wrap", "merge", "picture", "chart", "pivot", "thousandSeparator", "isLocked", "align", "isRHide"];
            this._isSaveAsJSON = true;
            this._isExport = true;
            if (this.model.exportSettings.allowExporting)
                this.XLExport._renderAll();
            this._isExport = false;

            JSONData = { dataContainer: $.extend(true, {}, this._dataContainer), model: $.extend(true, {}, this.model) };
            dtContainer = JSONData.dataContainer;
            model = JSONData.model;
            minHashIdx = len = dtContainer.hashCode.length;
            cellTypesColl = dtContainer.sheetCellType;
            dtContainer.sheetCellType = {};

            //border prop hashcode - removed
            for (key in dtContainer.hashCode) {
                sKey = dtContainer.hashCode[key];
                if (sKey.indexOf("e-border") > -1 && sKey.length < 25)
                    spliceStr.push(sKey);
            }
            for (key = 0; key < spliceStr.length; key++)
                dtContainer.hashCode.splice(dtContainer.hashCode.indexOf(spliceStr[key]), 1);


            key = "sheets"; //unwanted sheets prop - skipped
            for (sIdx in dtContainer[key]) {
                for (rIdx in dtContainer[key][sIdx]) {
                    for (cIdx in dtContainer[key][sIdx][rIdx]) {
                        for (sKey in dtContainer[key][sIdx][rIdx][cIdx]) {
                            if (["format", "formats", "borders"].indexOf(sKey) > -1) {
                                var fStr = this._dataContainer.hashCode[this._dataContainer[key][sIdx][rIdx][cIdx][sKey]];
                                dtContainer[key][sIdx][rIdx][cIdx][sKey] = dtContainer.hashCode.indexOf(fStr);
                            }
                            if (dtSheetProp.indexOf(sKey) < 0)
                                delete dtContainer[key][sIdx][rIdx][cIdx][sKey];
                        }
                        if (!this.getObjectLength(dtContainer[key][sIdx][rIdx][cIdx]))
                            delete dtContainer[key][sIdx][rIdx][cIdx];
                    }
                    if (!this.getObjectLength(dtContainer[key][sIdx][rIdx]))
                        delete dtContainer[key][sIdx][rIdx];
                }
            }

            //model default value - skipped
            for (key in model) {
                if (model[key] === this.defaults[key] || Object.prototype.toString.call(model[key]) === Object.prototype.toString())
                    delete model[key];
                else if (Array.isArray(model[key]))
                    if (!model[key].length)
                        delete model[key];
            }

            sheets = model.sheets;

            while (i < sheets.length) {
                sheet = sheets[i];

                for (key in sheet) {

                    switch (key) {
                        case "frozenColumns":
                        case "frozenRows":
                            if (sheet[key] === 0) // 0 - default
                                delete sheet[key];
                            break;
                        case "fieldAsColumnHeader":
                        case "isSheetProtected":
                            if (!sheet[key]) // false - default
                                delete sheet[key];
                            break;
                        case "showHeadings":
                        case "showGridlines":
                        case "showHeader":
                            if (sheet[key]) // true - default
                                delete sheet[key];
                            break;
                        case "filterSettings":
                            for (sKey in sheet[key]) {
                                if (sKey === "range") {
                                    if (this._isEmptyString(sheet[key][sKey]))
                                        delete sheet[key][sKey];
                                }
                                else
                                    delete sheet[key][sKey];
                            }
                            break;
                        case "sheetInfo":
                            for (sKey in sheet[key]) {
                                if (sKey !== "text") {
                                    if (sKey === "isVisible")
                                        if (!sheet[key][sKey])
                                            continue;
                                    delete sheet[key][sKey];
                                }
                            }
                            break;
                        case "_startCell":
                        case "_endCell":
                        case "_activeCell":
                        case "usedRange":
                            for (sKey in sheet[key]) {
                                if (sheet[key][sKey] === 0) // 0 index - default
                                    delete sheet[key][sKey];
                            }
                            break;
                        case "columnWidth":
                            if (sheet[key] === 64) // 64 - default 
                                delete sheet[key];
                            break;
                        case "rowHeight":
                            if (sheet[key] === 20) // 20 - default
                                delete sheet[key];
                            break;
                        case "primaryKey":
                            if (!sheet[key].length)
                                delete sheet[key];
                            break;
                        case "startCell":
                            if (sheet[key] === "A1")
                                delete sheet[key];
                            break;
                    }

                    if (sheetProp.indexOf(key) < 0 || sheet[key] === null)
                        delete sheet[key];
                    else if (Object.prototype.toString.call(sheet[key]) === Object.prototype.toString()) {
                        if (!this.getObjectLength(sheet[key]))
                            delete sheet[key];
                    }
                    else if (Array.isArray(sheet[key])) {
                        if (!sheet[key].length)
                            delete sheet[key];
                    }
                }

                //chart collection changes
                charts = sheets[i].shapeMngr["chart"];
                chartMngr = {};
                if (this.getObjectLength(charts)) {
                    index = 0;
                    for (key in charts) {
                        var cObj = $.extend(true, {}, charts[key]), cModel;
                        cModel = {
                            commonSeriesOptions: { type: cObj.type, marker: cObj.marker },
                            enable3D: cObj.enable3D,
                            top: cObj.top,
                            left: cObj.left,
                            size: { width: cObj.width, height: cObj.height },
                            title: cObj.title,
                            legend: cObj.legend,
                            primaryXAxis: cObj.primaryXAxis,
                            primaryYAxis: cObj.primaryYAxis,
                            dataSheetIdx: cObj.dataSheetIdx,
                            animation: cObj.animation,
                            isRowColSwitched: cObj.isRowColSwitched,
                            colIndex: cObj.colIndex,
                            rowIndex: cObj.rowIndex,
                            theme: cObj.theme
                        };
                        if (cObj.range)
                            cModel["range"] = this._getAlphaRange(i, cObj.range[0], cObj.range[1], cObj.range[2], cObj.range[3]);
                        if (cObj.series) {
                            cModel["series"] = [];
                            for (sKey in cObj.series) {
                                var pKey, points = [];
                                for (pKey in cObj.series[sKey]["points"])
                                    points.push({ x: cObj.series[sKey]["points"][pKey].x, y: cObj.series[sKey]["points"][pKey].y, size: cObj.series[sKey]["points"][pKey].size });
                                cModel["series"].push({ name: cObj.series[sKey]["name"], points: points });
                            }
                        }
                        if (cObj.seriesRange)
                            cModel["seriesRange"] = cObj.seriesRange;
                        if (cObj.colIndex && cObj.rowIndex)
                            dtContainer.sheets[i][cObj.rowIndex][cObj.colIndex]["chart"] = [];
                        else
                            dtContainer.sheets[i][cObj.activeCell.rowIndex][cObj.activeCell.colIndex]["chart"] = [];
                        chartMngr["chart" + index] = cModel;
                        index++;
                    }
                    sheets[i].shapeMngr["chart"] = chartMngr;
                }

                //table processing
                tables = sheets[i].tableManager;
                tbMngr = {};
                if (this.getObjectLength(tables)) {
                    index = 0;
                    for (key in tables) {
                        var prop = $.extend(true, {}, tables[key]);
                        delete prop["format"];
                        for (sKey in model.nameManager)
                            if (model.nameManager[sKey].name === prop.name)
                                model.nameManager.splice(parseInt(sKey), 1);
                        tbMngr[index] = prop;
                        index++;
                    }
                    sheets[i].tableManager = tbMngr;
                }

                //Cell types
                sheet.cellTypes = [];
                len = this.getObjectLength(cellTypesColl);
                if (len)
                    dtContainer.sheetCellType[i] = {};
                index = 1;
                for (key in cellTypesColl) {
                    sKey = cellTypesColl[key];
                    if (!this.getObjectLength(sKey))
                        continue;
                    range = sKey.id.split('_')[2];
                    sIdx = parseInt(range.match(/[0-9]+/)[0]);
                    if (i === sIdx) {
                        delete sKey["id"];
                        sKey["range"] = range.replace(/[0-9]+/, "");
                        dtContainer.sheetCellType[i][index] = { "settings": sKey };
                        cellTypesColl[key] = {};
                        index++;
                    }
                }
                sheets[i]._scrollTop = this.getSheet(i)._scrollTop;
                sheets[i]._scrollLeft = this.getSheet(i)._scrollLeft;
                i++;
            }
			model["isManualCalculation"] = this._calcEngine.getCalculatingSuspended();
            this._isSaveAsJSON = false;
			model.sheets.shift();
            return JSONData;
        },

        _isvalidRange: function (alphaRange) {
            var regx = new RegExp(/^\$?(?:\b[a-z]{1,3})\$?(?:\d{1,7}):\$?(?:\b[a-z]{1,3})\$?(?:\d{1,7})$/i);
            return regx.test(alphaRange);
        },

        // upload
        _renderFUpload: function () {
            this.element.append(ej.buildTag("div", "", { height: "0px" }, { id: this._id + "_file" }));
            $("#" + this._id + "_file").ejUploadbox({
                width: "0px",
                height: "0px",
                uploadName: "file",
                autoUpload: true,
                showFileDetails: false,
                dialogAction: { content: this.element },
                saveUrl: this.model["importSettings"].importMapper,
                fileSelect: $.proxy(this._fileSelect, this),
                complete: $.proxy(this._changeImport, this),
                error: $.proxy(this._importFailed, this)
            });
            $("#" + this._id + "_file_SelectButton").hide();
        },

        _fileSelect: function (args) {
		    if(!args.files.length)
			    return;
            var upBox, file = args.files[0], extension = file.extension;
            if ((this._uploadImage && (extension === ".xlsx" || extension === ".csv")) || (!this._uploadImage && (!(this._browserDetails.name === "msie" && parseInt(this._browserDetails.version) < 10) ? (file.rawFile.type.indexOf("image") > -1) : (extension.indexOf("jpg") > -1 || extension.indexOf("png") > -1 || extension.indexOf("jpeg") > -1 || extension.indexOf("gif") > -1)))) {
                this._showAlertDlg("Alert", "CorrectFormat", "", 290);
                this._uploadImage = false;
                return false;
            }
            if (!(this._browserDetails.name === "msie" && parseInt(this._browserDetails.version) < 10) && !this._uploadImage) {
                upBox = $("#" + this._id + "_file");
                upBox.ejUploadbox("option", "autoUpload", false);
                this["import"]({ file: file.rawFile, password: this.model.importSettings.password, allowSheetOnDemand: this.model.importSettings.allowSheetOnDemand });
                upBox.find(".e-uploadinput").val("");
                args.cancel = true;
            }
            else
                this.showWaitingPopUp();
            this._uploadImage = false;
        },

        _changeImport: function (args) {
            var response, upObj = $("#" + this._id + "_file").data("ejUploadbox");
            if (!(this._browserDetails.name === "msie" && parseInt(this._browserDetails.version) < 10) ? (args.files.rawFile.type.indexOf("image") > -1) : (args.files[0].extension.indexOf("jpg") > -1 || args.files[0].extension.indexOf("png") > -1 || args.files[0].extension.indexOf("jpeg") > -1 || args.files[0].extension.indexOf("gif") > -1)) {
                upObj.updialog.ejDialog("close");
                this.XLShape._insertPicture(args);
                if (this.model.showRibbon)
                    this.XLRibbon._formatTabUpdate();
                upObj.option("autoUpload", true);
            }
            else {
                response = this._browserDetails.name === "msie" && parseInt(this._browserDetails.version) < 10 ? args.responseText : args.xhr.response;
                upObj.updialog.ejDialog("close");
                this._importSuccess(response);
            }
            this.hideWaitingPopUp();
        },

        _dlgBeforeOpen: function (args) {
            var dlgObj = $("#" + this._id + "_PasswordDialog").data("ejDialog");
            this.hideWaitingPopUp();
            $("#" + this._id + "_workBookName").text("'" + $("#" + this._id + "_file").data("ejUploadbox")._files[0].name + "'" + this._getLocStr("Protect"));
        },

        _dlgOk: function (args) {
            var tgleObj, dlgObj = $("#" + this._id + "_PasswordDialog").data("ejDialog"), pwdEle = $("#" + this._id + "_xlpassword"), cPwdEle = $("#" + this._id + "_confirmpassword");
            tgleObj = $("#" + this._id + "_Ribbon_Review_Changes_ProtectWorkbook").data("ejToggleButton");
            if (dlgObj.model.title === "Protect Workbook") {
                if (pwdEle.val().length && cPwdEle.val().length) {
                    if (pwdEle.val() === cPwdEle.val()) {
                        this.model.exportSettings.password = pwdEle.val();
                        $("#" + this._id + "_AddSheet").addClass("e-disable");
                        $("#" + this._id + "_confirm").hide();
                        dlgObj.option("title", this._getLocStr("UnProtectWorkbook"));
                    }
                    else {
                        $("#" + this._id + "_confirm").show();
                        this._showAlertDlg("Alert", "PasswordAlert1");
                        tgleObj && tgleObj.option("toggleState", false);
                        dlgObj.option("title", this._getLocStr("ProtectWorkbook"));
                    }
                }
                else {
                    $("#" + this._id + "_confirm").show();
                    tgleObj && tgleObj.option("toggleState", false);
                    dlgObj.option("title", this._getLocStr("ProtectWorkbook"));
                    this._showAlertDlg("Alert", "PasswordAlert2");
                }
            }
            else if (dlgObj.model.title === "Unprotect Workbook") {
                if (this.model.exportSettings.password === pwdEle.val()) {
                    $("#" + this._id + "_AddSheet").removeClass("e-disable");
                    this.model.exportSettings.password = null;
                    $("#" + this._id + "_confirm").show();
                    dlgObj.option("title", this._getLocStr("ProtectWorkbook"));
                }
                else {
                    dlgObj.option("title", this._getLocStr("UnProtectWorkbook"));
                    tgleObj && tgleObj.option("toggleState", true);
                    this._showAlertDlg("Alert", "PasswordAlert3");
                }
            }
            pwdEle.val("");
            cPwdEle.val("");
            $("#" + this._id + "_PasswordDialog").ejDialog("close");
        },

        _passwordDlg: function () {
            var $dlg, $label, $okBtn, $canBtn, $btndiv, $div;
            $dlg = ej.buildTag("div", "", "", { id: this._id + "_PasswordDialog" });
            $btndiv = ej.buildTag("div.e-dlg-btnfields");
            $div = ej.buildTag("div.e-dlg-btnctnr");
            $label = "<div class= 'e-dlgctndiv'><table><tr class= 'e-dlgtd-fields'><td><label>" + this._getLocStr("Password") + ":</label></td><td><input id ='" + this._id + "_xlpassword' type ='password' class = 'ejinputtext'/></td></tr><tr class= 'e-dlgtd-fields' id ='" + this._id + "_confirm'><td><label>" + this._getLocStr("ConfirmPassword") + "</label></td><td><input id ='" + this._id + "_confirmpassword' type ='password'  class = 'ejinputtext'/></td></tr></table></div>";
            $dlg.append($label);
            $okBtn = ej.buildTag("input", "", "", { type: "submit" });
            $canBtn = ej.buildTag("input");
            $okBtn.ejButton({ text: this._getLocStr("Ok"), showRoundedCorner: true, width: 60, click: ej.proxy(this._dlgOk, this), enabled: true, cssClass:"e-ss-okbtn" });
            $canBtn.ejButton({ text: this._getLocStr("Cancel"), click: ej.proxy(this._dlgCancel, this), showRoundedCorner: true, width: 60 });
            $btndiv.append($div.append($okBtn, $canBtn));
            $dlg.append($btndiv);
            $dlg.ejDialog({ enableModal: true, showOnInit: false, enableResize: false, allowKeyboardNavigation: false, title: this._getLocStr("ProtectWorkbook"), width: "auto", height: "auto", cssClass: "e-ss-dialog e-" + this._id + "-dlg e-ss-pwddlg", close: ej.proxy(this._dlgCancel, this) });
        },

        _importPasswordDlg: function () {
            var $dlg, $label, $okBtn, $canBtn, $btndiv, $div;
            $dlg = ej.buildTag("div", "", "", { id: this._id + "_ImportPasswordDialog" });
            $btndiv = ej.buildTag("div.e-dlg-btnfields");
            $div = ej.buildTag("div.e-dlg-btnctnr");
            $label = "<div class= 'e-dlgctndiv'><table><tr class= 'e-dlgtd-fields'><td><label id ='" + this._id + "_workBookName' ></label></td></tr><tr class= 'e-dlgtd-fields'><td><label>" + this._getLocStr("Password") + ":</label></td><td><input id ='" + this._id + "_importpassword' type ='password'  class = 'ejinputtext'/></td></tr></table></div>";
            $dlg.append($label);
            $okBtn = ej.buildTag("input", "", "", { type: "submit" });
            $canBtn = ej.buildTag("input");
            $okBtn.ejButton({ text: this._getLocStr("Ok"), showRoundedCorner: true, width: 60, click: ej.proxy(this._importDlgOk, this), enabled: true });
            $canBtn.ejButton({ text: this._getLocStr("Cancel"), click: ej.proxy(this._dlgCancel, this), showRoundedCorner: true, width: 60 });
            $btndiv.append($div.append($okBtn, $canBtn));
            $dlg.append($btndiv);
            $dlg.ejDialog({ enableModal: true, showOnInit: false, enableResize: false, allowKeyboardNavigation: false, title: this._getLocStr("Password"), beforeOpen: $.proxy(this._dlgBeforeOpen, this), width: 420, height: "auto", cssClass: "e-ss-dialog e-" + this._id + "-dlg", close: ej.proxy(this._dlgCancel, this) });
            return $dlg;
        },

        _dlgCancel: function (args) {
            this._showDialog(this._id + "_Ribbon_Review_Changes_ProtectWorkbook");
            var dlgObj = $("#" + this._id + "_PasswordDialog").data("ejDialog");
            if (dlgObj.model.title === "Protect Workbook")
                $("#" + this._id + "_Ribbon_Review_Changes_ProtectWorkbook").ejToggleButton("option", "toggleState", false);
            else if (dlgObj.model.title === "Unprotect Workbook")
                $("#" + this._id + "_Ribbon_Review_Changes_ProtectWorkbook").ejToggleButton("option", "toggleState", true);
            $("#" + this._id + "_confirmpassword").val("");
            $("#" + this._id + "_xlpassword").val("");
            $("#" + this._id + "_importpassword").val("");
            $("#" + this._id + "_PasswordDialog").ejDialog("close");
            $("#" + this._id + "_ImportPasswordDialog").ejDialog("close");
        },

        _importDlgOk: function (args) {
            var opts = {}, pwdEle = $("#" + this._id + "_importpassword");
            this.model.importSettings.password = pwdEle.val();
            pwdEle.val("");
            $("#" + this._id + "_ImportPasswordDialog").ejDialog("close");
            opts.file = $("#" + this._id + "_file").data("ejUploadbox")._files[0].rawFile;
            opts.password = this.model.importSettings.password;
            opts.allowSheetOnDemand = this.model.importSettings.allowSheetOnDemand;
            this["import"](opts);
        },

        lockCells: function (range, isLocked) {
            if (this.model.isReadOnly)
                return;
            var args, status, len, cells, i = 0, btn, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx);
            status = (isLocked != false);
            if (this.model.allowLockCell && !sheet.isSheetProtected) {
                range = this._getRangeArgs(range, "object", sheetIdx);
                args = { reqType: "lockCells", range: range, isLock: status };
                if (this._trigActionBegin(args))
                    return;
                range = args.range;
                status = args.isLock;
                if (this._isDefaultLocked)
                    status = !status;
                status ? this.updateUniqueData({ isLocked: true }, range) : this.clearRangeData(range, ["isLocked"]);
                if (this.model.showRibbon)
                    this.XLRibbon._updateRibbonIcons();
                args = { reqType: "lockCells", range: range, isLocked: status };
                if (this._trigActionComplete(args))
                    return;
            }
        },

        protectSheet: function (isProtected) {
            if (this.model.isReadOnly)
                return;
            var args, status, btn, sheetIdx = this.getActiveSheetIndex(), sheet = this.getSheet(sheetIdx), rObj = this.XLRibbon;
            status = (isProtected !== false);
			this.XLEdit._isEdit && this.XLEdit.saveCell();
            if (this.model.allowLockCell) {
                args = { reqType: "protectSheet", isProtect: isProtected, sheetIdx: sheetIdx };
                if (this._trigActionBegin(args))
                    return;
                status = args.isProtect;
                sheet.isSheetProtected = status;
                if (this.model.showRibbon) {
                    btn = $("#" + this._id + "_Ribbon_Review_Changes_LockCell").data("ejToggleButton");
                    btn && btn.option("enabled", !status);
                    status ? rObj._disableRibbonIcons() : rObj._enableRibbonIcons();
                    rObj._updateRibbonIcons();
                }
                sheet._showLockCellAlert = true;
                if (this.model.allowFormulaBar)
                    this.updateFormulaBar();
                if (this.model.allowUndoRedo) {
                    if (this.model.sheetCount > 1)
                        this._removeUndoRedoForCurSheet(sheetIdx, "undo");
                    else {
                        this._undoCollection = [];
                        this._redoCollection = [];
                    }
                }
                args = { reqType: "protectSheet", isSheetProtected: isProtected, sheetIdx: sheetIdx };
                if (!this._isSheetNavigate && this._trigActionComplete(args))
                    return;
            }
        },

        _readOnly: function () {
            var xlRibbon = this.XLRibbon, tabObj = $("#" + this._id + "_FRDialog_FPDlgTab").data("ejTab"), backStageElem = this.element.find("#" + this._id + "_Ribbon_BackStage"), formulaElem = this.element.find("#" + this._id + "_inputbox");
            if (this.model.isReadOnly) {
                xlRibbon._disableRibbonIcons();
                xlRibbon.enableRibbonItems(["Spreadsheet_Ribbon_Home_Clipboard_Copy", "Spreadsheet_Ribbon_Review_Comments_ShowAllComments", "Spreadsheet_Ribbon_Others_Editing_FindSelect"]);
                this.XLCMenu && this.XLCMenu._disableMenuOpt(["Replace", "GoTo", "GoToSpecial", "Formulas", "Comments", "CFormat", "Constants", "DataValidation"], "Ribbon_FindRep");
                if (backStageElem.length) {
                    backStageElem.find("#saveas_backStageTab").hide();
                    backStageElem.find("#print_backStageTab").hide();
                }
                this.addClass(this.element.find("#" + this._id + "_AddSheet")[0], "e-disable");
                if (formulaElem.length)
                    formulaElem[0].disabled = true;
            }
            else {
                xlRibbon._enableRibbonIcons();
                this.XLCMenu && this.XLCMenu._enableMenuOpt(["Replace", "GoTo", "GoToSpecial", "Formulas", "Comments", "CFormat", "Constants", "DataValidation"], "Ribbon_FindRep");
                if (backStageElem.length) {
                    backStageElem.find("#saveas_backStageTab").show();
                    backStageElem.find("#print_backStageTab").show();
                }
                this._removeClass(this.element.find("#" + this._id + "_AddSheet")[0], "e-disable");
                if (formulaElem.length)
                    formulaElem[0].disabled = false;
            }

        },

        _isPropExists: function (range, prop, sheetIdx, skipAlert) {
            var curRange, i, j, k, l, m = 0, flag = false;
            while (m < range.length) {
                curRange = this.swapRange(range[m]);
                i = curRange[0], j = curRange[2]
                while (i <= j) {
                    k = curRange[1];
                    l = curRange[3];
                    while (k <= l) {
                        if (this.XLEdit.getPropertyValue(i, k, prop, sheetIdx)) {
                            if (!skipAlert) {
                                if (prop === "isLocked")
                                    this._popUplockCellAlert();
                                else if (prop === "isReadOnly")
                                    this._showAlertDlg("Alert", "ReadOnly", "", 400);
                            }
                            flag = true;
                            break;
                        }
                        k++;
                    }
                    if (flag)
                        break;
                    i++;
                }
                if (flag)
                    break;
                m++;
            }
            return flag;
        },

        _isCellProtected: function (rIndex, colIndex, alertStatus) {
            if (this.model.allowLockCell && this.getSheet(this.getActiveSheetIndex()).isSheetProtected && this.XLEdit.getPropertyValue(rIndex, colIndex, "isLocked")) {
                alertStatus && this._popUplockCellAlert();
                return true;
            }
            else if (this.XLEdit.getPropertyValue(rIndex, colIndex, "isReadOnly")) {
                this._showAlertDlg("Alert", "ReadOnly", "", 400);
                return true;
            }
        },

        _popUplockCellAlert: function () {
            if (this.getSheet(this.getActiveSheetIndex())._showLockCellAlert)
                this._showAlertDlg("Alert", "LockAlert", "", 500);
        },

        _removeUndoRedoForCurSheet: function (sheetIdx, state) {
            var collection = (state === "undo") ? this._undoCollection : this._redoCollection, len = collection.length;
            if (len) {
                while (len--) {
                    if (sheetIdx === collection[len].sheetIndex)
                        collection.splice(len, 1);
                }
            }
            if (state === "undo")
                this._removeUndoRedoForCurSheet(sheetIdx, "redo");
        },

        _detailsFromGlobalSpan: function (rowIndex, colIndex, type, value, width, isFromContent) {
            var span, req, value = value || 'K', cls = "e-rowcell e-wrapword ", data = this.getRangeData({range: [rowIndex, colIndex, rowIndex, colIndex], property: ['format', 'border', 'wrap'] })[0], format = data.format, border = data.border, wrap = data.wrap, isWidth;
            isWidth = !ej.isNullOrUndefined(width);
            span = isWidth ? $('#' + this._id + '_emptyDiv') : $('#' + this._id + '_emptySpan');
            width && (span[0].style.width = width - 4 + "px"); // 2 for left padding, 1 for right paddding, 1 for right border
            if (!ej.isNullOrUndefined(format))
                cls += format + " ";
            if (!ej.isNullOrUndefined(border))
                cls += border + " ";
            else if (span[0].className.indexOf('e-rowcell') > -1)
                span[0].style.borderRight = 0; // border-right property value should 0 in span when span has 'e-rowcell' class.
            if (!ej.isNullOrUndefined(wrap))
                cls += "e-sswraptext";
            this.addClass(span[0], cls);
            (span[0].className.indexOf('e-rowcell') > -1) && (span[0].style.padding = 0); // padding property value should 0 in span when span has 'e-rowcell' class.
            span.text(value);
            if (type === 'height') {
                req = span.outerHeight();
                (!isFromContent && (this.model.rowHeight > req)) && (req = this.model.rowHeight);
            }
            else {
                req = span.outerWidth();
                (!isFromContent && (this.model.columnWidth > req)) && (req = this.model.columnWidth);
            }
            this._refreshGlobalSpan(null, isWidth);
            return req;
        },

        _writeRule: function (colIdx, sheetIdx) {
            var stag, cellProp, sheetIdx = this.getSheetElement(sheetIdx).index() + 1;
            cellProp = "#" + this._id + " .e-sheet:nth-child(" + sheetIdx + ") .e-content td.e-rowcell:nth-of-type(" + (colIdx + 1) + ")";
            stag = document.getElementById(this._id + "_sshide");
            stag.sheet.insertRule(cellProp + "{display: none}", stag.sheet.cssRules.length);
        },

        _deleteRule: function (colIdx, sheetIdx) {
            var sheetIdx = this.getSheetElement(sheetIdx).index() + 1, stag, cellProp;
            stag = document.getElementById(this._id + "_sshide");
            var rules = stag.sheet.cssRules, sheetRule = " .e-sheet:nth-child(" + sheetIdx + ") ", cellRule = ".e-rowcell:nth-of-type(" + (colIdx + 1) + ")";
            if (this._browserDetails.name === "msie") {
                sheetRule = " :nth-child(" + sheetIdx + ").e-sheet ";
                cellRule = ":nth-of-type(" + (colIdx + 1) + ").e-rowcell";
            }
            cellProp = "#" + this._id + sheetRule + ".e-content td" + cellRule;
            for (var i = 0, len = rules.length; i < len; i++) {
                if (rules[i].selectorText === cellProp) {
                    stag.sheet.deleteRule(i);
                    break;
                }
            }
        },

        _refreshRowHeight: function (sheetIdx, rowIdx) {
            var pHeight = this.XLEdit.getPropertyValue(rowIdx, 0, "pHeight"), sheet = this.getSheet(sheetIdx);
            if (!this.isUndefined(pHeight)) {
                this.XLEdit._updateDataContainer({ rowIndex: rowIdx, colIndex: 0 }, { dataObj: { cHeight: pHeight, pHeight: sheet.rowsHeightCollection[rowIdx] } });
                sheet.rowsHeightCollection[rowIdx] = pHeight;
                if (this._isRowViewable(sheetIdx, rowIdx))
                    this.getRows(sheetIdx)[1][this._getRowIdx(rowIdx)].style.height = pHeight + "px";
            }
        },

        _batchAddRow: function (sRIndex, eRIndex, sheetIdx, isReverse) {
            var rowData, setting, bindex, curRange, deleted, dindex, j = 0, i = sRIndex, sheet = this.getSheet(sheetIdx),
                settings = this.getDataSettings(sheetIdx);
            if (settings) {
                while (i <= eRIndex) {
                    while (j < settings.length) {
                        setting = settings[j];
                        curRange = setting.range;
                        deleted = setting.batchChanges.deleted;
                        if (i > curRange[0] && i <= (curRange[2] + 1)) {
                            bindex = curRange[0] ? this._getPosDiff(i, curRange[0]) : i;
                            if (!setting.fieldAsColumnHeader && setting.showHeader)
                                bindex = bindex - 1;
                            rowData = this._getRowData(i, curRange[1], curRange[3], setting);
                            setting._jsonData.splice(bindex, 0, rowData);
                            if (setting._isDataManager) {
                                if (isReverse)
                                    deleted.length ? deleted.pop() : deleted.push(rowData);
                                else
                                    setting.batchChanges.added.push(setting._jsonData[bindex]);
                            }
                            curRange[2]++;
                            setting.count++;
                        }
                        else if (i <= curRange[0]) {
                            curRange[2]++;
                            curRange[0]++;
                        }
                        j++;
                    }
                    j = 0;
                    i++;
                }
            }
        },

        _batchDeleteRow: function (sRIndex, eRIndex, sheetIdx, isReverse) {
            var delData, setting, bindex, curRange, added, dindex, j = 0, i = eRIndex, sheet = this.getSheet(sheetIdx),
                settings = this.getDataSettings(sheetIdx);
            if (settings) {
                while (i >= sRIndex) {
                    while (j < settings.length) {
                        setting = settings[j];
                        curRange = setting.range;
                        added = setting.batchChanges.added;
                        if (i >= curRange[0] && i <= (curRange[2])) {
                            bindex = curRange[0] ? this._getPosDiff(i, curRange[0]) : i;
                            if (!setting.fieldAsColumnHeader && setting.showHeader)
                                bindex = bindex - 1;
                            delData = setting._jsonData.splice(bindex, 1)[0];
                            if (setting._isDataManager) {
                                if (!isReverse)
                                    setting.batchChanges.deleted.push(delData);
                                else {
                                    if (added.length) {
                                        dindex = added.indexOf(delData);
                                        if (dindex > -1)
                                            added.splice(dindex, 1);
                                    }
                                    else
                                        added.push(delData);
                                }
                            }
                            curRange[2]--;
                            setting.count--;
                        }
                        else if (i < curRange[0]) {
                            curRange[2]--;
                            curRange[0]--;
                        }
                        j++;
                    }
                    j = 0;
                    i--;
                }
            }
        },

        _updateBatchDetails: function (rowIndex, colIndex, sheetIdx) {
            var bindex, findex, range, actdata, curField, value, batchData, changed, setting, canIterate = true, i = 0, sheet = this.getSheet(sheetIdx),
            settings = this.getDataSettings(sheetIdx);
            if (settings) {
                while (i < settings.length) {
                    setting = settings[i];
                    range = setting.range;
                    if (range && this.inRange(range, rowIndex, colIndex)) {
                        changed = setting.batchChanges.changed;
                        bindex = range[0] ? this._getPosDiff(rowIndex, range[0]) : rowIndex;
                        findex = range[1] ? this._getPosDiff(colIndex, range[1]) : colIndex;
                        if (!setting.fieldAsColumnHeader && setting.showHeader) {
                            if (rowIndex === range[0])
                                canIterate = false;
                            else
                                bindex = bindex - 1;
                        }
                        if (canIterate) {
                            batchData = setting._jsonData[bindex];
                            curField = setting.fields[findex];
                            value = this.getRangeData({ range: [rowIndex, colIndex, rowIndex, colIndex], valueOnly: true, sheetIdx: sheetIdx, skipFormula: true })[0];
                            if (this.isUndefined(value) || this._isEmptyString(value))
                                value = null;
                            if (batchData[curField] !== value) {
                                batchData[curField] = value;
                                if (setting.primaryKey && curField === setting.primaryKey && !this.XLEdit.getPropertyValue(rowIndex, colIndex, "isReadOnly", sheetIdx) && !this.isUndefined(value))
                                    this.XLEdit._updateDataContainer({ rowIndex: rowIndex, colIndex: colIndex }, { dataObj: { isReadOnly: true } });
                                if (setting._isDataManager && $.inArray(batchData, changed) === -1 && $.inArray(batchData, setting.batchChanges.added) === -1)
                                    changed.push(batchData);
                            }
                        }
                        break;
                    }
                    i++;
                }
            }
        },

        _getRowData: function (rowIndex, scolIndex, ecolIndex, setting) {
            var value, data = {}, i = scolIndex, j = 0, sheet = this.getSheet(this.getActiveSheetIndex()), fields = setting.fields;
            while (i <= ecolIndex) {
                value = this.getRangeData({ range: [rowIndex, i, rowIndex, i], valueOnly: true, skipDateTime: true })[0];
                if (this._isEmptyString(value))
                    value = null;
                if (setting.primaryKey && fields[j] === setting.primaryKey && ej.isNullOrUndefined(value))
                    value = 0;
                data[fields[j]] = value;
                i++;
                j++;
            }
            return data;
        },


        saveBatchChanges: function (sheetIdx) {
            var args, promise, batchChanges, returnValue, i = 0, proxy = this, sheet = this.getSheet(sheetIdx), settings = this.getDataSettings(sheetIdx);
            if (settings) {
                while (i < settings.length) {
                    setting = settings[i];
                    if (setting._isDataManager) {
                        batchChanges = setting.batchChanges;
                        args = { sheetIdx: sheetIdx, dataSetting: setting, batchChanges: batchChanges };
                        returnValue = this._trigger("beforeBatchSave", args);
                        if (!returnValue && (batchChanges.changed.length || batchChanges.added.length || batchChanges.deleted.length)) {
                            promise = setting._dataManager.saveChanges(batchChanges, setting.primaryKey, setting.query._fromTable);
                            if (!setting._isOffline) {
                                this.showWaitingPopUp();
                                promise.done(function (e) {
                                    sheet._resCnt++;
                                    if (sheet._reqCnt === sheet._resCnt)
                                        proxy.hideWaitingPopUp();
                                });
                                promise.fail(function (e) {
                                    sheet._resCnt++;
                                    if (sheet._reqCnt === sheet._resCnt)
                                        proxy.hideWaitingPopUp();
                                });
                            }
                            sheet._reqCnt++;
                            setting.batchChanges = { added: [], changed: [], deleted: [] };
                        }
                    }
                    i++;
                }
            }
        },

        setReadOnly: function (range) {
            this.updateUniqueData({ isReadOnly: true }, range);
        },

        removeReadOnly: function (range) {
            this.clearRangeData(range, ["isReadOnly"]);
        },

        _updateCustomFormulas: function (formulasArr, action) {
            var calcEngine = this._calcEngine, isComplete, key;
            for (key in formulasArr) {
                if (action === "add" && this.isUndefined(this.getCalcEngine().getLibraryFunctions().getItem(formulasArr[key].formulaName)) && !this.XLEdit._isNamedRange("=" + formulasArr[key].formulaName)) {
                    isComplete = calcEngine["addCustomFunction"](formulasArr[key].formulaName, formulasArr[key].functionName);
                    this._formulaCollection.push({ text: "=" + formulasArr[key].formulaName, display: formulasArr[key].formulaName });
                }
                else if (action === "delete" && calcEngine.getCustomLibraryFunctions().contains(formulasArr[key].formulaName))
                    isComplete = calcEngine["removeFunction"](formulasArr[key].formulaName, formulasArr[key].functionName);
                else
                    this._showAlertDlg("Alert", "CorrectFormula", "FormulaAlert", 372); // To pass correct argument
            }
            return isComplete;
        },

        addCustomFormula: function (formulaName, functionName) {
            if (this.model.isReadOnly)
                return;
            var isComplete = this._updateCustomFormulas([{ formulaName: formulaName, functionName: functionName }], "add");
            if (isComplete) {
                this.model.customFormulas.push({ formulaName: formulaName, functionName: functionName });
                this.XLEdit._refreshAutoComplete();
            }
        },

        removeCustomFormula: function (formulaName, functionName) {
            if (this.model.isReadOnly)
                return;
            var key, isComplete = this._updateCustomFormulas([{ formulaName: formulaName.toUpperCase(), functionName: functionName }], "delete"), formulaColl;
            if (isComplete) {
                formulaColl = this.model.customFormulas;
                for (key in formulaColl)
                    if (formulaColl[key].formulaName === formulaName)
                        formulaColl.splice(1, parseInt(key));
                this._updateFormulaCollection();
                this.XLEdit._refreshCalcEngine(null, null, false, null, null);
                this.XLEdit._refreshAutoComplete();
            }
        },

        getValueFromFormulaArg: function (args) {
            var i = 1, key, sheetIdx = this._getSheetIndex(), calcEngine = this._calcEngine, splitArgs, tVal, values = {}, totalArgs = [], n, len;
            splitArgs = args.split(calcEngine.getParseArgumentSeparator());
            for (n = 0, len = splitArgs.length; n < len; n++)
                totalArgs = totalArgs.concat((splitArgs[n].indexOf(":") > -1) ? calcEngine.getCellsFromArgs(splitArgs[n]) : [splitArgs[n]]);
            for (key in totalArgs) {
                tVal = calcEngine.getValueFromArg(totalArgs[key]);
                values["arg" + i] = this.XLEdit._parseValue(tVal).value;
                if (totalArgs.indexOf(tVal) > -1 && tVal[0] === '"' && tVal[tVal.length - 1] === '"')
                    values["arg" + i] = tVal.substring(1, tVal.length - 1);
                i++;
            }
            return values;
        },

        getCalcEngine: function () {
            return this._calcEngine;
        },
		
		_updateFormatColl: function(sheetIdx, rowIdx, colIdx, cellHt) {
			var sheet = this.getSheet(sheetIdx), formatColl = sheet._formatColl;
			if(cellHt > this.model.rowHeight) {
				if(this.isUndefined(formatColl[rowIdx]))
					formatColl[rowIdx] = {};
				formatColl[rowIdx][colIdx] = cellHt;
			}
			else {
				if(rowIdx in formatColl && colIdx in formatColl[rowIdx]) 
					delete formatColl[rowIdx][colIdx];
				if(formatColl[rowIdx] && this.getObjectLength(formatColl[rowIdx]) < 1)
					delete formatColl[rowIdx];
			}
		},

		_getFormattedHeight: function (sheetIdx, rowIdx) {
		    var sheet = this.getSheet(sheetIdx), cellHt;
		    cellHt = ej.max(this._getObjectValues(sheet._formatColl[rowIdx]));
		    cellHt = cellHt ? cellHt : this.model.rowHeight;
		    return cellHt;
		}
    });


    ej.Spreadsheet.Locale = ej.Spreadsheet.Locale || {};

    ej.Spreadsheet.Locale['default'] = ej.Spreadsheet.Locale["en-US"] = {
        Cut: "Cut",
        Copy: "Copy",
        FormatPainter: "Format Painter",
        Paste: "Paste",
        PasteValues: "Paste Values Only",
        PasteSpecial: "Paste",
        Filter: "Filter",
        FilterContent: "Turn on filtering for the selected cells.",
        FilterSelected: "Filter by Selected Cell's value",
        Sort: "Sort",
        Clear: "Clear",
        ClearContent: "Delete everything in the cell, or remove just the formatting, contents, comments or hyperlinks.",
        ClearFilter: "Clear Filter",
        ClearFilterContent: "Clear the filter and sort state for the current range of data.",
        SortAtoZ: "Sort A to Z",
        SortAtoZContent: "Lowest to Highest.",
        SortZtoA: "Sort Z to A",
        SortZtoAContent: "Highest to Lowest.",
        SortSmallesttoLargest: "Sort Smallest to Largest",
        SortLargesttoSmallest: "Sort Largest to Smallest",
        SortOldesttoNewest: "Sort Oldest to Newest",
        SortNewesttoOldest: "Sort Newest to Oldest",
        Insert: "Insert",
        InsertTitle: "Insert Cells",
        InsertContent: "Add new cells, rows, or columns to your workbook.",
		MultipleInsertContent:"FYI: To insert multiple rows or columns at a time, select multiple rows or columns in the sheet, and click Insert.",
        InsertSBContent: "Add cells, rows, columns, or sheets to your workbook.",
        Delete: "Delete",
        DeleteTitle: "Delete Cells",
        DeleteContent: "Delete cells, rows, columns, or sheets from your workbook. ",
		MultipleDeleteContent:"FYI: To delete multiple rows or columns at a time, select multiple rows or columns in the sheet, and click Delete.",
        FindSelectTitle: "Find & Select",
        FindSelectContent: "Click to see options for finding text in your document.",
        CalculationOptions: "Calculation Options",
        CalcOptTitle: "Calculation Options",
        CalcOptContent: "Choose to calculate formulas automatically or manually.",
		CalcOptRecalcContent: "If you make a change that affects a value, Spreadsheet will automatically recalculate it.",
        CalculateSheet: "Calculate Sheet",
        CalculateNow: "Calculate Now",
        CalculateNowContent: "Calculate the entire workbook now.",
		CalculateNowTurnOffContent: "You only need to use this if automatic calculation is turned off.",
        CalculateSheetContent: "Calculate the active sheet now.",
		CalculateSheetTurnOffContent: "You only need to use this if automatic calculation is turned off.",
        Title: "Spreadsheet",
        ColorPicker: "Color Picker",
        Ok: "OK",
        Cancel: "Cancel",
        Alert: "We couldn't do this for the selected range of cells. Select a single cell within a range of data and then try again.",
        HeaderAlert: "The command could not be completed as you are attempting to filter with the filter header. Select a single cell in the filter range and try the command again.",
        FlashFillAlert: "All the data next to your selection was checked and there was no pattern for filling in values.",
        Formatcells: "Format Cells",
        FontFamily: "Font",
        FFContent: "Pick a new font for your text.",
        FontSize: "Font Size",
        FSContent: "Change the size of your text.",
        IncreaseFontSize: "Increase Font Size",
        IFSContent: "Make your text a bit bigger.",
        DecreaseFontSize: "Decrease Font Size",
        DFSContent: "Make your text a bit smaller.",
        Bold: "Bold",
        Italic: "Italic",
        Underline: "Underline",
        Linethrough: "Linethrough",
        FillColor: "Fill Color",
        FontColor: "Font Color",
        TopAlign: "Top Align",
        TopAlignContent: "Align text to the top.",
        MiddleAlign: "Middle Align",
        MiddleAlignContent: "Align text so that it is centered between the top and bottom of the cell.",
        BottomAlign: "Bottom Align",
        BottomAlignContent: "Align text to the bottom.",
        WrapText: "Wrap Text",
        WrapTextContent: "Wrap extra-long text into multiple lines so you can see all of it.",
        AlignLeft: "Align Left",
        AlignLeftContent: "Align your content to the left.",
        AlignCenter: "Center",
        AlignCenterContent: "Center your content.",
        AlignRight: "Align Right",
        AlignRightContent: "Align your content to the right.",
        IncreaseIndent: "Increase Indent",
        IncreaseIndentContent: "Move your content farther away from the cell border.",
        DecreaseIndent: "Decrease Indent",
        DecreaseIndentContent: "Move your content closer to the cell border.",
        Undo: "Undo",
        Redo: "Redo",
        NumberFormat: "Number Format",
        NumberFormatContent: "Choose the format for your cells, such as percentage, currency, date or time.",
        AccountingStyle: "Accounting Style",
        AccountingStyleContent: "Format as dollar accounting number format.",
        PercentageStyle: "Percent Style",
        PercentageStyleContent: "Format as a percent.",
        CommaStyle: "Comma Style",
        CommaStyleContent: "Format with a thousands separator.",
        IncreaseDecimal: "Increase Decimal",
        IncreaseDecimalContent: "Show more decimal places for a more precise value.",
        DecreaseDecimal: "Decrease Decimal",
        DecreaseDecimalContent: "Show fewer decimal places.",
        AutoSum: "AutoSum",
        AutoSumTitle: "Sum",
        AutoSumContent: "Automatically add a quick calculation to your worksheet, such as sum or average.",
        Fill: "Fill",
        ExportXL: "Excel",
        ExportCsv: "CSV",
        ExportPdf: "PDF",
        BackgroundColor: "Fill Color",
        BGContent: "Color the background of the cells to make them stand out.",
        ColorContent: "Change the color of your text.",
        Border: "Border",
        BorderContent: "Apply borders to the currently selected cells.",
        BottomBorder: "Bottom Border",
        TopBorder: "Top Border",
        LeftBorder: "Left Border",
        RightBorder: "Right Border",
        OutsideBorder: "Outside Borders",
        NoBorder: "No Border",
        AllBorder: "All Borders",
        ThickBoxBorder: "Thick Box Border",
        ThickBottomBorder: "Thick Bottom Border",
        BottomDoubleBorder: "Bottom Double Border",
        TopandBottomDoubleBorder: "Top and Bottom Double Border",
        TopandThickBottomBorder: "Top and Thick Bottom Border",
        DrawBorderGrid: "Draw Border Grid",
        DrawBorder: "Draw Border",
        TopandBottomBorder: "Top and Bottom Border",
        BorderColor: "Line Color",
        BorderStyle: "Line Style",
        Number: "Number is used for general display of numbers.  Currency and Accounting offer specialized formatting for monetary value.",
        General: "General format cells have no specific number format.",
        Currency: "Currency formats are used for general monetary values.  Use Accounting formats to align decimal points in a column.",
        Accounting: "Accounting formats line up the currency symbols and decimal points in a column.",
        Text: "Text format cells are treated as text even when a number is in the cell. The cell is displayed exactly as entered.",
        Percentage: "Percentage formats multiply the cell value by 100 and displays the result with a percent symbol.",
        CustomMessage: "Type number format code, using one of existing codes as a starting point.",
        Fraction: "Fraction is used to indicate a part of a whole number or a ratio between two numbers.",
        Scientific: "Scientific is used to represent a decimal number between 1 and 10 multiplied by ten, so the large numbers using less digits.",
        Type: "Type:",
        CustomFormatAlert: "Enter a valid format",
        Date: "Date formats display date and time serial numbers as date values.",
        Time: "Time formats display date and time serial numbers as date values.",
        File: "FILE",
        New: "New",
        Open: "Open",
        SaveAs: "Save As",
        Print: "Print",
        PrintContent: "Print the current sheet.",
        PrintSheet: "Print Sheet",
        PrintSelected: "Print Selected",
        PrintSelectedContent: "Select an area on the sheet you would like to print.",
        HighlightVal: "Format Invalid Data",
        ClearVal: "Clear Validation",
        Validation: "Validation",
        DataValidation: "Data Validation",
        DVContent: "Pick from a list of rules to limit the type of data that can be entered in a cell.",
        PageSize: "Page Size",
        PageSizeContent: "Choose a page size for your document.",
        FormatCells: "FormatCells",
        ConditionalFormat: "Conditional Formatting",
        CFContent: "Easily spot trends and patterns in your data using colors to visually highlight important values.",
        And: "and",
        With: "with",
        GTTitle: "Greater Than",
        GTContent: "Format cells that are GREATER THAN:",
        LTTitle: "Less Than",
        LTContent: "Format cells that are LESS THAN:",
        BWTitle: "Between",
        BWContent: "Format cells that are BETWEEN:",
        EQTitle: "Equal To",
        EQContent: "Format cells that are EQUAL TO:",
        DateTitle: "A Date Occurring",
        DateContent: "Format cells that contain a DATE:",
        ContainsTitle: "Text That Contains",
        ContainsContent: "Format cells that contain the text:",
        GreaterThan: "Greater Than",
        LessThan: "Less Than",
        Between: "Between",
        EqualTo: "Equal To",
        TextthatContains: "Text that Contains",
        DateOccurring: "A Date Occurring",
        ClearRules: "Clear Rules",
        ClearRulesfromSelected: "Clear Rules from Selected Cells",
        ClearRulesfromEntireSheets: "Clear Rules from Entire Sheet",
        CellStyles: "Cell Styles",
        CellStylesContent: "A colorful style is a great way to make important data stand out on the sheet.",
        CellStyleHeaderText: "Good, Bad and Neutral/Titles and Headings/Themed Cell Styles",
        Custom: "Type the number format code, using one of the existing codes as starting point.",
        CellStyleGBN: "Normal/Bad/Good/Neutral",
        CellStyleTH: "Heading 4/Title",
        Accent: "Accent",
        Style: "Style",
        FormatAsTable: "Format As Table",
        FormatasTable: "Format as Table",
        FATContent: "Quickly convert a range of cells to a table with its own style.",
        FATHeaderText: "Light/Medium/Dark",
        FATNameDlgText: "Table Name:/My table has headers",
        InvalidReference: "The range you have specified is invalid",
        ResizeAlert: "The specified range is invalid. The top of the table must remain in the same row, and the resulting table must overlap the original table. Specify a valid range.",
        RangeNotCreated: "Increasing the row beyond the maximum sheet rowcount is restricted in Format as Table.",
        ResizeRestrictAlert: "Increase or decrease of column count and decrease of row count is restricted in Format as Table.",
        FATResizeTableText: "Enter new data range for your table:",
        FATReizeTableNote: "Note: The headers must remain in the same row and the resulting table range must overlap the original table range.",
        FormatAsTableAlert: "Cannot create a table with a single row. A table must have at least two rows, one for the table header, and one for data",
        FormatAsTableTitle: "Light 1/Light 2/Light 3/Light 5/Light 8/Light 9/Light 10/Light 12/Light 15/Light 16/Light 17/Light 19/Medium 8/Medium 9/Medium 10/Medium 12/Medium 22/Medium 23/Medium 24/Medium 26/Dark 1/Dark 2/Dark 3/Dark 5",
        NewTableStyle: "New Table Style",
        ResizeTable: "Resize Table",
        ResizeTableContent: "Resize this table by adding or removing rows and columns.",
        ConvertToRange: "Convert to Range",
        ConvertToRangeContent: "Convert this table into a normal range of cells.",
        ConverToRangeAlert: "Do you want to convert the table to a normal range?",
        TableID: "Table ID:",
        Table: "Table",
        TableContent: "Create a table to organize and analyze related data.",
        TableStyleOptions: "First Column/Last Column/Total Row/Filter Button",
        Format: "Format",
        NameManager: "Name Manager",
        NameManagerContent: "Create, edit, delete and find all the names used in the workbook.",
        NameManagerFormulaContent: "Names can be used in formulas as substitutes for cell references.",
        DefinedNames: "Defined Names",
        DefineName: "Define Name",
        DefineNameContent: "Define and apply names.",
        UseInFormula: "Use In Formula",
        UseInFormulaContent: "Choose a name used in this workbook and insert it into the current formula.",
        RefersTo: "Refers To",
        Name: "Name",
        Scope: "Scope",
        NMNameAlert: "The name that you entered is not valid./Reason for this can include:/The name does not begin with a letter or an underscore/The name contains a space or other invalid characters/The name conflicts with a spreadsheet built-in name or the name of another object in the workbook", // not used completely
        NMUniqueNameAlert: "The name entered already exists. Enter a unique name.",
        NMRangeAlert: "Enter a valid range",
        FORMULAS: "FORMULAS",
        Value: "Values",
        DataValue: "Values:",
        Formula: "Formulas",
        MissingParenthesisAlert: "Your formula is missing a parenthesis--) or (. Check the formula, and then add the parenthesis in the appropriate place.",
        UnsupportedFile: "Unsupported File",
        IncorrectPassword: "Unable to open the file or worksheet with the given password",
        InvalidUrl: "Please specify proper URL",
        Up: "Up",
        Down: "Down",
        Sheet: "Sheet",
        Workbook: "Workbook",
        Rows: "By Rows",
        Columns: "By Columns",
        FindReplace: "Find Replace",
        FindnReplace: "Find and Replace",
        Find: "Find",
        Replace: "Replace",
        FindLabel: "Find what:",
        ReplaceLabel: "Replace with:",
        ReplaceAll: "Replace All",
        Close: "Close",
        FindNext: "Find Next",
        FindPrev: "Find Prev",
        Automatic: "Automatic",
        Manual: "Manual",
        Settings: "Settings",
        MatchCase: "Match case",
        MatchAll: "Match entire cell contents",
        Within: "Within:",
        Search: "Search:",
        Lookin: "Look in:",
        ShiftRight: "Shift cells right",
        ShiftBottom: "Shift cells down",
        EntireRow: "Entire row",
        EntireColumn: "Entire column",
        ShiftUp: "Shift cells up",
        ShiftLeft: "Shift cells left",
        Direction: "Direction:",
        GoTo: "Go To",
        GoToName: "Go to:",
        Reference: "Reference:",
        Special: "Special",
        Select: "Select",
        Comments: "Comments",
        Formulas: "Formulas",
        Constants: "Constants",
        RowDiff: "Row differences",
        ColDiff: "Column differences",
        LastCell: "Last cell",
        CFormat: "Conditional formats",
        Blanks: "Blanks",
        GotoError: "Error",
        GotoLogicals: "Logicals",
        GotoNumbers: "Numbers",
        GotoText: "Text",
        FindSelect: "Find & Select",
        Comment: "Comment",
        NewComment: "New",
        InsertComment: "Insert Comment",
        EditComment: "Edit",
        DeleteComment: "Delete Comment",
        DeleteCommentContent: "Delete the selected comment.",
        HideComment: "Hide Comment",
        Next: "Next",
        NextContent: "Jump to the next comment.",
        Previous: "Previous",
        PreviousContent: "Jump to the previous comment.",
        ShowHide: "Show/Hide Comment",
        ShowHideContent: "Show or hide the comment on the active cell.",
        ShowAll: "Show All Comments",
        ShowAllContent: "Display all comments in the sheet.",
        UserName: "User Name",
        Hide: "Hide",
        Unhide: "Unhide",
        Add: "Add",
        DropAlert: "Do you want to replace the existing data?",
        PutCellColor: "Put Selected Cell Color To The Top",
        PutFontColor: "Put Selected Font Color To The Top",
        WebPage: "Web Page",
        WorkSheet: "Worksheet Reference",
        SheetReference: "Sheet Reference",
        InsertHyperLink: "Insert Hyperlink",
        HyperLink: "Hyperlink",
        EditLink: "Editlink",
        OpenLink: "Openlink",
        HyperlinkText: "Text:",
        RemoveLink: "Removelink",
        WebAddress: "Web Address:",
        CellAddress: "Cell Reference:",
        SheetIndex: "Select a place in this document",
        ClearAll: "Clear All",
        ClearFormats: "Clear Formats",
        ClearContents: "Clear Contents",
        ClearComments: "Clear Comments",
        ClearHyperLinks: "Clear Hyperlinks",
        SortFilter: "Sort & Filter",
        SortFilterContent: "Organize your data so it's easier to analyze.",
        NumberStart: "Minimum:",
        NumberEnd: "Maximum:",
        DecimalStart: "Minimum:",
        DecimalEnd: "Maximum:",
        DateStart: "Start Date:",
        DateEnd: "End Date:",
        ListStart: "Source:",
        FreeText: "Show error after invalid data is entered",
        ListEnd: "Cell Reference:",
        TimeStart: "Start Time:",
        TimeEnd: "End Time:",
        TextLengthStart: "Minimum:",
        TextLengthEnd: "Maximum:",
        CommentFindEndAlert: "Spreadsheet reached the end of the workbook. Do you want to continue reviewing from the beginning of the workbook?",
        InsertSheet: "Insert",
        DeleteSheet: "Delete",
        RenameSheet: "Rename",
        MoveorCopy: "Move or Copy",
        HideSheet: "Hide",
        UnhideSheet: "Unhide",
        SheetRenameAlert: "That name is already taken. Try a different one.",
        SheetRenameEmptyAlert: "You typed an invalid name for a sheet. Make sure that:",
		SheetRenameEmptyCharExceedAlert: "The name that you type does not exceed 31 characters.",
		SheetRenameEmptySplCharAlert: "The name does not contain any of the following characters: ",
		SheetRenameEmptyBlankAlert: "You did not leave the name blank.",
        SheetDeleteAlert: "You can't undo deleting sheets, and you might be removing some data. If you don't need it, click OK to delete.",
        SheetDeleteErrorAlert: "A workbook must contain at least one visible worksheet. To hide, delete, or move the selected sheet, you must first insert a new sheet or unhide a sheet that is already hidden.",
        CtrlKeyErrorAlert: "That command cannot be used on  multiple selections.",
        ClipboardAccessError: "Your browser can't access the clipboard, so use these shortcuts:",
        MoveToEnd: "Move To End",
        Beforesheet: "Before sheet:",
        CreateaCopy: "Create a copy",
        AutoFillOptions: "Copy Cells/Fill Series/Fill Formatting Only/Fill Without Formatting/Flash Fill",
        NumberValidationMsg: "Enter only digits",
        DateValidationMsg: "Enter only date",
        Required: "Required",
        TimeValidationMsg: "The time you entered for the Time is invalid.",
        CellAddrsValidationMsg: "Reference is not valid.",
        PivotTable: "Pivot Table",
        PivotTableContent: "Easily arrange and summarize complex data in a PivotTable.",
        NumberTab: "Number",
        AlignmentTab: "Alignment",
        FontTab: "Font",
        FillTab: "Fill",
        TextAlignment: "Text alignment",
        Horizontal: "Horizontal:",
        Vertical: "Vertical:",
        Indent: "Indent",
        TextControl: "Text Control",
        FontGroup: "Font:",
        FontStyle: "Font style",
        Size: "Size:",
        PSize: "Page size",
        Effects: "Effects",
        Color: "Color",
        StrikeThrough: "Strikethrough",
        Overline: "Overline",
        NormalFont: "Normal font",
        Preview: "Preview",
        Line: "Line",
        Presets: "Presets",
        None: "None",
        Outline: "Outline",
        AllSide: "All sides",
        InsCells: "Insert Cells",
        InsRows: "Insert Sheet Rows",
        InsCols: "Insert Sheet Columns",
        InsSheet: "Insert Sheet",
        DelCells: "Delete Cells",
        DelRows: "Delete Sheet Rows",
        DelCols: "Delete Sheet Columns",
        DelSheet: "Delete Sheet",
        HyperLinkAlert: "The address of this site is not valid.Check the address and try again.",
        ReplaceData: "All done. We made / replacements.",
        NotFound: "We couldn't find what you were looking for. Select settings tab for more ways to search",
        Data: "Data:",
        Allow: "Allow:",
        IgnoreBlank: "Ignore blank",
        NotFind: "Unable to find the match to replace",
        FreezeTopRow: "Freeze Top Row",
        FreezeFirstColumn: "Freeze First Column",
        UnFreezePanes: "Unfreeze Panes",
        DestroyAlert: "Are you sure you want to destroy the current workbook without saving and create a new workbook?",
        ImageValAlert: "Upload image files only",
        Pictures: "Pictures",
        PicturesTitle: "From File",
        PicturesContent: "Insert pictures from computer or from other computers that you are connected to.",
        ImportAlert: "Are you sure you want to destroy the current workbook without saving and open a new workbook?",
        UnmergeCells: "Unmerge Cells",
        MergeCells: "Merge Cells",
        MergeAcross: "Merge Across",
        MergeAndCenter: "Merge & Center",
        MergeAndCenterContent: "Combine and center the contents of the selected cells in a new larger cell.",
        MergeCellsAlert: "Merging Cells keeps only upper left cell value and discards the other values.",
        MergeInsertAlert: "This operation will causes some merged cells to unmerge. Do you wish to continue ?",
        Axes: "Axes",
        PHAxis: "Primary Horizontal",
        PVAxis: "Primary Vertical",
        AxisTitle: "Axis Title",
        CTNone: "None",
        CTCenter: "Center",
        CTFar: "Far",
        CTNear: "Near",
        DataLabels: "Data Labels",
        DLNone: "None",
        DLCenter: "Center",
        DLIEnd: "Inside End",
        DLIBase: "Inside Base",
        DLOEnd: "Outside End",
        ErrorBar: "Error Bars",
        Gridline: "Gridlines",
        PMajorH: "Primary Major Horizontal",
        PMajorV: "Primary Major Vertical",
        PMinorH: "Primary Minor Horizontal",
        PMinorV: "Primary Minor Vertical",
        Legend: "Legends",
        LNone: "None",
        LLeft: "Left",
        LRight: "Right",
        LBottom: "Bottom",
        LTop: "Top",
        ChartTitleDlgText: "Enter Title",
        ChartTitle: "Title",
        InvalidTitle: "You typed an invalid name for the Title.",
        CorrectFormat: "Select the correct Format File",
        ResetPicture: "Reset Picture",
        ResetPictureContent: "Discard all of the formatting changes made to this picture.",
        PictureBorder: "Picture Border",
        PictureBorderContent: "Pick the color, width, and line style for the outline of your shape.",
        ResetSize: "Reset Picture & Size",
        Height: "Height",
        Width: "Width",
        ThemeColor: "Theme Colors",
        NoOutline: "No Outline",
        Weight: "Weight",
        Dashes: "Dashes",
        ColumnChart: "Column",
        ColumnChartTitle: "Insert Column Chart",
        ColumnChartContent: "Use this chart type to visually compare values across a few categories.",
        BarChart: "Bar",
        BarChartTitle: "Insert Bar Chart",
        BarChartContent: "Use this chart type to visually compare values across a few categories when the chart shows duration or the category text is long.",
        StockChart: "Radar",
        StockChartTitle: "Insert Radar Chart",
        StockChartContent: "Use this chart type to show values relative to a center point.",
        LineChart: "Line",
        LineChartTitle: "Insert Line Chart",
        LineChartContent: "Use this chart type to show trends over time (years, months, and days) or categories.",
        AreaChart: "Area",
        AreaChartTitle: "Insert Area Chart",
        AreaChartContent: "Use this chart type to show trends over time (years, months, and days) or categories. Use it to highlight the magnitude of change over time.",
        ComboChart: "Combo",
        PieChart: "Pie",
        PieChartTitle: "Insert Pie/Doughnut Chart",
        PieChartContent: "Use this chart type to show proportions of a whole. Use it when the total of your numbers is 100%.",
        ScatterChart: "Scatter",
        ScatterChartTitle: "Insert Scatter (X, Y) Chart",
        ScatterChartContent: "Use this chart type to show the relationship between sets of values.",
        ClusteredColumn: "Clustered&nbsp;Column",
        StackedColumn: "Stacked&nbsp;Column",
        ClusteredBar: "Clustered&nbsp;Bar",
        StackedBar: "Stacked&nbsp;Bar",
        Radar: "Radar",
        RadarMarkers: "Radar&nbsp;with&nbsp;Markers",
        LineMarkers: "Line&nbsp;with&nbsp;Markers",
        Area: "Area",
        StackedArea: "Stacked&nbsp;Area",
        Pie: "Pie",
        Doughnut: "Doughnut",
        Scatter: "Scatter",
        ChartRange: "Chart Range",
        XAxisRange: "Enter X-axis range:",
        YAxisRange: "Enter Y-axis range:",
        LegendRange: "Enter legend range:",
        YAxisMissing: "Enter Y-axis range to create chart",
        InvalidYAxis: "Y-axis range must be within the selected range",
        InvalidXAxis: "X-axis range must be within the selected range",
        InvalidLegend: "Legend range must be within the selected range",
        InvalidXAxisColumns: "X-axis range should be within a single column",
        FreezePanes: "Freeze Panes",
        FreezePanesContent: "Freeze a portion of the sheet to keep it visible while you scroll through the rest of the sheet.",
        PasteContent: "Add content on the Clipboard to your document.",
        PasteSplitContent: "Pick a paste option, such as keeping formatting or pasting only content.",
        CutContent: "Remove the selection and put it on the Clipboard so you can paste it somewhere else.",
        CopyContent: "Put a copy of the selection on the Clipboard so you can paste it somewhere else.",
        FPTitle: "Format Painter",
        FPContent: "Like the look of a particular selection? You can apply that look to other content in the document.",
        BoldContent: "Make your text bold.",
        ItalicContent: "Italicize your text.",
        ULineContent: "Underline your text.",
        LineTrContent: "Cross something out by drawing a strike through it.",
        UndoContent: "Undo your last action.",
        RedoContent: "Redo your last action.",
        HyperLinkTitle: "Add a Hyperlink",
        HyperLinkContent: "Create a link in your document for quick access to webpages and files. ",
        HyperLinkPlaceContent: "Hyperlinks can also take you to places in your document.",
        NewCommentTitle: "Insert a Comment",
        NewCommentContent: "Add a note about this part of the document.",
        RefreshTitle: "Refresh",
        RefreshContent: "Get the latest data from the source connected to the active cell",
        FieldListTitle: "Field List",
        FieldListContent: "Show or hide the Field List." ,
		FieldListRemoveContent: "The field list allows you to add and remove fields from your PivotTable report",
        AddChartElement: "Add Chart Element",
        AddChartElementContent: "Add elements to the created chart.",
        SwitchRowColumn: "Switch Row/ Column",
        SwitchRowColumnContent: "Swap the data over the axis.",
        MergeAlert: "We can't do that to a merged cell.",
        UnhideDlgText: "Unhide Sheet:",
        ChartThemes: "Chart Themes",
        ChartThemesContent: "Pick a new theme for your chart.",
        ChangePicture: "Change Picture",
        ChangePictureContent: "Change to a different picture, preserving the formatting and size of the current picture.",
        ChangeChartType: "Change Chart Type",
        SelectData: "Select Data",
        SelectDataContent: "Change the data range included in the chart.",
        Sum: "Sum",
        Average: "Average",
        CountNumber: "Count Numbers",
        Max: "Max",
        Min: "Min",
        ChartTypeContent: "Change to a different chart type.",
        AllCharts: "All Charts",
        defaultfont: "Default",
        LGeneral: "General",
        LCurrency: "Currency",
        LAccounting: "Accounting",
        LDate: "Date",
        LTime: "Time",
        LPercentage: "Percentage",
        LFraction: "Fraction",
        LScientific: "Scientific",
        LText: "Text",
        LCustom: "Custom",
        LShortdate: "Short Date",
        LLongdate: "Long Date",
        FormatSample: "Sample",
        Category: "Category:",
        Top: "Top",
        Center: "Center",
        Bottom: "Bottom",
        Left: "Left (Indent)",
        Right: "Right",
        Justify: "Justify",
        GeneralTxt: "General format cells have no specific number format.",
        NegativeNumbersTxt: "Negative Numbers",
        ThousandSeparatorTxt: "Use 1000 Separator",
        DecimalPlacesTxt: "Decimal Places:",
        TextTxt: "Text format cells are treated as text even when a number is in the cell. The cell is displayed exactly as entered.",
        BoldItalic: "Bold Italic",
        Regular: "Regular",
        HyperLinkHide: "<<Selection in Document>>",
        InvalidSheetIndex: "Specify proper SheetIndex",
        HugeDataAlert: "File too large to open.",
        ImportExportUrl: "Give import/export URL and try again.",
        BetweenAlert: "The Maximum must be greater or equal to the Minimum.",
        BorderStyles: "Solid/Dashed/Dotted/Double",
        FPaneAlert: "Freeze Pane is not applied for the First Cell",
        ReplaceNotFound: "Spreadsheet cannot find a match.",
        BlankWorkbook: "Blank workbook",
        SaveAsExcel: "Save As Excel",
        SaveAsCsv: "Save As CSV",
        SaveAsPdf: "Save As PDF",
        Design: "DESIGN",
        NewName: "New Name",
        FormulaBar: "Formula Bar",
        NameBox: "Name Box",
        NumberValMsg: "Decimal values cannot be used for number conditions.",
        NumberAlertMsg: "Enter only digits.",
        ListAlert: "Cell range is incorrect, Please enter correct cell range.",
        ListValAlert: "The list source must be a delimited list, or a reference to single row or column.",
        ListAlertMsg: "The value you entered is not valid",
        AutoFillTitle: "AutoFillOptions",
        NewSheet: "New Sheet",
        FullSheetCopyPasteAlert: "We can't paste because the Copy area and paste area aren't the same size.",
        Heading: "Headings",
        Gridlines: "Gridlines",
        Firstsheet: "Scroll to the first sheet",
        Lastsheet: "Scroll to the last sheet",
        Nextsheet: "Scroll to the next sheet",
        Prevsheet: "Scroll to the previous sheet",
        ProtectWorkbook: "Protect Workbook",
        UnProtectWorkbook: "Unprotect Workbook",
        ProtectWBContent: "Keep others from making structural changes to your workbook",
        Password: "Password",
        ConfirmPassword: "Reenter password to proceed:",
        PasswordAlert1: "Confirmation password is not identical.",
        PasswordAlert2: "Please enter a password.",
        PasswordAlert3: "The password you supplied is not correct. Verify that the CAPS LOCK key is off and be sure to use the correct capitalization.",
        Protect: "is protected.",
        Lock: "LockCell",
        Unlock: "UnlockCell",
        Protectsheet: "Protect Sheet",
        ProtectSheetToolTip: "Prevent unwanted changes from others by limiting their ability to edit",
        Unprotect: "Unprotect Sheet",
        LockAlert: "The cell you are trying to change is on protected sheet. To make changes, click Unprotect Sheet in the Review tab.",
        InsertDeleteAlert: "This operation is not allowed. The operation is attempting to shift cells in a table/Filter range on your worksheet.",
        CreateRule: "New Rule",
        NewRule: "New Formatting Rule",
        NewRuleLabelContent: "Format values where this formula is true:",
        ReadOnly: "The range you are trying to change contains readonly cells.",
        CreatePivotTable: "Create PivotTable",
        Range: "Range:",
        ChoosePivotTable: "Choose where you want the PivotTable to be placed",
        NewWorksheet: "New Worksheet",
        ExistingWorksheet: "Existing Worksheet",
        Location: "Location:",
        Refresh: "Refresh",
        PivotRowsAlert: "This command requires at least two rows of source data. You cannot use the command on a selection in only one row.",
        PivotLabelsAlert: "The PivotTable field name is not valid, To create a PivotTable report, you must use data that is organized as a list with labeled columns. If you are changing the name of a PivotTable field, you must type a new name for the field.",
        FieldList: "Field List",
        MergeSortAlert: "To do this, all the merged cells need to be the same size.",
        FormulaSortAlert: "The sort range with formula cannot be sorted.",
        MergePreventInsertDelete: "This operation is not allowed. The operation is attempting to shift a merge cells on your worksheet.",
        FormulaRuleMsg: "Please enter correct format.",
        MovePivotTable: "Move PivotTable",
        MovePivotTableContent: "Move the PivotTable to another location in the workbook.",
        ClearAllContent: "Remove fields and filters.",
        ChangeDataSource: "Modify",
        ChangeDataSourceContent: "Change the source data for this PivotTable",
        ChangePivotTableDataSource: "Change PivotTable Data Source",
        TotalRowAlert: "This operation is not allowed. The operation is attempting to shift cells in a table on your worksheet. Click OK to proceed with entire row.",
        CellTypeAlert: "This operation is not allowed in cell type applied range.",
        PivotOverlapAlert: "A PivotTable report cannot overlap another PivotTable report",
        NoCellFound: "No cells were found",
        MoreValidationAlert: "The selection contains more than one type of validation. Erase current settings and continue ?",
        CorrectArgument: "Please enter the correct argument",
        CorrectFormula: "Please enter the correct formula",
        CorrectCellAddress: "Please enter the correct cell address",
        ChartType: "Chart Type",
        NumberValidationAlert: "The Maximum must be greater than or equal to Minimum",
        DateValidationAlert: "The End Date must be greater than or equal to Start Date",
        TimeValidationAlert: "The End Time must be greater than or equal to Start Time",
        NewRuleAlert: "There's a problem with this formula",
        DragAlert: "The command could not be completed as you are attempting to move cells within the filter range. Select a range out of the filter range and try the command again.",
        OR: "or",
        HOME: "HOME",
        INSERT: "INSERT",
        DATATAB: "DATA",
        PAGELAYOUT: "PAGE LAYOUT",
        REVIEW: "REVIEW",
        OTHERS: "OTHERS",
        FORMAT: "Format",
        DESIGN: "DESIGN",
        CHARTDESIGN: "Chart Design",
        ANALYZE: "Analyze",
		FileName: "File Name",
		Save: "Save",
		SaveFile: "Save the file ",
		HighlightCellRules:"Highlight Cell Rules",
		LightRedFillDark:"Light Red Fill with Dark Red Text",
		YellowFillDark:"Yellow Fill with Dark Yellow Text",
		GreenFillDark:"Green Fill with Dark Green Text",
		RedFill:"Red Fill",
		RedText:"Red Text",
		Column:"Column",
	    Bar:"Bar",
		DataValidationType: "Number/Decimal/Date/Time/TextLength/List",
		DataValidationAction: "greater than/greater than or equal to/less than/less than or equal to/equal to/not equal to/between/not between",
		FilterAlert: "This will remove a filtered range on your worksheet. To complete this task, please remove auto filters.",
		cellStyleAlert: "This style name already exists",
		modifyCellStyleAlert: "This style name does not exists",
		Modify: "Modify",
		StyleName: "Style Name",
		Clipboard: "Clipboard",
		Font: "Font",
		Actions: "Actions",
		Styles: "Styles",
		Editing: "Editing",
		Tables: "Tables",
		Illustrations: "Illustrations",
		Links: "Links",
		Charts: "Charts",
		DataTools: "Data Tools",
		Show: "Show",
		PageLayout: "Page Layout",
		Changes: "Changes",
		Window: "Window",
		Cells: "Cells",
		Calculation: "Calculation",
		Properties: "Properties",
		Tools: "Tools",
		TableStyleOption: "Table Style Options",
		ChartLayouts: "Chart Layouts",
		ChartDesignData: "Data",
		ChartDesignType: "Type",
		ChartDesignSize: "Size",
		Adjust: "Adjust",
		FormatSize: "Size",
		AnalyzePivotTable: "PivotTable",
		DataSource: "DataSource",
		Actions: "Actions",
		Apply: "Apply",
		FATTitlePrefix: "Table Style ",
        NewCellStyle:"New Cell Style",
        HighPoint:"High Point",
        LowPoint: "Low Point",
        FirstPoint: "First Point",
        LastPoint: "Last Point",
        NegativePoint: "Negative Points",
        Markers: "Markers",
        NegativePoints: "Negative Points",
        LineSparklineTitle:"Insert Line Sparkline",
        LineSparklineContent:"Sparklines are mini charts placed in a single cells,each representing a row of data in your selection",
        ColumnSparklineTitle:"Insert Column Sparkline",
        ColumnSparklineContent:"Sparklines are mini charts placed in a single cells,each representing a row of data in your selection",
        //PieSparklineTitle:"Insert Pie Sparkline",
        //PieSparklineContent:"sparklines are mini charts placed in a single cells,each representing a row of data in your selection",
        //AreaSparklineTitle:"Insert Area Sparkline",
        //AreaSparklineContent:"sparklines are mini charts placed in a single cells,each representing a row of data in your selection",
        WinLossSparklineTitle:"Insert Win/Loss Sparkline",
        WinLossSparklineContent:"Sparklines are mini charts placed in a single cells,each representing a row of data in your selection", 
        Line: "Line",
        SparklineColor: "Sparkline Color",
        SparklineColorTitle: "Sparkline Color",
        SparklineColorContent: "Specify the color of the sparklines in the selected sparkline group",
        MarkerColor: "Marker Color",
        MarkerColorContent: "Change the color for negative points, markers, and all other points for selected sparkline group",
        ChooseDataRange: "Choose the Data Range",
        ChooseLocationRange: "Choose the Location Range",
        DataRange: "Data Range",
        LocationRange: "Location Range",
        EmptyDLRnge: "Data Source or Location reference is not valid",
        SourceDataRange: "Select a source data range for the sparkline",
        SparklineAlert: "Location reference is not valid because the cells are not all in same column or same row. Select cells that are all in single row or single column ",
        SparklineDataAlert: "Enter the Correct Data Format",
        SparklineLocAlert: "The reference for the location or data range is not valid",
        SDataRangeAlert: "Data Source reference is not valid",
        //PieAlert: "Cannot create the pie chart for single value",
        LineAlert: "Cannot create the line chart for single value",
        EditData: "Edit Data",
        EditDataContent: "Edit Group Location & Data",
        EditSingleSparklineData: "Edit Single Sparkline Data",
        EditSparklineData:"Edit Sparkline Data",
        HiddenEmptyCells: "Hidden & Empty Cells",
        SwitchRowCol: "Switch Row/Column",
        CreateSparkline: "Create Sparkline",
        SelectDataSource: "Select a source data range for the sparkline",
        SPARKLINEDESIGN: "Sparkline Design",
		CancellationRequested: "Couldn't open within the timeout specified"
    };

    ej.Spreadsheet.scrollMode = {
        Normal: "normal",
        Infinite: "infinite"
    };

    ej.Spreadsheet.AutoFillOptions = {
        CopyCells: "copycells",
        FillSeries: "fillseries",
        FillFormattingOnly: "fillformattingonly",
        FillWithoutFormatting: "fillwithoutformatting",
        FlashFill: "flashfill"
    };

    ej.Spreadsheet.autoFillDirection = {
        Up: "up",
        Right: "right",
        Down: "down",
        Left: "left"
    };

    ej.Spreadsheet.pageSize = {
        A4: "A4",
        A3: "A3",
        Letter: "Letter"
    };

    ej.Spreadsheet.Actions = {
        Sorting: "sorting",
        Selection: "selection",
        AutoFill: "autofill",
        CellNavigation: "cellnavigation",
        Filtering: "filtering"
    };

    ej.Spreadsheet.exportType = {
        Excel: "Excel",
        Csv: "Csv",
        Pdf: "Pdf"
    };

    ej.Spreadsheet.CustomCellType = {
        Button: "Button",
        CheckBox: "CheckBox",
        DropDownList: "DropDownList",
        DatePicker: "DatePicker"
    };

    ej.Spreadsheet.CellType = {
        String: "string",
        Number: "number",
        Custom: "custom",
        Formula: "formula",
        Time: "time",
        LongDate: "longdate",
        ShortDate: "shortdate",
        Scientific: "scientific",
        Fraction: "fraction",
        Text: "text",
        General: "general",
        Accounting: "accounting",
        Currency: "currency",
        Percentage: "percentage",
        Date: "date",
        DateTime: "datetime"
    };

    ej.Spreadsheet.SupportedStyles = {
        FontFamily: "font-family",
        FontSize: "font-size",
        FontStyle: "font-style",
        FontWeight: "font-weight",
        TextAlign: "text-align",
        TextDecoration: "text-decoration",
        VerticalAlign: "vertical-align",
        TextIndent: "text-indent"
    };

    ej.Spreadsheet.Validation = {
        ">": "GreaterThan",
        ">=": "GreaterOrEqualTo",
        "<": "LessThan",
        "<=": "LessThanOrEqualTo",
        "==": "EqualTo",
        "!=": "NotEqualTo",
        "!": "Not",
        "=": ""
    };

    ej.Spreadsheet.ValidationText = {
        ">": "greater than",
        ">=": "greater than or equal to",
        "<": "less than",
        "<=": "less than or equal to",
        "==": "equal to",
        "!=": "not equal to",
        "!": " not",
        "=": ""
    };

    ej.Spreadsheet.msg = " ";

    ej.Spreadsheet.getMsg = function () {
        return ej.Spreadsheet.msg;
    };

    ej.Spreadsheet.SelectionType = {
        Row: "row",
        Column: "column",
        Default: "default"
    };

    ej.Spreadsheet.SelectionUnit = {
        Single: "single",
        Range: "range",
        MultiRange: "multirange"
    };

    ej.Spreadsheet.Align = {
        Left: "left",
        Right: "right",
        Center: "center"
    };

    ej.Spreadsheet.CFormatRule = {
        GreaterThan: "greaterthan",
        LessThan: "lessthan",
        Between: "between",
        EqualTo: "equalto",
        TextContains: "textcontains",
        DateOccur: "dateoccur"
    };

    ej.Spreadsheet.ContextMenu = {
        Cell: "cell",
        RowHeader: "rowheader",
        ColumnHeader: "columnheader",
        Footer: "footer"
    };

    ej.Spreadsheet.CFormatHighlightColor = {
        RedFillwithDarkRedText: "redft",
        YellowFillwithDarkYellowText: "yellowft",
        GreenFillwithDarkGreenText: "greenft",
        RedFill: "redf",
        RedText: "redt",
    };


    ej.Spreadsheet.BorderType = {
        Top: "top",
        Left: "left",
        Right: "right",
        Bottom: "bottom",
        OutSide: "outside",
        AllBorder: "allborder",
        ThickBox: "thickbox",
        ThickBottom: "thickbottom",
        TopandBottom: "topandbottom",
        TopandThickBottom: "topandthickbottom"
    };
    ej.Spreadsheet.ChartProperties = {
        PrimaryHorizontal: "PHAxis",
        PrimaryVertical: "PVAxis",
        PrimaryHorizontalAxisTitle: "PHAxisTitle",
        PrimaryVerticalAxisTitle: "PVAxisTitle",
        TitleNone: "CTNone",
        TitleCenter: "CTCenter",
        TitleFar: "CTFar",
        TitleNear: "CTNear",
        DataLabelNone: "DLNone",
        DataLabelCenter: "DLCenter",
        DataLabelInsideBase: "DLIBase",
        DataLabelInsideEnd: "DLIEnd",
        DataLabelOutsideEnd: "DLOEnd",
        PrimaryMajorHorizontal: "PMajorH",
        PrimaryMajorVertical: "PMajorV",
        PrimaryMinorHorizontal: "PMinorH",
        PrimaryMinorVertical: "PMinorV",
        LegendsNone: "LNone",
        LegendsLeft: "LLeft",
        LegendsRight: "LRight",
        LegendsBottom: "LBottom",
        LegendsTop: "LTop"
    };
    ej.Spreadsheet.HideTypes = {
        Default: "default",
        Freeze: "freeze"
    }
})(jQuery, Syncfusion);